System.register("chunks:///_virtual/absolute.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "bf087/OgI9HIaIKP+ZWp/tU", "absolute", undefined);
      var Absolute = exports('default', (_dec = register({
        menu: 'Math/Advanced/Absolute',
        title: 'Absolute'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Absolute, _ShaderNode);
        function Absolute() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Absolute.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = abs(" + input0 + ");\n        ";
        };
        return Absolute;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/add.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "37762nev7BLgIRh9U7rJXkP", "add", undefined);
      var Add = exports('default', (_dec = register({
        menu: 'Math/Basic/Add',
        title: 'Add'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Add, _ShaderNode);
        function Add() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Max;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Add.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = " + input0 + " + " + input1 + ";\n        ";
        };
        return Add;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/all.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "08b1ekFRoNLQ5UDBj6YtBOO", "all", undefined);
      var All = exports('default', (_dec = register({
        menu: 'Logic/All',
        title: 'All'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(All, _ShaderNode);
        function All() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Min;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', false, 'boolean', 'boolean')]
          };
          return _this;
        }
        var _proto = All.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var i0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          var elements = ['x', 'y', 'z', 'w'];
          var conditions = [];
          var precision = this.slots[0].concretePrecision;
          for (var i = 0; i < precision; i++) {
            conditions.push("(" + i0 + "." + elements[i] + " > 0.)");
          }
          return "\n            " + output0 + " = (" + conditions.join(' && ') + ");\n        ";
        };
        return All;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/and.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "ad796qaJ35K1pVtAoiLAQwn", "and", undefined);
      var And = exports('default', (_dec = register({
        menu: 'Logic/And',
        title: 'And'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(And, _ShaderNode);
        function And() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Max;
          _this.data = {
            inputs: [slot('A', false, 'boolean', 'boolean'), slot('B', false, 'boolean', 'boolean')],
            outputs: [slot('Out', false, 'boolean', 'boolean')]
          };
          return _this;
        }
        var _proto = And.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var i0 = this.getInputValue(0);
          var i1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = (" + i0 + " && " + i1 + ");\n        ";
        };
        return And;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AnimationGraph.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, CCBoolean, animation, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      CCBoolean = module.CCBoolean;
      animation = module.animation;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "9470cSQRxtAIYqQT5Sm+ZX6", "AnimationGraph", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var AnimationGraph = exports('AnimationGraph', (_dec = ccclass('AnimationGraph'), _dec2 = property(CCBoolean), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AnimationGraph, _Component);
        function AnimationGraph() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this._graph = void 0;
          _initializerDefineProperty(_this, "isPose", _descriptor, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = AnimationGraph.prototype;
        _proto.start = function start() {
          this._graph = this.getComponent(animation.AnimationController);
          if (this._graph === undefined || this._graph === null) {
            throw new Error(this.node.name + " can not find AnimationController");
          }
        };
        _proto.play = function play(key, value) {
          this.setValue(key, value);
        };
        _proto.setValue = function setValue(key, value) {
          if (this.isPose) {
            this._graph.setValue_experimental(key, value);
          } else {
            var _this$_graph;
            (_this$_graph = this._graph) == null || _this$_graph.setValue(key, value);
          }
        };
        _proto.setLayer = function setLayer(number, value) {
          this._graph.setLayerWeight(number, value);
        };
        _proto.update = function update(deltaTime) {};
        return AnimationGraph;
      }(Component), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "isPose", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AnimationGraphGroup.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AnimationGraph.ts', './Constants.ts'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, Component, AnimationGraph, CurrentEnviroment;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
    }, function (module) {
      AnimationGraph = module.AnimationGraph;
    }, function (module) {
      CurrentEnviroment = module.CurrentEnviroment;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "61dcf57FUBJ8oXIVFbL/HTv", "AnimationGraphGroup", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var AnimationGraphGroup = exports('AnimationGraphGroup', (_dec = ccclass('AnimationGraphGroup'), _dec(_class = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AnimationGraphGroup, _Component);
        function AnimationGraphGroup() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this._groups = void 0;
          _this.curActiveKey = "";
          return _this;
        }
        var _proto = AnimationGraphGroup.prototype;
        _proto.__preload = function __preload() {
          this._groups = this.getComponentsInChildren(AnimationGraph);
          if (this._groups === undefined || this._groups === null) {
            throw new Error(this.node.name + " node not find AnimationGraph");
          }
        };
        _proto.play = function play(key, value) {
          if (this.curActiveKey === key) return;
          this.curActiveKey = key;
          try {
            for (var i = 0; i < this._groups.length; i++) {
              this._groups[i].play(key, value);
            }
          } catch (e) {
            if (CurrentEnviroment.LOG) console.log(e);
          }
        };
        _proto.setLayer = function setLayer(number, value) {
          for (var i = 0; i < this._groups.length; i++) {
            this._groups[i].setLayer(number, value);
          }
        };
        return AnimationGraphGroup;
      }(Component)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AnimationPanel.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './VisiblePanel.ts', './Defines.ts', './easing.ts', './audioManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Enum, Vec3, v3, UIOpacity, tween, KeyCode, VisiblePanel, ViewBeginType, EasingType, getEasingFunction, AudioManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Enum = module.Enum;
      Vec3 = module.Vec3;
      v3 = module.v3;
      UIOpacity = module.UIOpacity;
      tween = module.tween;
      KeyCode = module.KeyCode;
    }, function (module) {
      VisiblePanel = module.VisiblePanel;
    }, function (module) {
      ViewBeginType = module.ViewBeginType;
    }, function (module) {
      EasingType = module.EasingType;
      getEasingFunction = module.getEasingFunction;
    }, function (module) {
      AudioManager = module.AudioManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _descriptor20, _descriptor21, _descriptor22;
      cclegacy._RF.push({}, "0ade8jDYZpLPZyun6PIe4u6", "AnimationPanel", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Animation panel that provides customizable show/hide animations for UI panels
       * Supports position, scale, rotation, and opacity animations with various easing functions
       */
      var AnimationPanel = exports('AnimationPanel', (_dec = ccclass('AnimationPanel'), _dec2 = property({
        group: {
          name: "Animation Settings",
          id: "animation"
        },
        tooltip: "Enable to customize animation settings"
      }), _dec3 = property({
        type: Enum(ViewBeginType),
        group: {
          name: "Animation Settings",
          id: "animation"
        },
        tooltip: "Initial state of the panel",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec4 = property({
        type: Vec3,
        group: {
          name: "Animation Settings",
          id: "animation"
        },
        tooltip: "Initial position of the panel",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec5 = property({
        group: {
          name: "Show Animation",
          id: "show"
        },
        tooltip: "Starting X position for show animation",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec6 = property({
        group: {
          name: "Show Animation",
          id: "show"
        },
        tooltip: "Starting Y position for show animation",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec7 = property({
        group: {
          name: "Show Animation",
          id: "show"
        },
        tooltip: "Starting scale for show animation",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec8 = property({
        type: Enum(EasingType),
        group: {
          name: "Show Animation",
          id: "show"
        },
        tooltip: "Easing function for show animation",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec9 = property({
        group: {
          name: "Hide Animation",
          id: "hide"
        },
        tooltip: "Ending X position for hide animation",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec10 = property({
        group: {
          name: "Hide Animation",
          id: "hide"
        },
        tooltip: "Ending Y position for hide animation",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec11 = property({
        group: {
          name: "Hide Animation",
          id: "hide"
        },
        tooltip: "Ending scale for hide animation",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec12 = property({
        type: Enum(EasingType),
        group: {
          name: "Hide Animation",
          id: "hide"
        },
        tooltip: "Easing function for hide animation",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec13 = property({
        group: {
          name: "Additional Settings",
          id: "additional"
        },
        tooltip: "Duration of show animation in seconds",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec14 = property({
        group: {
          name: "Additional Settings",
          id: "additional"
        },
        tooltip: "Duration of hide animation in seconds",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec15 = property({
        group: {
          name: "Additional Settings",
          id: "additional"
        },
        tooltip: "Enable rotation animation",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec16 = property({
        group: {
          name: "Additional Settings",
          id: "additional"
        },
        tooltip: "Starting rotation for show animation (in degrees)",
        visible: function visible() {
          return this.isShowPopupsetting && this.enableRotation;
        }
      }), _dec17 = property({
        group: {
          name: "Additional Settings",
          id: "additional"
        },
        tooltip: "Ending rotation for hide animation (in degrees)",
        visible: function visible() {
          return this.isShowPopupsetting && this.enableRotation;
        }
      }), _dec18 = property({
        group: {
          name: "Additional Settings",
          id: "additional"
        },
        tooltip: "Enable opacity animation",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec19 = property({
        group: {
          name: "Additional Settings",
          id: "additional"
        },
        tooltip: "Starting opacity for show animation (0-255)",
        visible: function visible() {
          return this.isShowPopupsetting && this.enableOpacity;
        }
      }), _dec20 = property({
        group: {
          name: "Additional Settings",
          id: "additional"
        },
        tooltip: "Ending opacity for hide animation (0-255)",
        visible: function visible() {
          return this.isShowPopupsetting && this.enableOpacity;
        }
      }), _dec21 = property({
        type: VisiblePanel,
        group: {
          name: "Background Settings",
          id: "background"
        },
        tooltip: "Background panel that dims when this panel is shown",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec22 = property({
        group: {
          name: "Background Settings",
          id: "background"
        },
        tooltip: "Duration of background dim animation in seconds",
        visible: function visible() {
          return this.isShowPopupsetting;
        }
      }), _dec23 = property({
        group: {
          name: "Audio Settings",
          id: "audio"
        },
        tooltip: "Sound effect to play when panel is shown"
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_VisiblePanel) {
        _inheritsLoose(AnimationPanel, _VisiblePanel);
        function AnimationPanel() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _VisiblePanel.call.apply(_VisiblePanel, [this].concat(args)) || this;
          //#region Animation Settings
          _initializerDefineProperty(_this, "isShowPopupsetting", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "beginType", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "beginPosition", _descriptor3, _assertThisInitialized(_this));
          //#region Show Animation Settings
          _initializerDefineProperty(_this, "showFromPosX", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "showFromPosY", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "showFromScale", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "showEasingType", _descriptor7, _assertThisInitialized(_this));
          //#endregion
          //#region Hide Animation Settings
          _initializerDefineProperty(_this, "hideToPosX", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "hideToPosY", _descriptor9, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "hideToScale", _descriptor10, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "hideEasingType", _descriptor11, _assertThisInitialized(_this));
          //#endregion
          //#region Additional Animation Settings
          _initializerDefineProperty(_this, "showDuration", _descriptor12, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "hideDuration", _descriptor13, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "enableRotation", _descriptor14, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "showFromRotation", _descriptor15, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "hideToRotation", _descriptor16, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "enableOpacity", _descriptor17, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "showFromOpacity", _descriptor18, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "hideToOpacity", _descriptor19, _assertThisInitialized(_this));
          //#endregion
          //#region Background Settings
          _initializerDefineProperty(_this, "dimNode", _descriptor20, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "dimDuration", _descriptor21, _assertThisInitialized(_this));
          //#endregion
          //#region Audio Settings
          _initializerDefineProperty(_this, "shownAudioName", _descriptor22, _assertThisInitialized(_this));
          //#endregion
          //#region Internal Properties
          _this.opMain = null;
          _this.visibleIndex = -1;
          _this.visibleTween = null;
          _this.scheduleDim = null;
          return _this;
        }
        var _proto = AnimationPanel.prototype;
        //#endregion
        //#region Lifecycle Methods
        _proto.onLoad = function onLoad() {
          var _this$dimNode, _this$dimNode2;
          this.node.setPosition(this.beginPosition);
          switch (this.beginType) {
            case ViewBeginType.NONE:
              this.visibleIndex = -1;
              break;
            case ViewBeginType.HIDE:
              this.visibleIndex = 0;
              this.setPanelVisible(false, 0.0);
              (_this$dimNode = this.dimNode) == null || _this$dimNode.setPanelVisible(false, 0.0);
              break;
            case ViewBeginType.SHOW:
              this.visibleIndex = 1;
              this.setPanelVisible(true, 0.0);
              (_this$dimNode2 = this.dimNode) == null || _this$dimNode2.setPanelVisible(true, 0.0);
              break;
          }
        }
        //#endregion

        //#region Animation Methods
        ;

        _proto.setAnimVisible = function setAnimVisible(isVisible, callback, timeAction) {
          if (callback === void 0) {
            callback = null;
          }
          if (timeAction === void 0) {
            timeAction = 0.35;
          }
          if (this.visibleIndex == (isVisible ? 1 : 0)) {
            callback == null || callback();
            return;
          }
          this.visibleIndex = isVisible ? 1 : 0;
          if (isVisible) {
            this.showAnimation(callback, timeAction);
          } else {
            this.hideAnimation(callback, timeAction);
          }
        };
        _proto.showAnimation = function showAnimation(callback, timeAction) {
          var _this$visibleTween;
          this.node.active = true;
          this.node.position = v3(this.showFromPosX, this.showFromPosY, 0.0);
          this.node.setScale(v3(this.showFromScale, this.showFromScale, this.showFromScale));
          if (this.enableRotation) {
            this.node.setRotationFromEuler(0, 0, this.showFromRotation);
          }
          if (this.enableOpacity) {
            this.opMain = this.getComponent(UIOpacity) || this.addComponent(UIOpacity);
            this.opMain.opacity = this.showFromOpacity;
          }
          (_this$visibleTween = this.visibleTween) == null || _this$visibleTween.stop();
          this.visibleTween = tween(this.node);

          // Position animation
          this.visibleTween.to(timeAction, {
            position: Vec3.ZERO
          }, {
            easing: this.getEasingShowAnim()
          });

          // Scale animation
          this.visibleTween.to(timeAction, {
            scale: Vec3.ONE
          }, {
            easing: this.getEasingShowAnim()
          });

          // Rotation animation
          if (this.enableRotation) {
            this.visibleTween.to(timeAction, {
              eulerAngles: new Vec3(0, 0, 0)
            }, {
              easing: this.getEasingShowAnim()
            });
          }

          // Opacity animation
          if (this.enableOpacity) {
            tween(this.opMain).to(timeAction, {
              opacity: 255
            }, {
              easing: this.getEasingShowAnim()
            }).start();
          }
          this.visibleTween.call(function () {
            return callback == null ? void 0 : callback();
          }).start();
          this.setDimBackground(true, timeAction, this.dimDuration);
        };
        _proto.hideAnimation = function hideAnimation(callback, timeAction) {
          var _this$visibleTween2,
            _this2 = this;
          (_this$visibleTween2 = this.visibleTween) == null || _this$visibleTween2.stop();
          this.visibleTween = tween(this.node);

          // Position animation
          this.visibleTween.to(timeAction, {
            position: v3(this.hideToPosX, this.hideToPosY, 0.0)
          }, {
            easing: this.getEasingHideAnim()
          });

          // Scale animation
          this.visibleTween.to(timeAction, {
            scale: v3(this.hideToScale, this.hideToScale, this.hideToScale)
          }, {
            easing: this.getEasingHideAnim()
          });

          // Rotation animation
          if (this.enableRotation) {
            this.visibleTween.to(timeAction, {
              eulerAngles: new Vec3(0, 0, this.hideToRotation)
            }, {
              easing: this.getEasingHideAnim()
            });
          }

          // Opacity animation
          if (this.enableOpacity) {
            tween(this.opMain).to(timeAction, {
              opacity: this.hideToOpacity
            }, {
              easing: this.getEasingHideAnim()
            }).start();
          }
          this.visibleTween.call(function () {
            _this2.node.active = false;
            callback == null || callback();
          }).start();
          this.setDimBackground(false, 0.0, this.dimDuration);
        };
        _proto.getEasingShowAnim = function getEasingShowAnim() {
          return getEasingFunction(this.showEasingType);
        };
        _proto.getEasingHideAnim = function getEasingHideAnim() {
          return getEasingFunction(this.hideEasingType);
        };
        _proto.setDimBackground = function setDimBackground(isDim, delay, time) {
          var _this3 = this;
          if (time === void 0) {
            time = 0.2;
          }
          if (this.dimNode == null) return;
          if (this.scheduleDim != null) {
            this.unschedule(this.scheduleDim);
          }
          this.scheduleDim = this.scheduleOnce(function () {
            return _this3.dimNode.setPanelVisible(isDim, time);
          }, delay);
        }
        //#endregion

        //#region Public Interface
        ;

        _proto.show = function show(data, callback) {
          var _this4 = this;
          if (this.shownAudioName && this.visibleIndex != 1) {
            AudioManager.instance.playSound(this.shownAudioName);
          }
          this.setAnimVisible(true, function () {
            _this4.shown();
            callback == null || callback();
          }, this.showDuration);
        };
        _proto.doShow = function doShow() {
          this.show(null, undefined);
        };
        _proto.doHide = function doHide() {
          this.hide(undefined);
        };
        _proto.hide = function hide(callback) {
          var _this5 = this;
          this.setAnimVisible(false, function () {
            _this5.hided();
            callback == null || callback();
          }, this.hideDuration);
        };
        _proto.shown = function shown() {
          // Override in derived classes
        };
        _proto.hided = function hided() {
          // Override in derived classes
        }
        //#endregion

        //#region Input Handling
        ;

        _proto.onKeyDown = function onKeyDown(event) {
          if (this.isEscable == false) return;
          if (event.keyCode === KeyCode.ESCAPE) {
            this.doHide();
          }
        };
        _proto.onTouch_Close = function onTouch_Close() {
          this.doHide();
        }
        //#endregion
        ;

        _createClass(AnimationPanel, [{
          key: "isShowing",
          get:
          //#endregion
          //#region Public Properties
          function get() {
            return this.visibleIndex == 1;
          }
        }, {
          key: "isEscable",
          get: function get() {
            return false;
          }
        }]);
        return AnimationPanel;
      }(VisiblePanel), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "isShowPopupsetting", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "beginType", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ViewBeginType.NONE;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "beginPosition", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return v3(0.0, 0.0, 0.0);
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "showFromPosX", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return -1080.0;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "showFromPosY", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.0;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "showFromScale", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1.0;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "showEasingType", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return EasingType.BackOut;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "hideToPosX", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1080.0;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "hideToPosY", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.0;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "hideToScale", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.0;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "hideEasingType", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return EasingType.BackIn;
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "showDuration", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.35;
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "hideDuration", [_dec14], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.25;
        }
      }), _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, "enableRotation", [_dec15], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor15 = _applyDecoratedDescriptor(_class2.prototype, "showFromRotation", [_dec16], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return -45;
        }
      }), _descriptor16 = _applyDecoratedDescriptor(_class2.prototype, "hideToRotation", [_dec17], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 45;
        }
      }), _descriptor17 = _applyDecoratedDescriptor(_class2.prototype, "enableOpacity", [_dec18], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor18 = _applyDecoratedDescriptor(_class2.prototype, "showFromOpacity", [_dec19], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor19 = _applyDecoratedDescriptor(_class2.prototype, "hideToOpacity", [_dec20], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor20 = _applyDecoratedDescriptor(_class2.prototype, "dimNode", [_dec21], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor21 = _applyDecoratedDescriptor(_class2.prototype, "dimDuration", [_dec22], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.2;
        }
      }), _descriptor22 = _applyDecoratedDescriptor(_class2.prototype, "shownAudioName", [_dec23], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return "";
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AnimatorController.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, SkeletalAnimation, Component;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      SkeletalAnimation = module.SkeletalAnimation;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "2d25eUq/olFcqr07UVxslCs", "AnimatorController", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var AnimatorController = exports('AnimatorController', (_dec = ccclass('AnimatorController'), _dec(_class = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AnimatorController, _Component);
        function AnimatorController() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this._anim = Object.create(null);
          _this._data = Object.create(null);
          return _this;
        }
        var _proto = AnimatorController.prototype;
        _proto.init = function init(data) {
          this._data = data;
          this._anim = this.getComponent(SkeletalAnimation);
        };
        _proto.play = function play(name) {
          var anims = this._data[name];
          this._anim.play(anims[0]);
        };
        return AnimatorController;
      }(Component)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/any.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "c213eN4ql1Fo5ECkorGOGam", "any", undefined);
      var Any = exports('default', (_dec = register({
        menu: 'Logic/Any',
        title: 'Any'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Any, _ShaderNode);
        function Any() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Min;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', false, 'boolean', 'boolean')]
          };
          return _this;
        }
        var _proto = Any.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var i0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          var elements = ['x', 'y', 'z', 'w'];
          var conditions = [];
          var precision = this.slots[0].concretePrecision;
          for (var i = 0; i < precision; i++) {
            conditions.push("(" + i0 + "." + elements[i] + " > 0.)");
          }
          return "\n            " + output0 + " = (" + conditions.join(' || ') + ");\n        ";
        };
        return Any;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/APIFakeData.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "bc1d75XEItMOZF3HZi0EoA3", "APIFakeData", undefined);
      var APIFakeData = exports('APIFakeData', {});
      var initFakeData = exports('initFakeData', function initFakeData() {
        {
          APIFakeData = exports('APIFakeData', {
            "users/info": {
              "user": {
                "_id": "663222212019da65ced1bd56",
                "telegram_id": "1565295243",
                "username": "Wisky3107",
                "ather_id": null,
                "guild_id": null,
                "first_name": "Wikz",
                "last_name": "",
                "language_code": "",
                "allows_write_to_pm": true,
                "turn": 952,
                "coin": 622874030.7038965,
                "shield": 2,
                "attack": 0,
                "steal": 0,
                "last_login": 1716190128276,
                "reward_time": 1716180385166,
                "attacking_island_id": null,
                "stealing_island_id_1": null,
                "stealing_island_id_2": null,
                "stealing_island_id_3": null,
                "total_pull": 465251,
                "__v": 0,
                "commulative_coin": 244620699.078597,
                "commulative_invite": 0,
                "commulative_invite_recevied": 0,
                "commulative_purchase": 0,
                "commulative_purchase_recevied": 0,
                "is_follow_x": false,
                "is_join_telegram_channel": false,
                "is_join_telegram_chat": false,
                "login_streak": 0,
                "premium_login_streak": 0,
                "premium_login_streak_received": 0,
                "ship": 0
              }
            }
          });
        }
      });
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/APIManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './env', './APIFakeData.ts', './Constants.ts'], function (exports) {
  var _asyncToGenerator, _regeneratorRuntime, cclegacy, DEBUG, initFakeData, APIFakeData, CurrentEnviroment;
  return {
    setters: [function (module) {
      _asyncToGenerator = module.asyncToGenerator;
      _regeneratorRuntime = module.regeneratorRuntime;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      DEBUG = module.DEBUG;
    }, function (module) {
      initFakeData = module.initFakeData;
      APIFakeData = module.APIFakeData;
    }, function (module) {
      CurrentEnviroment = module.CurrentEnviroment;
    }],
    execute: function () {
      exports({
        getApiKey: getApiKey,
        getEncrypedToken: getEncrypedToken,
        getToken: getToken,
        intervalPing: intervalPing,
        requestUserInfo: requestUserInfo,
        setAPIManagerURL: setAPIManagerURL,
        setApiKey: setApiKey,
        setFakeData: setFakeData,
        setKeyAuthen: setKeyAuthen,
        setToken: setToken,
        updateApiKey: updateApiKey
      });
      cclegacy._RF.push({}, "3b325m3/clNb7s376jIQ9MJ", "APIManager", undefined);
      var APIManager = /*#__PURE__*/function () {
        function APIManager() {
          var _this = this;
          this.baseURL = void 0;
          this.timeout = void 0;
          this.MAX_RETAKE_TOKEN = 5;
          this.retakeTokenTimesThisSession = 0;
          this.retakeToken = null;
          this.onFailedCallback = null;
          this.isLog = true;
          this.log = function (content) {
            if (_this.isLog) {
              if (CurrentEnviroment.LOG) console.log("[API] : ", content);
            }
          };
          this.baseURL = '';
          this.timeout = 30000;
        }
        var _proto = APIManager.prototype;
        _proto.setBaseURL = function setBaseURL(url) {
          this.baseURL = url;
        };
        _proto.setTimeout = function setTimeout(milliseconds) {
          this.timeout = milliseconds;
        };
        _proto.request = /*#__PURE__*/function () {
          var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(endpoint, config, callback, failHandler, key) {
            var data, isError, resData, response, _this$onFailedCallbac, _this$onFailedCallbac2, bytes, original;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  if (key === void 0) {
                    key = null;
                  }
                  data = null;
                  isError = false;
                  resData = null;
                  if (!key) {
                    key = apiKey;
                  }
                  _context.prev = 5;
                  _context.next = 8;
                  return this.fetchWithRetry(endpoint, config);
                case 8:
                  response = _context.sent;
                  if (response.ok) {
                    _context.next = 11;
                    break;
                  }
                  throw {
                    message: 'Network response was not ok',
                    statusCode: 777
                  };
                case 11:
                  _context.next = 13;
                  return response.json();
                case 13:
                  data = _context.sent;
                  this.log("data:" + data);
                  resData = data;
                  if (resData.statusCode && resData.statusCode != 200) {
                    isError = true;
                    this.log("Server response ERROR:" + resData.message);
                    failHandler(resData);
                    (_this$onFailedCallbac = this.onFailedCallback) == null || _this$onFailedCallbac.call(this, resData);
                  }
                  _context.next = 25;
                  break;
                case 19:
                  _context.prev = 19;
                  _context.t0 = _context["catch"](5);
                  isError = true;
                  this.log("ERROR:" + _context.t0);
                  failHandler(_context.t0);
                  (_this$onFailedCallbac2 = this.onFailedCallback) == null || _this$onFailedCallbac2.call(this, _context.t0);
                case 25:
                  if (!isError) {
                    //decrupt the data depend on the key 
                    try {
                      bytes = CryptoJS.AES.decrypt(resData.data, key);
                      original = bytes.toString(CryptoJS.enc.Utf8);
                      resData.data = JSON.parse(original);
                    } catch (e) {
                      this.log("resData: ERROR" + e);
                    }
                    callback(resData);
                  }
                case 26:
                case "end":
                  return _context.stop();
              }
            }, _callee, this, [[5, 19]]);
          }));
          function request(_x, _x2, _x3, _x4, _x5) {
            return _request.apply(this, arguments);
          }
          return request;
        }();
        _proto.fetchWithRetry = /*#__PURE__*/function () {
          var _fetchWithRetry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(endpoint, config, retries) {
            var attempts, url, response, isSuccess;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  if (retries === void 0) {
                    retries = 3;
                  }
                  attempts = 0;
                case 2:
                  if (!(attempts < retries)) {
                    _context2.next = 28;
                    break;
                  }
                  _context2.prev = 3;
                  url = this.baseURL + endpoint;
                  this.log("fetch " + url);
                  _context2.next = 8;
                  return this.timeoutPromise(fetch(url, config));
                case 8:
                  response = _context2.sent;
                  if (!(response.status == 401 && this.retakeToken)) {
                    _context2.next = 16;
                    break;
                  }
                  this.log("try get new token");
                  if (!(++this.retakeTokenTimesThisSession <= this.MAX_RETAKE_TOKEN)) {
                    _context2.next = 16;
                    break;
                  }
                  _context2.next = 14;
                  return this.retakeToken();
                case 14:
                  isSuccess = _context2.sent;
                  if (isSuccess) {
                    config.headers = headers();
                  }
                case 16:
                  if (!response.ok) {
                    _context2.next = 18;
                    break;
                  }
                  return _context2.abrupt("return", response);
                case 18:
                  _context2.next = 24;
                  break;
                case 20:
                  _context2.prev = 20;
                  _context2.t0 = _context2["catch"](3);
                  if (!(attempts === retries - 1)) {
                    _context2.next = 24;
                    break;
                  }
                  throw _context2.t0;
                case 24:
                  attempts++;
                  this.log("retry attemptes:" + attempts);
                  _context2.next = 2;
                  break;
                case 28:
                  throw {
                    message: 'All retries failed',
                    statusCode: 666
                  };
                case 29:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this, [[3, 20]]);
          }));
          function fetchWithRetry(_x6, _x7, _x8) {
            return _fetchWithRetry.apply(this, arguments);
          }
          return fetchWithRetry;
        }();
        _proto.timeoutPromise = function timeoutPromise(fetchPromise) {
          var _this2 = this;
          return new Promise(function (resolve, reject) {
            var timeoutId = setTimeout(function () {
              return reject(new Error('Request timed out'));
            }, _this2.timeout);
            fetchPromise.then(function (res) {
              clearTimeout(timeoutId);
              resolve(res);
            }, function (err) {
              clearTimeout(timeoutId);
              reject(err);
            });
          });
        };
        return APIManager;
      }();
      var isFakeData = false;
      if (isFakeData && DEBUG) {
        setFakeData();
      }
      function setFakeData() {
        isFakeData = true;
        initFakeData();
      }
      var CryptoJS = window["CryptoJS"];
      var token = "";
      var authenKey = "";
      var apiKey = "";
      var api = new APIManager();
      api.onFailedCallback = function (error) {
        // ClientEvent.dispatchEvent(GameConstant.EVENT_NAME.ON_API_FAILED, error);
      };
      setInterval(intervalPing, 300000); //ping every 5 minutes

      function intervalPing() {
        if (!token) return;
        // requestPing((data, error) => {
        //     if (error) {
        //         if (CurrentEnviroment.LOG) console.log("Ping ERROR");
        //         return;
        //     }
        //     if (CurrentEnviroment.LOG) console.log("Ping DONE");
        // });
      }

      function setAPIManagerURL(url) {
        api.setBaseURL(url);
      }
      function setKeyAuthen(key) {
        authenKey = key;
      }
      function getApiKey() {
        return apiKey;
      }
      function setApiKey(key) {
        apiKey = key;
      }
      var headers = exports('headers', function headers() {
        return {
          "Authorization": "Bearer " + token,
          'Content-Type': 'application/json'
        };
      });
      var postConfig = function postConfig(data, key) {
        if (data === void 0) {
          data = null;
        }
        if (!data) {
          return {
            method: 'POST',
            headers: headers()
          };
        }
        var encodedData = Object.keys(data).filter(function (key) {
          return data[key] !== null;
        }) // Filter out keys with null values
        .map(function (key) {
          return encodeURIComponent(key) + '=' + encodeURIComponent(data[key]);
        }).join('&');
        if (CurrentEnviroment.LOG) console.log("encoded data: " + encodedData);
        return {
          method: 'POST',
          headers: headers(),
          body: encodedData
        };
      };
      function setToken(input) {
        token = input;
      }
      function getToken() {
        return "Bearer " + token;
      }
      function getEncrypedToken() {
        return CryptoJS.AES.encrypt(getToken(), authenKey).toString();
      }
      function updateApiKey(user) {}
      function requestUserInfo(callback) {
        var apiName = "users/info";
        if (isFakeData && DEBUG) return callback == null ? void 0 : callback(APIFakeData[apiName], null);
        api.request(apiName, postConfig(), function (res) {
          callback == null || callback(res.data, null);
        }, function (error) {
          callback == null || callback(null, error);
        });
      }
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/arccosine.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "d296eo8ejhAz4SJ+Afh3Ceo", "arccosine", undefined);
      var Arccosine = exports('default', (_dec = register({
        menu: 'Math/Trigonometry/Arccosine',
        title: 'Arccosine'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Arccosine, _ShaderNode);
        function Arccosine() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Arccosine.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = acos(" + input0 + ");\n        ";
        };
        return Arccosine;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/arcsine.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "63135dmizRJ4Jf8BpVKF+Wm", "arcsine", undefined);
      var Arcsine = exports('default', (_dec = register({
        menu: 'Math/Trigonometry/Arcsine',
        title: 'Arcsine'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Arcsine, _ShaderNode);
        function Arcsine() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Arcsine.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = asin(" + input0 + ");\n        ";
        };
        return Arcsine;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/arctangent.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "2986999N5lOG433MyYF3lBY", "arctangent", undefined);
      var Arctangent = exports('default', (_dec = register({
        menu: 'Math/Trigonometry/Arctangent',
        title: 'Arctangent'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Arctangent, _ShaderNode);
        function Arctangent() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Arctangent.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = atan(" + input0 + ");\n        ";
        };
        return Arctangent;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/arctangent2.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "2a9c8rn4+VHWa4BXpsUBf1R", "arctangent2", undefined);
      var Arctangent2 = exports('default', (_dec = register({
        menu: 'Math/Trigonometry/Arctangent2',
        title: 'Arctangent2'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Arctangent2, _ShaderNode);
        function Arctangent2() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Arctangent2.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = atan2(" + input0 + ", " + input1 + ");\n        ";
        };
        return Arctangent2;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/assetRemoteUtil.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Constants.ts'], function (exports) {
  var _asyncToGenerator, _regeneratorRuntime, cclegacy, assetManager, SpriteAtlas, Texture2D, ImageAsset, SpriteFrame, CurrentEnviroment;
  return {
    setters: [function (module) {
      _asyncToGenerator = module.asyncToGenerator;
      _regeneratorRuntime = module.regeneratorRuntime;
    }, function (module) {
      cclegacy = module.cclegacy;
      assetManager = module.assetManager;
      SpriteAtlas = module.SpriteAtlas;
      Texture2D = module.Texture2D;
      ImageAsset = module.ImageAsset;
      SpriteFrame = module.SpriteFrame;
    }, function (module) {
      CurrentEnviroment = module.CurrentEnviroment;
    }],
    execute: function () {
      cclegacy._RF.push({}, "ad288/O58VDkJlgQZZZjRwu", "assetRemoteUtil", undefined);
      var assetRemoteUtil = exports('assetRemoteUtil', /*#__PURE__*/function () {
        function assetRemoteUtil() {}
        //#region bundle
        assetRemoteUtil.loadBundle = function loadBundle(bundleName, cb) {
          assetManager.loadBundle(bundleName, null, function (error, data) {
            if (error) {
              console.error(error);
              cb(error, null);
              return;
            }
            cb(null, data);
          });
        };
        assetRemoteUtil.loadAltas = function loadAltas(bundeName, atlasName, cb) {
          this.loadBundle(bundeName, function (error, bundle) {
            if (error) {
              cb == null || cb(error, null);
              return;
            }
            bundle.load(atlasName, SpriteAtlas, function (error, atlas) {
              if (error) {
                console.error(error);
                cb == null || cb(error, null);
                return;
              }
              cb == null || cb(null, atlas);
            });
          });
        };
        assetRemoteUtil.loadRemoteImage = /*#__PURE__*/function () {
          var _loadRemoteImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url) {
            var response, blob, image, imageLoadPromise, texture, sf;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  // Fetch the image data
                  url = "https://cors-anywhere.herokuapp.com/" + url;
                  _context.next = 4;
                  return fetch(url);
                case 4:
                  response = _context.sent;
                  if (response.ok) {
                    _context.next = 7;
                    break;
                  }
                  throw new Error("HTTP error! Status: " + response.status);
                case 7:
                  _context.next = 9;
                  return response.blob();
                case 9:
                  blob = _context.sent;
                  // Create an image element
                  image = new Image();
                  image.crossOrigin = 'Anonymous';
                  imageLoadPromise = new Promise(function (resolve, reject) {
                    image.onload = function () {
                      return resolve(image);
                    };
                    image.onerror = function () {
                      return reject(new Error('Failed to load image element'));
                    };
                  });
                  image.src = URL.createObjectURL(blob);

                  // Wait for the image to load
                  _context.next = 16;
                  return imageLoadPromise;
                case 16:
                  // Create a Texture2D from the image element
                  texture = new Texture2D();
                  texture.image = new ImageAsset(image);
                  sf = new SpriteFrame();
                  sf.texture = texture;
                  return _context.abrupt("return", sf);
                case 23:
                  _context.prev = 23;
                  _context.t0 = _context["catch"](0);
                  throw new Error("Failed to load remote image: " + _context.t0.message);
                case 26:
                case "end":
                  return _context.stop();
              }
            }, _callee, null, [[0, 23]]);
          }));
          function loadRemoteImage(_x) {
            return _loadRemoteImage.apply(this, arguments);
          }
          return loadRemoteImage;
        }() //#endregion
        //#region fetch image
        ;

        assetRemoteUtil.fetchImage = /*#__PURE__*/
        function () {
          var _fetchImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url) {
            var response, binaryData, base64String;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  if (url) {
                    _context2.next = 2;
                    break;
                  }
                  throw new Error("Failed to fetch image: URL is null or empty.");
                case 2:
                  _context2.prev = 2;
                  _context2.next = 5;
                  return fetch(url);
                case 5:
                  response = _context2.sent;
                  _context2.t0 = Uint8Array;
                  _context2.next = 9;
                  return response.arrayBuffer();
                case 9:
                  _context2.t1 = _context2.sent;
                  binaryData = new _context2.t0(_context2.t1);
                  base64String = this.bufferToBase64(binaryData);
                  return _context2.abrupt("return", this.convertBase64ToSpriteFrame(base64String));
                case 15:
                  _context2.prev = 15;
                  _context2.t2 = _context2["catch"](2);
                  throw new Error("Failed to get SpriteFrame: " + _context2.t2.message);
                case 18:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this, [[2, 15]]);
          }));
          function fetchImage(_x2) {
            return _fetchImage.apply(this, arguments);
          }
          return fetchImage;
        }();
        assetRemoteUtil.bufferToBase64 = function bufferToBase64(buffer) {
          var binary = Array.from(buffer).map(function (_byte) {
            return String.fromCharCode(_byte);
          }).join('');
          return btoa(binary);
        };
        assetRemoteUtil.convertBase64ToSpriteFrame = /*#__PURE__*/function () {
          var _convertBase64ToSpriteFrame = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(base64String) {
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  return _context3.abrupt("return", new Promise(function (resolve, reject) {
                    var img = new Image();
                    img.onload = function () {
                      var texture = new Texture2D();
                      texture.image = new ImageAsset(img);
                      var spriteFrame = new SpriteFrame();
                      spriteFrame.texture = texture;
                      resolve(spriteFrame);
                      URL.revokeObjectURL(img.src); // Free memory by revoking the object URL
                    };

                    img.onerror = function () {
                      reject(new Error('Failed to load base64 image'));
                      URL.revokeObjectURL(img.src); // Ensure memory is freed on error as well
                    };

                    img.src = 'data:image/png;base64,' + base64String;
                  }));
                case 1:
                case "end":
                  return _context3.stop();
              }
            }, _callee3);
          }));
          function convertBase64ToSpriteFrame(_x3) {
            return _convertBase64ToSpriteFrame.apply(this, arguments);
          }
          return convertBase64ToSpriteFrame;
        }() //#endregion
        //#region avatars
        ;

        assetRemoteUtil.loadAndListenAvatar = function loadAndListenAvatar(url, cb) {
          var _this = this;
          if (this.spriteFrameMap.has(url)) {
            cb == null || cb(this.spriteFrameMap.get(url));
            return;
          }
          if (!this.spriteCallbacks.has(url)) {
            this.spriteCallbacks.set(url, []);
          }
          this.spriteCallbacks.get(url).push(cb);
          if (this.loadingSprites.indexOf(url) >= 0) {
            return;
          }
          this.loadingSprites.push(url);
          var onDone = function onDone(sf) {
            _this.spriteFrameMap.set(url, sf);
            var cbs = _this.spriteCallbacks.get(url);
            cbs.forEach(function (func) {
              return func(sf);
            });
            _this.spriteCallbacks.set(url, []);
            _this.loadingSprites = _this.loadingSprites.filter(function (str) {
              return str !== url;
            });

            // Auto clear when reaching 100 records
            if (_this.spriteFrameMap.size > 100) {
              _this.spriteFrameMap.clear();
              if (CurrentEnviroment.LOG) console.log("SpriteFrameMap cache cleared due to exceeding 100 records.");
            }
            if (CurrentEnviroment.LOG) console.log("Total loaded avatar: ", _this.spriteFrameMap.size);
          };
          this.fetchImage(url).then(function (sf) {
            onDone(sf);
          })["catch"](function (err) {
            onDone(null);
          });
        };
        assetRemoteUtil.removeListenAvatar = function removeListenAvatar(url, cb) {
          if (this.spriteCallbacks.has(url) == false) return;
          this.spriteCallbacks.set(url, this.spriteCallbacks.get(url).filter(function (ccb) {
            return ccb != cb;
          }));
        }

        //#endregion
        ;

        return assetRemoteUtil;
      }());
      assetRemoteUtil.spriteFrameMap = new Map();
      assetRemoteUtil.loadingSprites = [];
      assetRemoteUtil.spriteCallbacks = new Map();
      assetRemoteUtil.loadedImages = [];
      assetRemoteUtil.loadedTextures = [];
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/audioManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Constants.ts', './storageManager.ts', './resourceUtil.ts'], function (exports) {
  var _createClass, cclegacy, _decorator, Node, director, game, AudioSource, AudioClip, tween, easing, GameConstant, CurrentEnviroment, StorageManager, resourceUtil;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      director = module.director;
      game = module.game;
      AudioSource = module.AudioSource;
      AudioClip = module.AudioClip;
      tween = module.tween;
      easing = module.easing;
    }, function (module) {
      GameConstant = module.GameConstant;
      CurrentEnviroment = module.CurrentEnviroment;
    }, function (module) {
      StorageManager = module.StorageManager;
    }, function (module) {
      resourceUtil = module.resourceUtil;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "d7ecda770NLF4OP1Afz5O5u", "audioManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var AudioManager = exports('AudioManager', (_dec = ccclass("AudioManager"), _dec(_class = (_class2 = /*#__PURE__*/function () {
        function AudioManager() {
          this.audioMap = new Map();
          this._persistRootNode = null;
          this._audioSources = [];
          this.dictWeaponSoundIndex = {};
          this.bgmVolume = 0.8;
          this.sfxVolume = 1;
          this.audios = {};
          this.arrSound = [];
          this.BGM_VOLUME = 0.35;
          this.SFX_VOLUME = 0.75;
          this.asMusic = null;
          this.curGetSFXSourceIndex = 0;
          this.tweenFadeMusic = null;
          this.init();
        }
        var _proto = AudioManager.prototype;
        _proto.init = function init() {
          if (this._persistRootNode) return; //
          this._persistRootNode = new Node('audio');
          director.getScene().addChild(this._persistRootNode);
          game.addPersistRootNode(this._persistRootNode);
          this.asMusic = this._persistRootNode.addComponent(AudioSource);
          for (var i = 0; i < 15; i++) {
            this._audioSources.push(this._persistRootNode.addComponent(AudioSource));
          }
          this.bgmVolume = this.getAudioSetting(true);
          this.sfxVolume = this.getAudioSetting(false);

          //mapping clips
          this.audioMap.clear();
        };
        _proto.getAudioSetting = function getAudioSetting(isMusic) {
          var state;
          if (isMusic) {
            var _StorageManager$insta;
            state = (_StorageManager$insta = StorageManager.instance.getGlobalData(GameConstant.STORAGE_KEY.BGM_VOLUME)) != null ? _StorageManager$insta : this.BGM_VOLUME;
          } else {
            var _StorageManager$insta2;
            state = (_StorageManager$insta2 = StorageManager.instance.getGlobalData(GameConstant.STORAGE_KEY.SFX_VOLUME)) != null ? _StorageManager$insta2 : this.SFX_VOLUME;
          }
          return state;
        };
        _proto.setBGMProgress = function setBGMProgress(progress) {
          this.bgmVolume = progress * this.BGM_VOLUME;
          StorageManager.instance.setGlobalData(GameConstant.STORAGE_KEY.BGM_VOLUME, this.bgmVolume);
        };
        _proto.setSFXProgress = function setSFXProgress(progress) {
          this.sfxVolume = progress * this.SFX_VOLUME;
          StorageManager.instance.setGlobalData(GameConstant.STORAGE_KEY.SFX_VOLUME, this.sfxVolume);
        };
        _proto.getSound = function getSound(name) {
          if (this.audioMap.has(name)) {
            return this.audioMap.get(name);
          }
          return null;
        };
        _proto.playMusic = function playMusic(name, loop) {
          var _this = this;
          var source = this.asMusic;
          var path = "sounds/bgm/" + name;
          resourceUtil.loadRes(path, AudioClip, function (error, clip) {
            if (error) {
              if (CurrentEnviroment.LOG) console.error(error);
              return;
            }
            if (!clip) return null;
            var tmp = {
              source: source,
              isMusic: true
            };
            _this.audios[name] = tmp;
            source.stop();
            source.clip = clip;
            source.volume = _this.bgmVolume;
            source.loop = loop;
            source.play();
          });
          return source;
        };
        _proto.setMusicFade = function setMusicFade(isFadeIn, time, callback) {
          var _this2 = this,
            _this$tweenFadeMusic;
          if (time === void 0) {
            time = 0.5;
          }
          if (callback === void 0) {
            callback = null;
          }
          var beginValue = isFadeIn ? 0.0 : 1.0;
          var endValue = isFadeIn ? 1.0 : 0.0;
          var gapValue = endValue - beginValue;
          var musicFadeValue = {
            value: beginValue
          };
          var onValueChanged = function onValueChanged(ratio) {
            var appliedValue = beginValue + ratio * gapValue;
            if (_this2.asMusic && _this2.bgmVolume) {
              _this2.asMusic.volume = _this2.bgmVolume * appliedValue;
            }
          };
          (_this$tweenFadeMusic = this.tweenFadeMusic) == null || _this$tweenFadeMusic.stop();
          this.tweenFadeMusic = tween(musicFadeValue).to(time, {
            value: endValue
          }, {
            easing: easing.linear,
            progress: function progress(s, e, c, r) {
              onValueChanged(r);
              return 0;
            }
          }).call(function () {
            return callback == null ? void 0 : callback();
          }).start();
        };
        _proto.dimAllSounds = function dimAllSounds() {
          this._audioSources.forEach(function (as) {
            as.volume = 0.0;
          });
        };
        _proto.playSound = function playSound(name, volumePercent) {
          var _this3 = this;
          if (volumePercent === void 0) {
            volumePercent = 1.0;
          }
          if (!this.sfxVolume) return;
          this.curGetSFXSourceIndex = ++this.curGetSFXSourceIndex % this._audioSources.length;
          var source = this._audioSources[this.curGetSFXSourceIndex];
          var path = "sounds/sfx/" + name;
          resourceUtil.loadRes(path, AudioClip, function (error, clip) {
            if (error) {
              if (CurrentEnviroment.LOG) console.error(error);
              return;
            }
            if (!clip) return;
            source.stop();
            source.clip = clip;
            source.currentTime = 0.0;
            source.volume = _this3.sfxVolume * volumePercent;
            source.play();
            // if (CurrentEnviroment.LOG) console.log("audiomanager sound played: ", name);
          });

          return source;
        };
        _proto.stop = function stop(name) {
          if (this.audios.hasOwnProperty(name)) {
            var audio = this.audios[name];
            audio.source.stop();
            audio.source.volume = 0.0;
          }
        };
        _proto.stopAll = function stopAll() {
          for (var i in this.audios) {
            if (this.audios.hasOwnProperty(i)) {
              var audio = this.audios[i];
              audio.source.stop();
              audio.source.clip = null;
            }
          }
          this.asMusic.stop();
          this.asMusic.clip = null;
        };
        _proto.getMusicVolume = function getMusicVolume() {
          return this.bgmVolume;
        };
        _proto.setMusic = function setMusic(flag) {
          var volume = flag * this.BGM_VOLUME;
          StorageManager.instance.setGlobalData(GameConstant.STORAGE_KEY.BGM_VOLUME, volume);
          this.bgmVolume = volume;
          this.asMusic.volume = this.bgmVolume;
        };
        _proto.pauseAll = function pauseAll() {
          if (CurrentEnviroment.LOG) console.log("pause all music!!!");
          for (var item in this.audios) {
            if (this.audios.hasOwnProperty(item)) {
              var audio = this.audios[item];
              audio.source.pause();
            }
          }
        };
        _proto.resumeAll = function resumeAll() {
          for (var item in this.audios) {
            if (this.audios.hasOwnProperty(item)) {
              var audio = this.audios[item];
              audio.source.play();
            }
          }
        };
        _proto.setSound = function setSound(flag) {
          var volume = flag * this.SFX_VOLUME;
          StorageManager.instance.setGlobalData(GameConstant.STORAGE_KEY.SFX_VOLUME, volume);
          this.sfxVolume = volume;
          for (var item in this.audios) {
            if (this.audios.hasOwnProperty(item) && !this.audios[item].isMusic) {
              // this.changeState(item, flag);
              var audio = this.audios[item];
              audio.source.volume = this.sfxVolume;
            }
          }
          for (var idx = 0; idx < this.arrSound.length; idx++) {
            var _audio = this.arrSound[idx];
            _audio.source.volume = this.sfxVolume;
          }
        };
        _proto.stopSingleSound = function stopSingleSound(name) {
          if (this.audios.hasOwnProperty(name) && !this.audios[name].isMusic) {
            var audio = this.audios[name];
            audio.source.stop();
          }
        };
        _createClass(AudioManager, [{
          key: "bgmProgress",
          get: function get() {
            return this.bgmVolume / this.BGM_VOLUME;
          }
        }, {
          key: "sfxProgress",
          get: function get() {
            return this.sfxVolume / this.SFX_VOLUME;
          }
        }]);
        return AudioManager;
      }(), _class2.instance = void 0, _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AudioManager2.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './audioManager.ts', './resourceUtil.ts', './MidiReader.ts'], function (exports) {
  var _createClass, _asyncToGenerator, _regeneratorRuntime, cclegacy, _decorator, Node, director, AudioSource, AudioClip, AudioManager, resourceUtil, loadMidi;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
      _asyncToGenerator = module.asyncToGenerator;
      _regeneratorRuntime = module.regeneratorRuntime;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      director = module.director;
      AudioSource = module.AudioSource;
      AudioClip = module.AudioClip;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      resourceUtil = module.resourceUtil;
    }, function (module) {
      loadMidi = module.loadMidi;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "3f1f3G1DxNPvqoVbgokQUjm", "AudioManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * AudioManager for Magic Tiles 3
       * Extends the common AudioManager with additional functionality for music synchronization with gameplay
       */
      var MagicTilesAudioManager = exports('MagicTilesAudioManager', (_dec = ccclass("MagicTilesAudioManager"), _dec(_class = (_class2 = /*#__PURE__*/function () {
        // Check actual time every 30 frames

        function MagicTilesAudioManager() {
          // Reference to the common audio manager
          this.commonAudioManager = AudioManager.instance;
          // Music source specifically for the beatmap playback
          this._beatmapAudioSource = null;
          // Current beatmap audio data
          this._currentBeatmap = null;
          // Callbacks for beat events
          this._beatCallbacks = [];
          // Audio buffering status
          this._isBuffering = false;
          // Timer for tracking audio playback position
          this._playbackTimer = 0;
          // Add properties for time estimation
          this.audioTimeEstimation = 0;
          this.lastSystemTime = 0;
          this._timeCheckCounter = 0;
          this._timeCheckInterval = 30;
          this.init();
        }
        var _proto = MagicTilesAudioManager.prototype;
        _proto.init = function init() {
          // Create a dedicated node for beatmap audio
          var beatmapNode = new Node('beatmap-audio');
          director.getScene().addChild(beatmapNode);

          // Create a dedicated audio source for beatmaps
          this._beatmapAudioSource = beatmapNode.addComponent(AudioSource);
        }

        /**
         * Load a beatmap audio file and its corresponding MIDI data
         * @param audioPath Path to the audio file
         * @param midiPath Path to the MIDI file
         * @param trackIndex Index of the MIDI track to use
         * @returns Promise that resolves when loading is complete
         */;
        _proto.loadBeatmapAudioData = /*#__PURE__*/
        function () {
          var _loadBeatmapAudioData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(audioPath, midiPath, trackIndex) {
            var _yield$Promise$all, audioClip, midiTrack;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  if (trackIndex === void 0) {
                    trackIndex = 1;
                  }
                  this._isBuffering = true;
                  _context.prev = 2;
                  _context.next = 5;
                  return Promise.all([this.loadAudioClip(audioPath), loadMidi(midiPath, trackIndex)]);
                case 5:
                  _yield$Promise$all = _context.sent;
                  audioClip = _yield$Promise$all[0];
                  midiTrack = _yield$Promise$all[1];
                  // Create beatmap audio data
                  this._currentBeatmap = {
                    clip: audioClip,
                    trackInfo: midiTrack,
                    totalDuration: audioClip.getDuration(),
                    currentTime: 0,
                    isPlaying: false,
                    isPaused: false
                  };

                  // Setup the audio source
                  this._beatmapAudioSource.clip = audioClip;
                  this._beatmapAudioSource.volume = 1.0;
                  // this._beatmapAudioSource.volume = this.commonAudioManager.getMusicVolume();

                  this._isBuffering = false;
                  return _context.abrupt("return", this._currentBeatmap);
                case 15:
                  _context.prev = 15;
                  _context.t0 = _context["catch"](2);
                  console.error("Failed to load beatmap audio:", _context.t0);
                  this._isBuffering = false;
                  return _context.abrupt("return", null);
                case 20:
                case "end":
                  return _context.stop();
              }
            }, _callee, this, [[2, 15]]);
          }));
          function loadBeatmapAudioData(_x, _x2, _x3) {
            return _loadBeatmapAudioData.apply(this, arguments);
          }
          return loadBeatmapAudioData;
        }();
        _proto.setCurrentBeatmap = function setCurrentBeatmap(beatmap) {
          this._currentBeatmap = beatmap;
          // Setup the audio source
          this._beatmapAudioSource.clip = beatmap.clip;
          this._beatmapAudioSource.volume = 1.0;
          this._isBuffering = false;
        }

        /**
         * Promise-based audio clip loading
         */;
        _proto.loadAudioClip = function loadAudioClip(path) {
          return new Promise(function (resolve, reject) {
            resourceUtil.loadRes(path, AudioClip, function (err, clip) {
              if (err) {
                reject(err);
                return;
              }
              resolve(clip);
            });
          });
        }

        /**
         * Start playing the beatmap audio
         * @param startTime Optional start time in seconds
         */;
        _proto.playBeatmapAudio = function playBeatmapAudio(startTime) {
          if (startTime === void 0) {
            startTime = 0;
          }
          if (!this._currentBeatmap || this._isBuffering) {
            console.warn("No beatmap loaded or still buffering");
            return;
          }
          this._currentBeatmap.currentTime = startTime;
          this._currentBeatmap.isPlaying = true;
          this._currentBeatmap.isPaused = false;
          this._beatmapAudioSource.currentTime = startTime;
          this._beatmapAudioSource.play();

          // Start tracking beats
          // this.startBeatTracking();
        }

        /**
         * Get estimated audio time with minimal overhead
         * Uses time estimation between actual audio time checks
         */;
        _proto.getEstimatedAudioTime = function getEstimatedAudioTime() {
          var currentTime = Date.now() / 1000;

          // Initialize if first call
          if (!this.lastSystemTime) {
            this.lastSystemTime = currentTime;
            this.audioTimeEstimation = this._beatmapAudioSource.currentTime;
            return this.audioTimeEstimation;
          }

          // Calculate time elapsed since last check
          var deltaTime = currentTime - this.lastSystemTime;

          // Update estimation
          this.audioTimeEstimation += deltaTime;

          // Periodically correct estimation (less frequently)
          if (this._timeCheckCounter++ % this._timeCheckInterval === 0) {
            var actualTime = this._beatmapAudioSource.currentTime;
            // Smoothly adjust to actual time
            this.audioTimeEstimation = 0.95 * this.audioTimeEstimation + 0.05 * actualTime;
          }
          this.lastSystemTime = currentTime;
          return this.audioTimeEstimation;
        }

        /**
         * Get the current audio time
         * This is the original method, but we now recommend using getEstimatedAudioTime()
         */;
        _proto.getAudioTime = function getAudioTime() {
          return this._beatmapAudioSource.currentTime;
        }

        /**
         * Pause the beatmap audio
         */;
        _proto.pauseBeatmapAudio = function pauseBeatmapAudio() {
          if (!this._currentBeatmap || !this._currentBeatmap.isPlaying) {
            return;
          }
          this._beatmapAudioSource.pause();
          this._currentBeatmap.isPaused = true;
          this._currentBeatmap.isPlaying = false;
        }

        /**
         * Resume the beatmap audio
         */;
        _proto.resumeBeatmapAudio = function resumeBeatmapAudio() {
          if (!this._currentBeatmap || !this._currentBeatmap.isPaused) {
            return;
          }
          this._beatmapAudioSource.play();
          this._currentBeatmap.isPaused = false;
          this._currentBeatmap.isPlaying = true;
        }

        /**
         * Stop the beatmap audio
         */;
        _proto.stopBeatmapAudio = function stopBeatmapAudio() {
          if (!this._currentBeatmap) {
            return;
          }
          this._beatmapAudioSource.stop();
          this._currentBeatmap.isPlaying = false;
          this._currentBeatmap.isPaused = false;
          this._currentBeatmap.currentTime = 0;
        }

        /**
         * Get the current playback time of the beatmap audio
         */;
        _proto.getCurrentTime = function getCurrentTime() {
          if (!this._currentBeatmap) {
            return 0;
          }
          return this._beatmapAudioSource.currentTime;
        }

        /**
         * Get the total duration of the current beatmap
         */;
        _proto.getTotalDuration = function getTotalDuration() {
          if (!this._currentBeatmap) {
            return 0;
          }
          return this._currentBeatmap.totalDuration;
        }

        /**
         * Register a callback to be called on each beat
         * @param callback Function to call on each beat
         */;
        _proto.onBeat = function onBeat(callback) {
          this._beatCallbacks.push(callback);
        }

        /**
         * Remove a beat callback
         * @param callback The callback to remove
         */;
        _proto.offBeat = function offBeat(callback) {
          var index = this._beatCallbacks.indexOf(callback);
          if (index !== -1) {
            this._beatCallbacks.splice(index, 1);
          }
        }

        /**
         * Start tracking beats from the MIDI file and call registered callbacks
         */;
        _proto.startBeatTracking = function startBeatTracking() {
          var _this = this;
          if (!this._currentBeatmap || !this._currentBeatmap.trackInfo.notes) {
            return;
          }

          // Clean up any existing timer
          this.stopBeatTracking();

          // Track note timings and call callbacks
          var notes = this._currentBeatmap.trackInfo.notes;
          var nextNoteIndex = 0;

          // Use requestAnimationFrame for more precise timing
          var trackBeats = function trackBeats() {
            if (!_this._currentBeatmap || !_this._currentBeatmap.isPlaying) {
              return;
            }
            var currentTime = _this._beatmapAudioSource.currentTime;

            // Check if we've reached any new notes
            while (nextNoteIndex < notes.length && notes[nextNoteIndex].time <= currentTime) {
              // Call all beat callbacks with the note info
              _this._beatCallbacks.forEach(function (callback) {
                callback(notes[nextNoteIndex]);
              });
              nextNoteIndex++;
            }

            // Continue tracking
            requestAnimationFrame(trackBeats);
          };

          // Start tracking
          requestAnimationFrame(trackBeats);
        }

        /**
         * Stop tracking beats
         */;
        _proto.stopBeatTracking = function stopBeatTracking() {
          // This will naturally stop the requestAnimationFrame loop
          if (this._currentBeatmap) {
            this._currentBeatmap.isPlaying = false;
          }
        }

        /**
         * Set the music volume
         * @param volume Volume from 0 to 1
         */;
        _proto.setMusicVolume = function setMusicVolume(volume) {
          this._beatmapAudioSource.volume = volume;
        }

        /**
         * Get the music volume
         */;
        _proto.getMusicVolume = function getMusicVolume() {
          return this._beatmapAudioSource.volume;
        }

        /**
         * Check if beatmap audio is still buffering
         */;
        _proto.isBuffering = function isBuffering() {
          return this._isBuffering;
        }

        /**
         * Check if beatmap audio is currently playing
         */;
        _proto.isPlaying = function isPlaying() {
          return this._currentBeatmap ? this._currentBeatmap.isPlaying : false;
        }

        /**
         * Check if beatmap audio is currently paused
         */;
        _proto.isPaused = function isPaused() {
          return this._currentBeatmap ? this._currentBeatmap.isPaused : false;
        }

        /**
         * Play a sound effect through the common audio manager
         */;
        _proto.playSound = function playSound(name, volumePercent) {
          var _this$commonAudioMana;
          if (volumePercent === void 0) {
            volumePercent = 1.0;
          }
          return (_this$commonAudioMana = this.commonAudioManager) == null ? void 0 : _this$commonAudioMana.playSound(name, volumePercent);
        }

        /**
         * Create BeatmapAudioData directly from already loaded assets
         * Useful for drag-and-drop functionality where assets are loaded outside the resource system
         * 
         * @param audioClip The already loaded AudioClip
         * @param midiTrack The already parsed MIDI track data
         * @returns Promise that resolves with the BeatmapAudioData
         */;
        _proto.createBeatmapAudioDataFromAssets = /*#__PURE__*/
        function () {
          var _createBeatmapAudioDataFromAssets = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(audioClip, midiTrack) {
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  this._isBuffering = true;
                  _context2.prev = 1;
                  // Create beatmap audio data directly from the provided assets
                  this._currentBeatmap = {
                    clip: audioClip,
                    trackInfo: midiTrack,
                    totalDuration: audioClip.getDuration(),
                    currentTime: 0,
                    isPlaying: false,
                    isPaused: false
                  };

                  // Setup the audio source
                  this._beatmapAudioSource.clip = audioClip;
                  this._beatmapAudioSource.volume = 1.0;
                  // this._beatmapAudioSource.volume = this.commonAudioManager.getMusicVolume();

                  this._isBuffering = false;
                  return _context2.abrupt("return", this._currentBeatmap);
                case 9:
                  _context2.prev = 9;
                  _context2.t0 = _context2["catch"](1);
                  console.error("Failed to create beatmap audio from assets:", _context2.t0);
                  this._isBuffering = false;
                  return _context2.abrupt("return", null);
                case 14:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this, [[1, 9]]);
          }));
          function createBeatmapAudioDataFromAssets(_x4, _x5) {
            return _createBeatmapAudioDataFromAssets.apply(this, arguments);
          }
          return createBeatmapAudioDataFromAssets;
        }();
        _createClass(MagicTilesAudioManager, null, [{
          key: "instance",
          get:
          // Singleton pattern
          function get() {
            if (!this._instance) {
              this._instance = new MagicTilesAudioManager();
            }
            return this._instance;
          }
        }]);
        return MagicTilesAudioManager;
      }(), _class2._instance = null, _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionAudioManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './resourceUtil.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, AudioSource, AudioClip, Component, resourceUtil;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      AudioSource = module.AudioSource;
      AudioClip = module.AudioClip;
      Component = module.Component;
    }, function (module) {
      resourceUtil = module.resourceUtil;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _class3;
      cclegacy._RF.push({}, "d703e2K9thB05Xmm4wf/DzN", "AuditionAudioManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Audio Manager for Audition module
       * Handles music playback, sound effects, and audio synchronization
       */
      var AuditionAudioManager = exports('AuditionAudioManager', (_dec = ccclass('AuditionAudioManager'), _dec2 = property(AudioSource), _dec3 = property(AudioSource), _dec4 = property({
        range: [0, 1]
      }), _dec5 = property({
        range: [0, 1]
      }), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionAudioManager, _Component);
        function AuditionAudioManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "musicFolder", _descriptor, _assertThisInitialized(_this));
          // Audio sources for music and sound effects
          _initializerDefineProperty(_this, "musicSource", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "sfxSource", _descriptor3, _assertThisInitialized(_this));
          // Audio settings
          _initializerDefineProperty(_this, "audioOffset", _descriptor4, _assertThisInitialized(_this));
          // Calibration offset in milliseconds
          _initializerDefineProperty(_this, "musicVolume", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "sfxVolume", _descriptor6, _assertThisInitialized(_this));
          // Internal properties
          _this.soundEffects = new Map();
          _this.startTime = 0;
          _this.isPaused = false;
          _this.pauseTime = 0;
          return _this;
        }
        var _proto = AuditionAudioManager.prototype;
        _proto.onLoad = function onLoad() {
          // Make this a singleton
          if (AuditionAudioManager._instance === null) {
            AuditionAudioManager._instance = this;

            // Initialize audio sources if they weren't set in the Inspector
            if (!this.musicSource) {
              this.musicSource = this.node.addComponent(AudioSource);
              this.musicSource.loop = true;
              this.musicSource.volume = this.musicVolume;
            }
            if (!this.sfxSource) {
              this.sfxSource = this.node.addComponent(AudioSource);
              this.sfxSource.loop = false;
              this.sfxSource.volume = this.sfxVolume;
            }
            this.loadSoundEffects();
          } else {
            this.node.destroy();
          }
        }

        /**
         * Preload common sound effects
         */;
        _proto.loadSoundEffects = function loadSoundEffects() {
          var _this2 = this;
          // const sfxList = ['perfect', 'good', 'miss', 'click', 'combo'];
          var sfxList = ['good', 'miss', 's_ready', 's_go'];

          // Load base sound effects
          sfxList.forEach(function (sfx) {
            resourceUtil.loadRes("audition/audio/sfx/" + sfx, AudioClip, function (err, clip) {
              if (err) {
                console.error("Failed to load sound effect: " + sfx, err);
                return;
              }
              _this2.soundEffects.set(sfx, clip);
              console.log("Sound effect loaded: " + sfx);
            });
          });

          // Load perfect sound variations (1-5)
          var _loop = function _loop() {
            var perfectSound = i === 1 ? 'perfect' : "perfect" + i;
            resourceUtil.loadRes("audition/audio/sfx/" + perfectSound, AudioClip, function (err, clip) {
              if (err) {
                console.error("Failed to load perfect sound effect: " + perfectSound, err);
                return;
              }
              _this2.soundEffects.set(perfectSound, clip);
              console.log("Perfect sound effect loaded: " + perfectSound);
            });
          };
          for (var i = 1; i <= 5; i++) {
            _loop();
          }
        }

        /**
         * Load a song audio file
         * @param songPath Path to the song audio file
         * @returns Promise that resolves when the song is loaded
         */;
        _proto.loadSong = function loadSong(songPath) {
          var _this3 = this;
          return new Promise(function (resolve, reject) {
            console.log("Loading song: " + songPath);
            var fullPath = _this3.musicFolder + songPath;
            resourceUtil.loadRes(fullPath, AudioClip, function (err, clip) {
              if (err) {
                console.error("Failed to load song: " + fullPath, err);
                reject(err);
                return;
              }
              _this3.musicSource.clip = clip;
              console.log("Song loaded: " + fullPath);
              resolve();
            });
          });
        }

        /**
         * Play the loaded song
         * @param startTime Start time in milliseconds (default: 0)
         */;
        _proto.playSong = function playSong(startTime) {
          if (startTime === void 0) {
            startTime = 0;
          }
          if (!this.musicSource.clip) {
            console.error('No song loaded');
            return;
          }

          // Convert milliseconds to seconds for AudioSource
          this.musicSource.currentTime = startTime / 1000;
          this.startTime = Date.now() - startTime;
          this.isPaused = false;
          this.musicSource.play();
          console.log("Playing song from " + startTime + "ms");
        }

        /**
         * Pause the current song
         */;
        _proto.pauseSong = function pauseSong() {
          if (!this.musicSource.playing) {
            return;
          }
          this.musicSource.pause();
          this.isPaused = true;
          this.pauseTime = this.getCurrentTime();
          console.log("Song paused at " + this.pauseTime + "ms");
        }

        /**
         * Resume the paused song
         */;
        _proto.resumeSong = function resumeSong() {
          if (!this.isPaused) {
            return;
          }
          this.musicSource.play();
          this.startTime = Date.now() - this.pauseTime;
          this.isPaused = false;
          console.log("Song resumed from " + this.pauseTime + "ms");
        }

        /**
         * Stop the current song
         */;
        _proto.stopSong = function stopSong() {
          this.musicSource.stop();
          this.isPaused = false;
          console.log('Song stopped');
        }

        /**
         * Get the current playback position
         * @returns Current time in milliseconds
         */;
        _proto.getCurrentTime = function getCurrentTime() {
          if (this.isPaused) {
            return this.pauseTime;
          }

          // if (!this.musicSource.playing) {
          //     return 0;
          // }

          return this.musicSource.currentTime * 1000;
          // return Date.now() - this.startTime + this.audioOffset;
        };

        _proto.getDuration = function getDuration() {
          return this.musicSource.clip.getDuration() * 1000;
        }

        /**
         * Play a sound effect
         * @param soundId ID of the sound effect to play
         */;
        _proto.playSound = function playSound(soundId) {
          var clip = this.soundEffects.get(soundId);
          if (!clip) {
            console.warn("Sound effect not found: " + soundId);
            return;
          }
          this.sfxSource.playOneShot(clip);
        }

        /**
         * Set music volume
         * @param volume Volume level (0-1)
         */;
        _proto.setMusicVolume = function setMusicVolume(volume) {
          this.musicVolume = Math.max(0, Math.min(1, volume));
          this.musicSource.volume = this.musicVolume;
        }

        /**
         * Set sound effects volume
         * @param volume Volume level (0-1)
         */;
        _proto.setSfxVolume = function setSfxVolume(volume) {
          this.sfxVolume = Math.max(0, Math.min(1, volume));
          this.sfxSource.volume = this.sfxVolume;
        }

        /**
         * Get music volume
         * @returns Music volume level (0-1)
         */;
        _proto.getMusicVolume = function getMusicVolume() {
          return this.musicVolume;
        }

        /**
         * Get sound effects volume
         * @returns Sound effects volume level (0-1)
         */;
        _proto.getSfxVolume = function getSfxVolume() {
          return this.sfxVolume;
        }

        /**
         * Set audio offset for calibration
         * @param offset Offset in milliseconds
         */;
        _proto.setAudioOffset = function setAudioOffset(offset) {
          this.audioOffset = offset;
          console.log("Audio offset set to " + offset + "ms");
        }

        /**
         * Get current audio offset
         * @returns Offset in milliseconds
         */;
        _proto.getAudioOffset = function getAudioOffset() {
          return this.audioOffset;
        }

        /**
         * Calibrate audio offset by measuring system latency
         * This is a simplified implementation and might need adjustment
         */;
        _proto.calibrateAudioOffset = function calibrateAudioOffset() {
          // TODO: Implement a more sophisticated calibration method
          // This could involve playing a sound and asking the user to tap in rhythm
          console.log('Audio calibration initiated');

          // For now, just use a default offset
          this.audioOffset = -50; // Common default adjustment
          console.log("Audio calibrated with offset: " + this.audioOffset + "ms");
        };
        _createClass(AuditionAudioManager, null, [{
          key: "instance",
          get:
          // Singleton pattern implementation
          function get() {
            return this._instance;
          }
        }]);
        return AuditionAudioManager;
      }(Component), _class3._instance = null, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "musicFolder", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 'audition/music/';
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "musicSource", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "sfxSource", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "audioOffset", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "musicVolume", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.7;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "sfxVolume", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1.0;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionBeatmap.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AuditionNotePool.ts'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, Component, AuditionNoteType;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
    }, function (module) {
      AuditionNoteType = module.AuditionNoteType;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "b36e0MayvRDhqtAvXGvTrjp", "AuditionBeatmap", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Interface for individual note data within a beatmap
       */

      /**
       * Interface for beatmap data structure
       */

      /**
       * Class for generating and managing beatmap data
       */
      var AuditionBeatmap = exports('AuditionBeatmap', (_dec = ccclass('AuditionBeatmap'), _dec(_class = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionBeatmap, _Component);
        function AuditionBeatmap() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Currently loaded beatmap
          _this.currentBeatmap = null;
          return _this;
        }
        var _proto = AuditionBeatmap.prototype;
        /**
         * Generate a beatmap based on BPM and quantization
         * @param songId The song ID
         * @param bpm The beats per minute
         * @param durationMs The song duration in milliseconds
         * @param quantization The note quantization (e.g., 4 for quarter notes, 8 for eighth notes, 16 for sixteenth notes)
         * @returns Promise that resolves with the beatmap data
         */
        _proto.generateBeatmap = function generateBeatmap(songId, bpm, durationMs, quantization) {
          var _this2 = this;
          return new Promise(function (resolve) {
            var notes = [];
            var beatInterval = 60000 / bpm; // ms per beat
            var spaceNoteInterval = beatInterval * quantization; // ms per note

            // Start after 1 second and end 2 seconds before song end
            var currentTime = 1000;
            var endTime = durationMs - 2000;
            while (currentTime < endTime) {
              // Add SPACE note at each quantization point
              notes.push({
                time: currentTime,
                type: 2 // SPACE type
              });

              currentTime += spaceNoteInterval;
            }
            var beatmapData = {
              songId: songId,
              bpm: bpm,
              offset: 0,
              notes: notes,
              difficulty: 2,
              creator: 'System',
              version: '1.0'
            };
            _this2.currentBeatmap = beatmapData;
            console.log("Beatmap generated successfully: " + beatmapData.songId);
            resolve(beatmapData);
          });
        }

        /**
         * Get the currently loaded beatmap
         * @returns The current beatmap data or null if none loaded
         */;
        _proto.getCurrentBeatmap = function getCurrentBeatmap() {
          return this.currentBeatmap;
        }

        /**
         * Get all notes in a specific time range
         * @param startTime Start time in milliseconds
         * @param endTime End time in milliseconds
         * @returns Array of notes within the time range
         */;
        _proto.getNotesInTimeRange = function getNotesInTimeRange(startTime, endTime) {
          if (!this.currentBeatmap || !this.currentBeatmap.notes) {
            return [];
          }
          return this.currentBeatmap.notes.filter(function (note) {
            return note.time >= startTime && note.time <= endTime;
          });
        }

        /**
         * Get the next notes to spawn based on look-ahead time
         * @param currentTime Current song time in milliseconds
         * @param lookAheadTime Time to look ahead in milliseconds
         * @returns Array of notes that should be spawned
         */;
        _proto.getNotesToSpawn = function getNotesToSpawn(currentTime, lookAheadTime) {
          return this.getNotesInTimeRange(currentTime, currentTime + lookAheadTime);
        }

        /**
         * Get total number of notes in the beatmap
         * @returns The total note count
         */;
        _proto.getTotalNoteCount = function getTotalNoteCount() {
          var _this$currentBeatmap;
          return ((_this$currentBeatmap = this.currentBeatmap) == null || (_this$currentBeatmap = _this$currentBeatmap.notes) == null ? void 0 : _this$currentBeatmap.length) || 0;
        }

        /**
         * Convert a BeatNote to the corresponding AuditionNoteType
         * @param note The beat note to convert
         * @returns The corresponding AuditionNoteType
         */;
        AuditionBeatmap.getNoteTypeFromBeatNote = function getNoteTypeFromBeatNote(note) {
          return AuditionNoteType.SPACE; // All notes are SPACE type
        };

        return AuditionBeatmap;
      }(Component)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionBeatSystem.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AuditionAudioManager.ts', './AuditionInputHandler.ts', './AuditionNotePool.ts', './AuditionNote.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Node, Sprite, UIOpacity, Label, CCFloat, Vec3, Color, Tween, tween, Component, AuditionAudioManager, AuditionInputHandler, AuditionInputType, AuditionNotePool, AuditionNoteType, AuditionNote;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Sprite = module.Sprite;
      UIOpacity = module.UIOpacity;
      Label = module.Label;
      CCFloat = module.CCFloat;
      Vec3 = module.Vec3;
      Color = module.Color;
      Tween = module.Tween;
      tween = module.tween;
      Component = module.Component;
    }, function (module) {
      AuditionAudioManager = module.AuditionAudioManager;
    }, function (module) {
      AuditionInputHandler = module.AuditionInputHandler;
      AuditionInputType = module.AuditionInputType;
    }, function (module) {
      AuditionNotePool = module.AuditionNotePool;
      AuditionNoteType = module.AuditionNoteType;
    }, function (module) {
      AuditionNote = module.AuditionNote;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15;
      cclegacy._RF.push({}, "e8f01vW2ehGAbebHt2Bdk2+", "AuditionBeatSystem", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Accuracy ratings for note hits
       */
      var AuditionAccuracyRating = exports('AuditionAccuracyRating', /*#__PURE__*/function (AuditionAccuracyRating) {
        AuditionAccuracyRating[AuditionAccuracyRating["PERFECT"] = 0] = "PERFECT";
        AuditionAccuracyRating[AuditionAccuracyRating["GOOD"] = 1] = "GOOD";
        AuditionAccuracyRating[AuditionAccuracyRating["MISS"] = 2] = "MISS";
        return AuditionAccuracyRating;
      }({}));

      /**
       * Level sequence types
       */
      var LevelSequenceType = exports('LevelSequenceType', /*#__PURE__*/function (LevelSequenceType) {
        LevelSequenceType["OFF"] = "off";
        LevelSequenceType["LEVEL"] = "lv";
        LevelSequenceType["FINISH"] = "finish";
        return LevelSequenceType;
      }({}));

      /**
       * Level sequence data
       */

      /**
       * Beat System for Audition module
       * Manages single note movement and timing evaluation
       */
      var AuditionBeatSystem = exports('AuditionBeatSystem', (_dec = ccclass('AuditionBeatSystem'), _dec2 = property({
        type: Node,
        group: {
          name: "Visual Elements",
          id: "visual"
        }
      }), _dec3 = property({
        type: Node,
        group: {
          name: "Visual Elements",
          id: "visual"
        }
      }), _dec4 = property({
        type: Node,
        group: {
          name: "Visual Elements",
          id: "visual"
        }
      }), _dec5 = property({
        type: Node,
        group: {
          name: "Visual Elements",
          id: "visual"
        }
      }), _dec6 = property({
        type: Sprite,
        group: {
          name: "Visual Elements",
          id: "visual"
        }
      }), _dec7 = property({
        type: UIOpacity,
        group: {
          name: "Visual Elements",
          id: "visual"
        }
      }), _dec8 = property({
        type: Label,
        group: {
          name: "Visual Elements",
          id: "visual"
        }
      }), _dec9 = property({
        group: {
          name: "Beat Settings",
          id: "beat"
        }
      }), _dec10 = property({
        group: {
          name: "Beat Settings",
          id: "beat"
        }
      }), _dec11 = property({
        group: {
          name: "Timing Windows",
          id: "timing"
        }
      }), _dec12 = property({
        group: {
          name: "Timing Windows",
          id: "timing"
        }
      }), _dec13 = property({
        group: {
          name: "Timing Windows",
          id: "timing"
        }
      }), _dec14 = property({
        type: AuditionNotePool,
        group: {
          name: "Note Settings",
          id: "notes"
        }
      }), _dec15 = property({
        type: Node,
        group: {
          name: "Note Settings",
          id: "notes"
        }
      }), _dec16 = property({
        type: CCFloat,
        group: {
          name: "Note Settings",
          id: "notes"
        }
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionBeatSystem, _Component);
        function AuditionBeatSystem() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          //#region Properties - Visual Elements
          // Visual nodes and UI elements for gameplay visualization
          _initializerDefineProperty(_this, "movingBeatNote", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "targetZone", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "startNode", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "endNode", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "heartBeatSprite", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "opacityGameplay", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "levelLabel", _descriptor7, _assertThisInitialized(_this));
          //#endregion
          //#region Properties - Beat Settings
          // Core beat timing and rhythm settings
          _initializerDefineProperty(_this, "bpm", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "beatsPerLoop", _descriptor9, _assertThisInitialized(_this));
          //#endregion
          //#region Properties - Timing Windows
          // Accuracy evaluation windows for note hits
          _initializerDefineProperty(_this, "perfectWindow", _descriptor10, _assertThisInitialized(_this));
          // 50ms for perfect hit
          _initializerDefineProperty(_this, "goodWindow", _descriptor11, _assertThisInitialized(_this));
          // 100ms for good hit
          _initializerDefineProperty(_this, "missWindow", _descriptor12, _assertThisInitialized(_this));
          // 200ms for miss
          //#endregion
          //#region Properties - Note Settings
          // Note pool and positioning configuration
          _initializerDefineProperty(_this, "notePool", _descriptor13, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "nodeContainer", _descriptor14, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "nodeDistance", _descriptor15, _assertThisInitialized(_this));
          //#endregion
          //#region Game State
          // Core game state variables
          _this.isPlaying = false;
          _this.timingWindows = new Map();
          _this.currentLoop = 0;
          _this.lastBeatTime = 0;
          _this.songDuration = 0;
          _this.isAutoPlay = false;
          _this.scoringCallback = null;
          _this.readyCallback = null;
          _this.levelChangedCallback = null;
          //#endregion
          //#region Note Movement
          // Note movement and positioning variables
          _this.startX = -500;
          _this.endX = 500;
          _this.targetX = 0;
          _this.noteSpeed = 0;
          // Speed in units per second
          _this.noteDelay = 0;
          // Delay in seconds to hit target zone at right time
          //#endregion
          //#region Level System
          // Level progression and sequence management
          _this.currentLevel = 0;
          _this.currentLevelLoop = 0;
          _this.requiredNotes = 0;
          _this.currentNotes = 0;
          _this.isInDelay = false;
          _this.delayLoops = 0;
          _this.levelSequences = [];
          _this.currentSequenceIndex = 0;
          _this.penaltyPatternLoops = 0;
          //#endregion
          //#region Note Tracking
          // Active note and sequence tracking
          _this.activeNoteIds = [];
          _this.noteSequence = [];
          _this.currentSequenceNotes = [];
          return _this;
        }
        var _proto = AuditionBeatSystem.prototype;
        //#endregion
        //#region Lifecycle Methods
        _proto.onLoad = function onLoad() {
          // Setup timing windows
          this.timingWindows.set(AuditionAccuracyRating.PERFECT, this.perfectWindow);
          this.timingWindows.set(AuditionAccuracyRating.GOOD, this.goodWindow);
          this.timingWindows.set(AuditionAccuracyRating.MISS, this.missWindow);
          this.startX = this.startNode.position.x;
          this.endX = this.endNode.position.x;
          this.targetX = this.targetZone.position.x;
          this.updateSpeed();

          // Make sure we have the note
          if (!this.movingBeatNote) {
            console.error('No note assigned to AuditionBeatSystem!');
            return;
          }

          // Set initial position
          this.movingBeatNote.position = new Vec3(this.startX, this.startNode.position.y, this.startNode.position.z);

          // Initialize heartbeat sprite if available
          if (this.heartBeatSprite) {
            this.heartBeatSprite.node.scale = new Vec3(1, 1, 1);
          }

          //test auto plays
          // this.setAutoPlay(true);
        }
        //#endregion

        //#region Core Gameplay Methods
        ;

        _proto.updateSpeed = function updateSpeed() {
          // Calculate note speed based on distance and timing
          var distance = this.endX - this.startX;
          var beatTime = 60000 / this.bpm / 1000; // Convert to seconds
          var beatInterval = beatTime * this.beatsPerLoop;
          this.noteSpeed = distance / beatInterval;

          // Calculate delay needed to hit target zone at right time
          var distanceToEnd = this.endX - this.targetX;
          this.noteDelay = distanceToEnd / distance * beatInterval;
        };
        _proto.getCurrentTime = function getCurrentTime() {
          return AuditionAudioManager.instance.getCurrentTime();
        };
        _proto.update = function update(dt) {
          if (!this.isPlaying || !this.movingBeatNote) return;
          var audioManager = AuditionAudioManager.instance;
          if (!audioManager) return;
          var currentTime = this.getCurrentTime();
          var beatTime = 60000 / this.bpm;
          var beatInterval = beatTime * this.beatsPerLoop;

          // Check if it's time for the next beat
          if (currentTime - this.lastBeatTime >= beatInterval + this.missWindow) {
            this.lastBeatTime = Math.round(currentTime / beatInterval) * beatInterval;
            this.currentLoop++;
            this.updateLevelSystem();
          }
          this.updateBeatNoteMoving(currentTime);
          this.updateHeartBeatEffect(currentTime, beatTime, beatInterval);

          // Handle auto-play
          this.handleAutoPlay();
        }
        //#endregion

        //#region Level System Methods
        ;

        _proto.initializeLevelSequences = function initializeLevelSequences() {
          this.levelSequences = [{
            type: LevelSequenceType.OFF,
            loop: 3,
            notes: 0
          }, {
            type: LevelSequenceType.LEVEL,
            loop: 1,
            notes: 1
          }, {
            type: LevelSequenceType.LEVEL,
            loop: 1,
            notes: 2
          }, {
            type: LevelSequenceType.LEVEL,
            loop: 1,
            notes: 3
          }, {
            type: LevelSequenceType.LEVEL,
            loop: 1,
            notes: 4
          }, {
            type: LevelSequenceType.LEVEL,
            loop: 1,
            notes: 5
          }, {
            type: LevelSequenceType.LEVEL,
            loop: 4,
            notes: 6,
            delay: 1
          }, {
            type: LevelSequenceType.LEVEL,
            loop: 4,
            notes: 7,
            delay: 1
          }, {
            type: LevelSequenceType.LEVEL,
            loop: 4,
            notes: 8,
            delay: 1
          }, {
            type: LevelSequenceType.LEVEL,
            loop: 4,
            notes: 9,
            delay: 1
          }, {
            type: LevelSequenceType.FINISH,
            loop: 1,
            notes: 9
          }];
        };
        _proto.startBeatSystem = function startBeatSystem(bpm, songDuration, disableLoops) {
          var _this2 = this;
          if (!this.movingBeatNote) return;
          this.bpm = bpm;
          this.updateSpeed();
          this.isPlaying = true;
          this.songDuration = songDuration;

          // Initialize level system
          this.initializeLevelSequences();
          this.currentSequenceIndex = 0;
          this.currentLevel = 0;
          this.currentNotes = 0;
          this.penaltyPatternLoops = 0;
          this.activeNoteIds = [];
          this.noteSequence = [];

          // Initialize lastBeatTime with current audio time
          var audioManager = AuditionAudioManager.instance;
          if (audioManager) {
            this.lastBeatTime = audioManager.getCurrentTime();
          } else {
            this.lastBeatTime = Date.now();
          }
          this.currentLoop = 0;

          // Register input callbacks
          var inputHandler = AuditionInputHandler.instance;
          if (inputHandler) {
            inputHandler.registerInputCallback(AuditionInputType.SPACE, function (time) {
              return _this2.evaluateInput(time);
            });
            inputHandler.registerInputCallback(AuditionInputType.LEFT, function (time) {
              return _this2.handleNoteInput(AuditionNoteType.LEFT, time);
            });
            inputHandler.registerInputCallback(AuditionInputType.RIGHT, function (time) {
              return _this2.handleNoteInput(AuditionNoteType.RIGHT, time);
            });
          }
          console.log('Beat system started with level sequences');

          //setup frist sequence
          this.isInDelay = false;
          this.delayLoops = 0;
          this.currentLevelLoop = 0;
          this.updateGameplayInteractableVisualize();
          var beatTime = 60000 / this.bpm / 1000; // Convert to seconds
          var beatInterval = beatTime * this.beatsPerLoop * 4;
          var readyCallbackTime = Math.max(0, beatInterval - 1.0);
          this.scheduleOnce(function () {
            if (_this2.readyCallback) {
              _this2.readyCallback();
              _this2.readyCallback = null;
            }
          }, readyCallbackTime);
        };
        _proto.updateLevelSystem = function updateLevelSystem() {
          var _this3 = this;
          if (this.noteSequence.length > 0) {
            this.handleMiss(); //if reach this but not perfect
          }

          this.clearLastNotes();
          if (this.isInDelay) {
            this.delayLoops--;
            if (this.delayLoops <= 0) {
              this.isInDelay = false;
            }
            return;
          }
          var startNewSequence = function startNewSequence(sequence) {
            if (_this3.isInPenalty) {
              _this3.penaltyPatternLoops--;
            }
            _this3.startNextPattern();
            if (sequence.delay) {
              _this3.delayLoops = sequence.delay;
              _this3.isInDelay = true;
            }
          };
          var currentSequence = this.levelSequences[this.currentSequenceIndex];

          // Check if current pattern is complete
          if (this.currentLevelLoop >= currentSequence.loop) {
            this.currentSequenceIndex++;
            if (this.currentSequenceIndex >= this.levelSequences.length) {
              this.currentSequenceIndex = 0; //reset to wait phase
              this.penaltyPatternLoops = 0;
            }
            var nextSequence = this.levelSequences[this.currentSequenceIndex];
            if (nextSequence.type === LevelSequenceType.OFF) {
              this.delayLoops = nextSequence.loop;
              this.currentLevelLoop = nextSequence.loop; //no need wait loop cause already wait in InDelay
              this.isInDelay = true;
            } else if (nextSequence.type === LevelSequenceType.LEVEL) {
              this.currentLevel = nextSequence.notes;
              this.currentLevelLoop = 1;
              this.updateLevelTextNormal(this.currentLevel);
              if (this.levelChangedCallback) {
                this.levelChangedCallback(this.currentLevel, nextSequence.type);
              }
              startNewSequence(nextSequence);
            } else if (nextSequence.type === LevelSequenceType.FINISH) {
              // Handle finish sequence
              this.currentLevelLoop = 1;
              startNewSequence(nextSequence);
              this.updateLevelTextFinish();
            }
          } else {
            this.currentLevelLoop++;
            if (currentSequence.type === LevelSequenceType.LEVEL) {
              startNewSequence(currentSequence);
            }
          }
        };
        _proto.startNextPattern = function startNextPattern() {
          var sequence = this.levelSequences[this.currentSequenceIndex];
          // Set required notes to match the level number (not the sequence value)
          this.requiredNotes = sequence.notes;
          this.currentNotes = 0;
          this.noteSequence = [];
          this.currentSequenceNotes = [];
          // Calculate starting X position to center the sequence
          var startX = -(this.nodeDistance * this.requiredNotes / 2) + this.nodeDistance / 2;

          // Generate random note sequence
          for (var i = 0; i < this.requiredNotes; i++) {
            var noteType = Math.random() < 0.5 ? AuditionNoteType.LEFT : AuditionNoteType.RIGHT;
            this.noteSequence.push(noteType);

            // Create note visual
            var _this$notePool$getNot = this.notePool.getNote(noteType),
              id = _this$notePool$getNot.id,
              node = _this$notePool$getNot.node;
            node.parent = this.nodeContainer;
            if (node) {
              this.activeNoteIds.push(id);
              var note = node.getComponent(AuditionNote);
              note.initialize(noteType, this.lastBeatTime, id);
              this.currentSequenceNotes.push(note);
              // Position the note using the configured nodeDistance property
              node.setPosition(new Vec3(startX + i * this.nodeDistance, 0, 0));
            }
          }
          this.updateGameplayInteractableVisualize();
        };
        _proto.updateLevelTextNormal = function updateLevelTextNormal(level) {
          if (this.levelLabel) {
            this.levelLabel.string = "Level " + level.toString();
            // Set shadow color based on level
            if (level <= 3) {
              this.levelLabel.shadowColor = new Color(0, 0, 0, 255); // Black shadow for early levels
            } else if (level <= 6) {
              this.levelLabel.shadowColor = new Color(0, 0, 128, 255); // Navy blue for mid levels
            } else if (level <= 9) {
              this.levelLabel.shadowColor = new Color(128, 0, 128, 255); // Purple for higher levels
            } else {
              this.levelLabel.shadowColor = new Color(178, 34, 34, 255); // Firebrick red for top levels
            }
          }

          // Animate the level label with a scale tween
          if (this.levelLabel) {
            // Stop any existing tween
            Tween.stopAllByTarget(this.levelLabel.node);
            // Set initial scale
            this.levelLabel.node.setScale(new Vec3(1.5, 1.5, 1));
            // Create and play the scale animation
            tween(this.levelLabel.node).to(0.3, {
              scale: new Vec3(1, 1, 1)
            }, {
              easing: 'bounceOut'
            }).start();
          }
        };
        _proto.updateLevelTextFinish = function updateLevelTextFinish() {
          if (this.levelLabel) {
            this.levelLabel.string = "Finish Move";
            // Set shadow color for finish move to a vibrant gold/orange color
            this.levelLabel.shadowColor = new Color(255, 165, 0, 255); // Gold/Orange for finish move

            // Stop any existing tween
            Tween.stopAllByTarget(this.levelLabel.node);

            // Set initial scale
            this.levelLabel.node.setScale(new Vec3(1, 1, 1));

            // Create a looping scale animation
            tween(this.levelLabel.node).to(0.5, {
              scale: new Vec3(1.2, 1.2, 1)
            }).to(0.5, {
              scale: new Vec3(1, 1, 1)
            }).union().repeatForever().start();
          }
        }
        //#endregion

        //#region Input Handling
        ;

        _proto.handleNoteInput = function handleNoteInput(noteType, time) {
          if (!this.isPlaying || this.isInPenalty) return;
          if (this.currentNotes >= this.noteSequence.length) return; //if user finished the sequence

          // Check if the note matches the sequence
          if (this.currentNotes < this.noteSequence.length && this.noteSequence[this.currentNotes] === noteType) {
            this.currentSequenceNotes[this.currentNotes].playHitEffect(AuditionAccuracyRating.PERFECT);
            this.currentNotes++;
          } else {
            // Wrong note pressed
            this.currentNotes = 0;
            this.currentSequenceNotes.forEach(function (note) {
              return note.reset();
            });
          }
        };
        _proto.evaluateInput = function evaluateInput(time) {
          if (!this.isPlaying || this.isInPenalty) return;
          if (this.noteSequence.length == 0) return; //can not press space if not note sequence

          var audioManager = AuditionAudioManager.instance;
          if (!audioManager) return;
          var currentTime = this.getCurrentTime();
          var beatInterval = 60000 / this.bpm * this.beatsPerLoop;
          var timeSinceLastBeat = currentTime - this.lastBeatTime;

          // Calculate how close to the target the note is
          var targetProgress = 1.0; // Note should be at target when beat occurs
          var currentProgress = timeSinceLastBeat / beatInterval;
          var distanceFromTarget = Math.abs(targetProgress - currentProgress);

          // Determine accuracy rating
          var accuracyRating;
          if (distanceFromTarget <= this.timingWindows.get(AuditionAccuracyRating.PERFECT) / beatInterval) {
            accuracyRating = AuditionAccuracyRating.PERFECT;
          } else if (distanceFromTarget <= this.timingWindows.get(AuditionAccuracyRating.GOOD) / beatInterval) {
            accuracyRating = AuditionAccuracyRating.GOOD;
          } else {
            accuracyRating = AuditionAccuracyRating.MISS;
          }
          if (this.isMiss() || accuracyRating == AuditionAccuracyRating.MISS) {
            this.handleMiss();
          } else {
            this.handleScored(accuracyRating);
          }
        };
        _proto.handleAutoPlay = function handleAutoPlay() {
          if (!this.isAutoPlay || !this.isPlaying || this.isInPenalty) return;
          var currentTime = this.getCurrentTime();
          var beatInterval = 60000 / this.bpm * this.beatsPerLoop;
          var timeSinceLastBeat = currentTime - this.lastBeatTime;
          var targetProgress = 1.0;
          var currentProgress = timeSinceLastBeat / beatInterval;
          var distanceFromTarget = Math.abs(targetProgress - currentProgress);

          // Auto-play logic
          if (this.noteSequence.length > 0 && this.currentNotes < this.noteSequence.length) {
            // Auto-press the correct note
            var inputHandler = AuditionInputHandler.instance;
            if (inputHandler) {
              var noteType = this.noteSequence[this.currentNotes];
              if (noteType === AuditionNoteType.LEFT) {
                inputHandler.simulateInput(AuditionInputType.LEFT, currentTime);
              } else if (noteType === AuditionNoteType.RIGHT) {
                inputHandler.simulateInput(AuditionInputType.RIGHT, currentTime);
              }
            }
          }

          // Auto-press space at the right time
          if (distanceFromTarget <= this.timingWindows.get(AuditionAccuracyRating.PERFECT) / beatInterval) {
            var _inputHandler = AuditionInputHandler.instance;
            if (_inputHandler) {
              _inputHandler.simulateInput(AuditionInputType.SPACE, currentTime);
            }
          }
        }
        //#endregion

        //#region Note Management
        ;

        _proto.clearLastNotes = function clearLastNotes() {
          var _this4 = this;
          // Recycle all active notes
          this.activeNoteIds.forEach(function (id) {
            return _this4.notePool.recycleNote(id);
          });
          this.activeNoteIds = [];
          this.noteSequence = [];
          this.currentNotes = 0;
        };
        _proto.handleMiss = function handleMiss() {
          if (this.isInPenalty) return;
          this.penaltyPatternLoops = 2; //can not play next patterns

          if (this.scoringCallback) {
            this.scoringCallback(AuditionAccuracyRating.MISS);
          }
          this.updateGameplayInteractableVisualize();
        };
        _proto.handleScored = function handleScored(rating) {
          this.clearLastNotes();
          if (this.scoringCallback) {
            this.scoringCallback(rating);
          }
        };
        _proto.isMiss = function isMiss() {
          return this.currentNotes < this.requiredNotes;
        }
        //#endregion

        //#region Visual Effects
        ;

        _proto.updateBeatNoteMoving = function updateBeatNoteMoving(currentTime) {
          // Move note using speed-based movement based on audio time with delay
          var checkTime = currentTime - this.lastBeatTime;
          var timeSinceLastBeat = checkTime / 1000 - this.noteDelay; // Convert to seconds
          var newX = this.startX;
          if (timeSinceLastBeat > 0) {
            newX = this.startX + this.noteSpeed * timeSinceLastBeat;
          } else {
            newX = this.endX + this.noteSpeed * timeSinceLastBeat;
          }
          this.movingBeatNote.position = new Vec3(newX, this.movingBeatNote.position.y, this.movingBeatNote.position.z);
        };
        _proto.updateHeartBeatEffect = function updateHeartBeatEffect(currentTime, beatTime, beatInterval) {
          // Visualize heartbeat effect based on proximity to beat time
          if (!this.heartBeatSprite) return;
          var checkTime = currentTime - this.lastBeatTime;
          // Calculate how close we are to the next beat
          var normalizedPosition = currentTime % beatTime;
          var isApplyScale = checkTime > beatInterval - beatTime * 0.5 && checkTime < beatInterval + beatTime * 0.5;
          var scale = isApplyScale ? Math.max(1.0, (1.0 - normalizedPosition / beatTime) * 2.0) : 1.0;
          // Apply scale to note
          this.heartBeatSprite.node.setScale(new Vec3(scale, 1.0, 1.0));

          // Set alpha based on beat proximity
          var alpha = Math.max(0.5, 1.0 - normalizedPosition / beatTime);
          // Apply alpha to heartbeat sprite
          var color = this.heartBeatSprite.color.clone();
          color.a = alpha * 255;
          this.heartBeatSprite.color = color;
        };
        _proto.updateGameplayInteractableVisualize = function updateGameplayInteractableVisualize() {
          if (!this.opacityGameplay) return;
          var isPlayable = !this.isInPenalty && this.isPlaying;
          this.opacityGameplay.opacity = isPlayable ? 255 : 50;
        }
        //#endregion

        //#region Public Interface
        ;

        _proto.stopBeatSystem = function stopBeatSystem() {
          var _this5 = this;
          this.isPlaying = false;
          this.isAutoPlay = false;

          // Unregister input callback
          var inputHandler = AuditionInputHandler.instance;
          if (inputHandler) {
            inputHandler.unregisterInputCallback(AuditionInputType.SPACE, function (time) {
              return _this5.evaluateInput(time);
            });
            inputHandler.unregisterInputCallback(AuditionInputType.LEFT, function (time) {
              return _this5.handleNoteInput(AuditionNoteType.LEFT, time);
            });
            inputHandler.unregisterInputCallback(AuditionInputType.RIGHT, function (time) {
              return _this5.handleNoteInput(AuditionNoteType.RIGHT, time);
            });
          }
          console.log('Beat system stopped');
        };
        _proto.setScoreCallback = function setScoreCallback(callback) {
          this.scoringCallback = callback;
        };
        _proto.setReadyCallback = function setReadyCallback(callback) {
          this.readyCallback = callback;
        };
        _proto.setLevelChangedCallback = function setLevelChangedCallback(callback) {
          this.levelChangedCallback = callback;
        };
        _proto.getBPM = function getBPM() {
          return this.bpm;
        };
        _proto.setBPM = function setBPM(bpm) {
          this.bpm = Math.max(60, Math.min(200, bpm));
          console.log("BPM set to " + this.bpm);
        };
        _proto.getBeatsPerLoop = function getBeatsPerLoop() {
          return this.beatsPerLoop;
        };
        _proto.setBeatsPerLoop = function setBeatsPerLoop(beats) {
          this.beatsPerLoop = Math.max(1, Math.min(8, beats));
          console.log("Beats per loop set to " + this.beatsPerLoop);
        };
        _proto.setAutoPlay = function setAutoPlay(enabled) {
          this.isAutoPlay = enabled;
          console.log("Auto-play " + (enabled ? 'enabled' : 'disabled'));
        };
        _proto.isAutoPlayEnabled = function isAutoPlayEnabled() {
          return this.isAutoPlay;
        }
        //#endregion
        ;

        _createClass(AuditionBeatSystem, [{
          key: "isInPenalty",
          get: function get() {
            return this.penaltyPatternLoops > 0;
          }
        }]);
        return AuditionBeatSystem;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "movingBeatNote", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "targetZone", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "startNode", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "endNode", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "heartBeatSprite", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "opacityGameplay", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "levelLabel", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "bpm", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 120;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "beatsPerLoop", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 4;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "perfectWindow", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 50;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "goodWindow", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 100;
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "missWindow", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 200;
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "notePool", [_dec14], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, "nodeContainer", [_dec15], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor15 = _applyDecoratedDescriptor(_class2.prototype, "nodeDistance", [_dec16], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 65;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionCharacterAnimation.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AuditionBeatSystem.ts', './AuditionCharacterAnimationData.ts', './resourceUtil.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _asyncToGenerator, _regeneratorRuntime, _createForOfIteratorHelperLoose, cclegacy, _decorator, Node, Animation, Component, Prefab, instantiate, SkeletalAnimation, AuditionAccuracyRating, AuditionCharacterAnimationData, SpecialStateType, resourceUtil;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _asyncToGenerator = module.asyncToGenerator;
      _regeneratorRuntime = module.regeneratorRuntime;
      _createForOfIteratorHelperLoose = module.createForOfIteratorHelperLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Animation = module.Animation;
      Component = module.Component;
      Prefab = module.Prefab;
      instantiate = module.instantiate;
      SkeletalAnimation = module.SkeletalAnimation;
    }, function (module) {
      AuditionAccuracyRating = module.AuditionAccuracyRating;
    }, function (module) {
      AuditionCharacterAnimationData = module.AuditionCharacterAnimationData;
      SpecialStateType = module.SpecialStateType;
    }, function (module) {
      resourceUtil = module.resourceUtil;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;
      cclegacy._RF.push({}, "1e7b6TmLYNOJqHH2ZZSRUXY", "AuditionCharacterAnimation", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Input history record used for tracking sequences
       */

      /**
       * Character Animation System for Audition module
       * Manages character animations based on player performance
       */
      var AuditionCharacterAnimation = exports('AuditionCharacterAnimation', (_dec = ccclass('AuditionCharacterAnimation'), _dec2 = property(Node), _dec3 = property(Animation), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionCharacterAnimation, _Component);
        function AuditionCharacterAnimation() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Character model/sprite
          _initializerDefineProperty(_this, "character", _descriptor, _assertThisInitialized(_this));
          // Animation component
          _initializerDefineProperty(_this, "animationController", _descriptor2, _assertThisInitialized(_this));
          // Animation configuration
          _initializerDefineProperty(_this, "transitionDuration", _descriptor3, _assertThisInitialized(_this));
          // Duration for animation transitions
          _initializerDefineProperty(_this, "comboThreshold", _descriptor4, _assertThisInitialized(_this));
          // Combo count to trigger combo animation
          _initializerDefineProperty(_this, "inputHistorySize", _descriptor5, _assertThisInitialized(_this));
          // Number of recent inputs to track
          // Current state
          _this.currentCombo = 0;
          _this.inputHistory = [];
          _this.isMale = true;
          // Default to male, should be set based on character selection
          _this.animMap = new Map();
          _this.animNames = [];
          _this.allDanceStates = [];
          _this.currentDanceIndex = 0;
          _this.musicSpeed = 1.0;
          return _this;
        }
        var _proto = AuditionCharacterAnimation.prototype;
        // Speed multiplier based on music BPM
        _proto.loadDanceData = function loadDanceData(songId) {
          var _this2 = this;
          if (!this.animationController && this.character) {
            this.animationController = this.character.getComponent(Animation);
          }
          return new Promise(function (resolve, reject) {
            // Initialize animation controller if not set
            // Initialize dance move data
            AuditionCharacterAnimationData.initialize();
            var songDance = songId + '_Dance';
            AuditionCharacterAnimationData.loadDanceData(songDance).then(function () {
              // Get all animation names from the loaded dance data
              _this2.animNames = AuditionCharacterAnimationData.getAllAnimationNames();
              // Log all animation names that will be loaded
              console.log("Animation names to be loaded:");
              _this2.animNames.forEach(function (animName, index) {
                console.log(index + 1 + ". " + animName);
              });
              console.log("Loading " + _this2.animNames.length + " dance animations for song: " + songId);
              // Load all animations for this dance
              return _this2.loadDanceAnims(_this2.animNames);
            }).then(function (clips) {
              console.log("Successfully loaded " + clips.length + " dance animations");
              _this2.setClips(clips, _this2.animNames);
              _this2.allDanceStates = AuditionCharacterAnimationData.getAllDanceStates();
              _this2.currentDanceIndex = -1;
              _this2.playSpecialAnimation(SpecialStateType.FIRST_STAND);
              resolve("success");
            })["catch"](function (error) {
              console.error("Failed to load dance: " + error);
              reject(error);
            });
          });
        };
        _proto.setClips = function setClips(clips, animNames) {
          for (var i = 0; i < clips.length; i++) {
            var clip = clips[i];
            var animName = animNames[i];
            this.animationController.createState(clip, animName);
          }
        };
        _proto.testLoadDanceAnim = function testLoadDanceAnim() {
          this.loadDanceAnim('Breakdance');
        }

        /**
         * Loads multiple dance animations by their names
         * @param animNames Array of animation names to load
         * @returns Promise that resolves with an array of loaded animation clips
         */;
        _proto.loadDanceAnims = /*#__PURE__*/
        function () {
          var _loadDanceAnims = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(animNames) {
            var clipPromises, _iterator, _step, animName, clips;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  clipPromises = []; // Create a promise for each animation name
                  for (_iterator = _createForOfIteratorHelperLoose(animNames); !(_step = _iterator()).done;) {
                    animName = _step.value;
                    clipPromises.push(this.loadDanceAnim(animName));
                  }
                  _context.prev = 2;
                  _context.next = 5;
                  return Promise.all(clipPromises);
                case 5:
                  clips = _context.sent;
                  return _context.abrupt("return", clips);
                case 9:
                  _context.prev = 9;
                  _context.t0 = _context["catch"](2);
                  console.error('Failed to load multiple dance animations:', _context.t0);
                  throw _context.t0;
                case 13:
                case "end":
                  return _context.stop();
              }
            }, _callee, this, [[2, 9]]);
          }));
          function loadDanceAnims(_x) {
            return _loadDanceAnims.apply(this, arguments);
          }
          return loadDanceAnims;
        }() // Load prefab with SkeletalAnimation component and play animation
        ;

        _proto.loadDanceAnim = /*#__PURE__*/
        function () {
          var _loadDanceAnim = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(animName) {
            var _this3 = this;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  return _context2.abrupt("return", new Promise(function (resolve, reject) {
                    // Load the prefab that contains SkeletalAnimation component
                    resourceUtil.loadRes("audition/anims/" + animName, Prefab, function (err, prefabAsset) {
                      if (err) {
                        console.error('Failed to load character as  nimation prefab:', err);
                        reject(err);
                        return;
                      }
                      try {
                        // Instantiate the prefab to access its components
                        var prefabNode = instantiate(prefabAsset);

                        // Get the SkeletalAnimation component from the prefab
                        var skeletalAnimation = prefabNode.getComponent(SkeletalAnimation);
                        if (!skeletalAnimation) {
                          console.error("No SkeletalAnimation component found in prefab: " + animName);
                          prefabNode.destroy();
                          reject(new Error('Missing SkeletalAnimation component'));
                          return;
                        }

                        // Get animation clips from the skeletal animation
                        var clip = skeletalAnimation.clips[0];
                        if (!clip) {
                          console.error("No animation clips found in prefab: " + animName);
                          prefabNode.destroy();
                          reject(new Error('No animation clips found'));
                          return;
                        }
                        prefabNode.destroy();
                        console.log("Successfully loaded and setup animation prefab: " + animName);
                        clip.name = animName; //set anim name
                        _this3.animMap.set(animName, clip);
                        resolve(clip); //return to clips index 0
                      } catch (error) {
                        console.error('Error processing animation prefab:', error);
                        reject(error);
                      }
                    });
                  }));
                case 1:
                case "end":
                  return _context2.stop();
              }
            }, _callee2);
          }));
          function loadDanceAnim(_x2) {
            return _loadDanceAnim.apply(this, arguments);
          }
          return loadDanceAnim;
        }()
        /**
         * Set character gender
         * @param isMale Whether the character is male
         */;

        _proto.setGender = function setGender(isMale) {
          this.isMale = isMale;
        }

        /**
         * React to player input with appropriate animation
         * @param accuracyRating Accuracy rating of the hit
         * @param combo Current combo
         */;
        _proto.reactToInput = function reactToInput(accuracyRating, combo) {
          console.log("reactToInput: " + accuracyRating + " " + combo);
          // Update combo count
          this.currentCombo = combo;

          // Record input for sequence detection
          this.recordInput(accuracyRating);

          // Handle miss animation if accuracy is poor
          if (accuracyRating === AuditionAccuracyRating.MISS) {
            this.playMissAnimation();
            this.nextDanceState();
            return;
          }

          // Continue with regular dance sequence
          this.playNextDanceState();
        };
        _proto.nextDanceState = function nextDanceState() {
          this.currentDanceIndex = ++this.currentDanceIndex % this.allDanceStates.length;
        }

        /**
         * Play the next dance state in sequence
         */;
        _proto.playNextDanceState = function playNextDanceState() {
          this.nextDanceState();
          var currentStateName = this.allDanceStates[this.currentDanceIndex].transitions[0].srcState;
          this.playAnimation(currentStateName, this.allDanceStates[this.currentDanceIndex], 1.0);
        }

        /**
         * Play a special animation
         * @param type Special animation type
         * @param callback Optional callback when animation completes
         */;
        _proto.playSpecialAnimation = function playSpecialAnimation(type, callback) {
          var state = AuditionCharacterAnimationData.getSpecialState(type);
          if (!state) {
            console.error("Special animation state not found: " + type);
            return;
          }
          this.playAnimation(state.motion, state, state.speed, callback);
        }

        /**
         * Play a miss animation
         */;
        _proto.playMissAnimation = function playMissAnimation() {
          var state = AuditionCharacterAnimationData.getSpecialState(SpecialStateType.MISS);
          // TODO: Implement miss animation logic
          // This should play a brief "miss" animation and then return to the current dance state
          this.playAnimation(state.motion, state, state.speed);
        }

        /**
         * Set the music speed multiplier based on BPM
         * @param bpm The current music BPM
         */;
        _proto.setMusicSpeed = function setMusicSpeed(bpm) {
          // Assuming standard BPM is 120, adjust speed accordingly
          this.musicSpeed = bpm / 100.0;
        }

        /**
         * Play an animation with optional speed and callback
         */;
        _proto.playAnimation = function playAnimation(animationName, danceState, speed, callback) {
          if (speed === void 0) {
            speed = 1.0;
          }
          if (!this.animationController) return;
          var state = this.animationController.getState(animationName);
          if (!state) {
            console.error("Animation state not found: " + animationName);
            return;
          }

          // Apply both the dance state speed and music speed
          state.speed = speed * this.musicSpeed;
          // Get the dance state to determine exit time for blending
          if (danceState && danceState.transitions && danceState.transitions.length > 0) {
            // Use the exit time from the first transition as blend time
            var exitTime = danceState.transitions[0].exitTime || 0.95;
            this.animationController.crossFade(animationName, exitTime);
            // state.play();
          } else {
            // Default play without blend time if no transition data
            this.animationController.crossFade(animationName, 0.3);
          }
          if (callback) {
            state.on('finished', callback, this);
          }
        }

        /**
         * Record an input for sequence detection
         */;
        _proto.recordInput = function recordInput(accuracyRating) {
          // Add to history
          this.inputHistory.push({
            accuracyRating: accuracyRating,
            timestamp: Date.now()
          });

          // Limit history size
          if (this.inputHistory.length > this.inputHistorySize) {
            this.inputHistory.shift();
          }
        }

        /**
         * End the dance sequence with appropriate ending animation
         * @param isWinner Whether the player won
         */;
        _proto.endDanceSequence = function endDanceSequence(isWinner) {
          var _this4 = this;
          // Determine which ending animation to play based on gender and result
          var endType;
          if (this.isMale) {
            endType = isWinner ? SpecialStateType.END2 : SpecialStateType.END1;
          } else {
            endType = isWinner ? SpecialStateType.END4 : SpecialStateType.END3;
          }
          this.playSpecialAnimation(endType, function () {
            // After ending animation, transition to last stand
            _this4.playSpecialAnimation(SpecialStateType.LAST_STAND);
          });
        }

        /**
         * Reset to idle animation
         */;
        _proto.resetToIdle = function resetToIdle() {
          this.currentCombo = 0;
          this.inputHistory = [];
          this.playSpecialAnimation(SpecialStateType.FIRST_STAND);
        };
        return AuditionCharacterAnimation;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "character", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "animationController", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "transitionDuration", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.2;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "comboThreshold", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 10;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "inputHistorySize", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 20;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionCharacterAnimationData.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './resourceUtil.ts'], function (exports) {
  var _createForOfIteratorHelperLoose, cclegacy, _decorator, TextAsset, resourceUtil;
  return {
    setters: [function (module) {
      _createForOfIteratorHelperLoose = module.createForOfIteratorHelperLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      TextAsset = module.TextAsset;
    }, function (module) {
      resourceUtil = module.resourceUtil;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "5d9e2TkgsBGdK4Et+YVimdr", "AuditionCharacterAnimationData", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Animation state types
       */
      var AnimationStateType = exports('AnimationStateType', /*#__PURE__*/function (AnimationStateType) {
        AnimationStateType[AnimationStateType["SPECIAL"] = 0] = "SPECIAL";
        AnimationStateType[AnimationStateType["DANCE"] = 1] = "DANCE";
        return AnimationStateType;
      }({}));

      /**
       * Special state types
       */
      var SpecialStateType = exports('SpecialStateType', /*#__PURE__*/function (SpecialStateType) {
        SpecialStateType["FIRST_STAND"] = "first_stand";
        SpecialStateType["LAST_STAND"] = "last_stand";
        SpecialStateType["BOY_START"] = "boy_start";
        SpecialStateType["GIRL_START"] = "girl_start";
        SpecialStateType["DANCE_START"] = "dance_start";
        SpecialStateType["DANCE_END"] = "dance_end";
        SpecialStateType["BOY_WIN"] = "boy_win";
        SpecialStateType["BOY_LOSE"] = "boy_lose";
        SpecialStateType["GIRL_WIN"] = "girl_win";
        SpecialStateType["GIRL_LOSE"] = "girl_lose";
        SpecialStateType["END1"] = "end1";
        SpecialStateType["END2"] = "end2";
        SpecialStateType["END3"] = "end3";
        SpecialStateType["END4"] = "end4";
        SpecialStateType["MISS"] = "miss";
        return SpecialStateType;
      }({}));

      /**
       * Interface for animation transition
       */

      /**
       * Interface for animation state
       */

      /**
       * Class for managing dance move data
       */
      var AuditionCharacterAnimationData = exports('AuditionCharacterAnimationData', (_dec = ccclass('AuditionCharacterAnimationData'), _dec(_class = (_class2 = /*#__PURE__*/function () {
        function AuditionCharacterAnimationData() {}
        /**
         * Initialize dance move data
         */
        AuditionCharacterAnimationData.initialize = function initialize() {
          // Clear existing data
          this.specialStates.clear();
          this.danceStates.clear();
          this.currentSequence = [];

          // Initialize special states with default values
          this.initializeSpecialStates();
        }

        /**
         * Initialize special states with default values
         */;
        AuditionCharacterAnimationData.initializeSpecialStates = function initializeSpecialStates() {
          // First stand
          this.specialStates.set(SpecialStateType.FIRST_STAND, {
            speed: 1.0,
            motion: 'first_stand',
            transitions: [{
              srcState: 'first_stand',
              destState: 'boy_start',
              transitionDuration: 0.2,
              transitionOffset: 0,
              exitTime: 0.9
            }],
            isLooping: false
          });

          // Last stand
          this.specialStates.set(SpecialStateType.LAST_STAND, {
            speed: 1.0,
            motion: 'last_stand',
            transitions: [],
            isLooping: true
          });

          // Gender-specific start animations
          this.specialStates.set(SpecialStateType.BOY_START, {
            speed: 1.0,
            motion: 'boy_start',
            transitions: [{
              srcState: 'boy_start',
              destState: 'dance_start',
              transitionDuration: 0.2,
              transitionOffset: 0,
              exitTime: 0.9
            }],
            isLooping: false
          });
          this.specialStates.set(SpecialStateType.GIRL_START, {
            speed: 1.0,
            motion: 'girl_start',
            transitions: [{
              srcState: 'girl_start',
              destState: 'dance_start',
              transitionDuration: 0.2,
              transitionOffset: 0,
              exitTime: 0.9
            }],
            isLooping: false
          });

          // Dance start/end
          this.specialStates.set(SpecialStateType.DANCE_START, {
            speed: 1.0,
            motion: 'dance_start',
            transitions: [{
              srcState: 'dance_start',
              destState: 'default_dance',
              transitionDuration: 0.2,
              transitionOffset: 0,
              exitTime: 0.9
            }],
            isLooping: false
          });
          this.specialStates.set(SpecialStateType.DANCE_END, {
            speed: 1.0,
            motion: 'dance_end',
            transitions: [],
            isLooping: false
          });
          // Win/lose animations for both genders
          this.specialStates.set(SpecialStateType.BOY_WIN, {
            speed: 1.0,
            motion: 'boy_win',
            transitions: [{
              srcState: 'boy_win',
              destState: 'last_stand',
              transitionDuration: 0.2,
              transitionOffset: 0,
              exitTime: 0.9
            }],
            isLooping: false
          });
          this.specialStates.set(SpecialStateType.BOY_LOSE, {
            speed: 1.0,
            motion: 'boy_lose',
            transitions: [{
              srcState: 'boy_lose',
              destState: 'last_stand',
              transitionDuration: 0.2,
              transitionOffset: 0,
              exitTime: 0.9
            }],
            isLooping: false
          });
          this.specialStates.set(SpecialStateType.GIRL_WIN, {
            speed: 1.0,
            motion: 'girl_win',
            transitions: [{
              srcState: 'girl_win',
              destState: 'last_stand',
              transitionDuration: 0.2,
              transitionOffset: 0,
              exitTime: 0.9
            }],
            isLooping: false
          });
          this.specialStates.set(SpecialStateType.GIRL_LOSE, {
            speed: 1.0,
            motion: 'girl_lose',
            transitions: [{
              srcState: 'girl_lose',
              destState: 'last_stand',
              transitionDuration: 0.2,
              transitionOffset: 0,
              exitTime: 0.9
            }],
            isLooping: false
          });

          // End animations
          // this.specialStates.set(SpecialStateType.END1, {
          //     speed: 1.0,
          //     motion: 'boy_lose',
          //     transitions: [{
          //         srcState: 'boy_lose',
          //         destState: 'last_stand',
          //         transitionDuration: 0.2,
          //         transitionOffset: 0,
          //         exitTime: 0.9
          //     }],
          //     isLooping: false
          // });

          // this.specialStates.set(SpecialStateType.END2, {
          //     speed: 1.0,
          //     motion: 'boy_win',
          //     transitions: [{
          //         srcState: 'boy_win',
          //         destState: 'last_stand',
          //         transitionDuration: 0.2,
          //         transitionOffset: 0,
          //         exitTime: 0.9
          //     }],
          //     isLooping: false
          // });

          // this.specialStates.set(SpecialStateType.END3, {
          //     speed: 1.0,
          //     motion: 'girl_lose',
          //     transitions: [{
          //         srcState: 'girl_lose',
          //         destState: 'last_stand',
          //         transitionDuration: 0.2,
          //         transitionOffset: 0,
          //         exitTime: 0.9
          //     }],
          //     isLooping: false
          // });

          // this.specialStates.set(SpecialStateType.END4, {
          //     speed: 1.0,
          //     motion: 'girl_win',
          //     transitions: [{
          //         srcState: 'girl_win',
          //         destState: 'last_stand',
          //         transitionDuration: 0.2,
          //         transitionOffset: 0,
          //         exitTime: 0.9
          //     }],
          //     isLooping: false
          // });

          // Miss animation
          this.specialStates.set(SpecialStateType.MISS, {
            speed: 1.0,
            motion: 'miss',
            transitions: [],
            isLooping: false
          });
        }

        /**
         * Load dance data from resources
         */;
        AuditionCharacterAnimationData.loadDanceData = function loadDanceData(dataName) {
          var _this = this;
          return new Promise(function (resolve, reject) {
            resourceUtil.loadRes('audition/dances/' + dataName, TextAsset, function (err, content) {
              if (err) {
                console.error('Failed to load dance data:', err);
                reject(err);
                return;
              }
              _this.parseDanceData(content.text);
              resolve();
            });
          });
        }

        /**
         * Parse dance data from text content
         */;
        AuditionCharacterAnimationData.parseDanceData = function parseDanceData(content) {
          var _this2 = this;
          var lines = content.split('\n');
          var currentState = '';
          var currentTransitions = [];
          this.beginDanceState = '';
          for (var i = 0; i < lines.length; i++) {
            var line = lines[i].trim();

            // Skip empty lines
            if (!line) continue;

            // Check for default state
            if (line.startsWith('DefaultState:')) {
              this.defaultState = line.split(':')[1].trim();
              continue;
            }

            // Check for state definition
            if (line.startsWith('[') && line.endsWith(']')) {
              // Save previous state if exists
              var isSpecialState = Array.from(this.specialStates.keys()).some(function (key) {
                return _this2.specialStates.get(key).motion === currentState;
              });
              if (currentState && !isSpecialState) {
                this.saveState(currentState, currentTransitions);
                currentTransitions = [];
              }
              currentState = line.slice(1, -1).trim();
              continue;
            }

            // Parse state properties
            if (currentState) {
              // Check if current state is a special state
              var _isSpecialState = Array.from(this.specialStates.keys()).some(function (key) {
                return _this2.specialStates.get(key).motion === currentState;
              });
              if (line.startsWith('Speed:')) {
                var speed = parseFloat(line.split(':')[1].trim());
                if (_isSpecialState) {
                  this.updateSpecialStateSpeed(currentState, speed);
                } else {
                  this.updateStateSpeed(currentState, speed);
                }
              } else if (line.startsWith('Motion:')) {
                var motion = line.split(':')[1].trim();
                if (_isSpecialState) {
                  this.updateSpecialStateMotion(currentState, motion);
                } else {
                  this.updateStateMotion(currentState, motion);
                  // If this is the first dance motion and not a special state, set it as the begin dance state
                  if (!this.beginDanceState && !this.specialStates.has(motion)) {
                    this.beginDanceState = currentState;
                  }
                }
              } else if (line.startsWith('Transition:')) {
                var transition = this.parseTransition(lines, i);
                if (transition) {
                  if (_isSpecialState) {
                    this.updateSpecialStateTransitions(currentState, transition);
                  } else {
                    currentTransitions.push(transition);
                  }
                }
              } else if (line.startsWith('IsLooping:')) {
                var isLooping = line.split(':')[1].trim().toLowerCase() === 'true';
                if (_isSpecialState) {
                  this.updateSpecialStateLooping(currentState, isLooping);
                } else {
                  this.updateStateLooping(currentState, isLooping);
                }
              } else if (line.startsWith('NextState:')) {
                var nextState = line.split(':')[1].trim();
                if (!_isSpecialState) {
                  this.updateStateNext(currentState, nextState);
                }
              }
            }
          }

          // // Save last state
          // if (currentState) {
          //     this.saveState(currentState, currentTransitions);
          // }

          // Build dance sequence
          this.buildDanceSequence();
          console.log("Loaded " + this.danceStates.size + " dance states");
        }

        /**
         * Build the dance sequence from loaded states
         */;
        AuditionCharacterAnimationData.buildDanceSequence = function buildDanceSequence() {
          this.currentSequence = [];
          var currentState = this.defaultState;
          while (currentState) {
            this.currentSequence.push(currentState);
            var state = this.danceStates.get(currentState);
            if (!state || !state.nextState) break;
            currentState = state.nextState;
          }
        }

        /**
         * Get all dance states
         */;
        AuditionCharacterAnimationData.getAllDanceStates = function getAllDanceStates() {
          return Array.from(this.danceStates.values());
        }

        /**
         * Parse transition data
         */;
        AuditionCharacterAnimationData.parseTransition = function parseTransition(lines, startIndex) {
          var transition = {
            srcState: '',
            destState: '',
            transitionDuration: 0,
            transitionOffset: 0,
            exitTime: 0
          };
          var i = startIndex + 1;
          while (i < lines.length && lines[i].startsWith('\t')) {
            var line = lines[i].trim();
            if (line.startsWith('SrcState:')) {
              transition.srcState = line.split(':')[1].trim();
            } else if (line.startsWith('DestState:')) {
              transition.destState = line.split(':')[1].trim();
            } else if (line.startsWith('TransitionDuration:')) {
              transition.transitionDuration = parseFloat(line.split(':')[1].trim());
            } else if (line.startsWith('TransitionOffset:')) {
              transition.transitionOffset = parseFloat(line.split(':')[1].trim());
            } else if (line.startsWith('ExitTime:')) {
              transition.exitTime = parseFloat(line.split(':')[1].trim());
            } else if (line.startsWith('Condition:')) {
              // Parse condition string and create condition function
              var conditionStr = line.split(':')[1].trim();
              transition.condition = this.parseCondition(conditionStr);
            }
            i++;
          }
          return transition;
        }

        /**
         * Parse condition string into a function
         */;
        AuditionCharacterAnimationData.parseCondition = function parseCondition(conditionStr) {
          // Example conditions:
          // "combo >= 10" -> (combo) => combo >= 10
          // "accuracy === MISS" -> (_, accuracy) => accuracy === AuditionAccuracyRating.MISS
          // "combo >= 5 && accuracy !== MISS" -> (combo, accuracy) => combo >= 5 && accuracy !== AuditionAccuracyRating.MISS

          return new Function('combo', 'accuracy', "return " + conditionStr);
        }

        /**
         * Save state data
         */;
        AuditionCharacterAnimationData.saveState = function saveState(stateName, transitions) {
          var state = this.danceStates.get(stateName) || {
            speed: 1.0,
            motion: stateName,
            transitions: [],
            isLooping: false
          };
          state.transitions = transitions;
          this.danceStates.set(stateName, state);
        }

        /**
         * Update state speed
         */;
        AuditionCharacterAnimationData.updateStateSpeed = function updateStateSpeed(stateName, speed) {
          var state = this.danceStates.get(stateName) || {
            speed: 1.0,
            motion: stateName,
            transitions: [],
            isLooping: false
          };
          state.speed = speed;
          this.danceStates.set(stateName, state);
        }

        /**
         * Update state motion
         */;
        AuditionCharacterAnimationData.updateStateMotion = function updateStateMotion(stateName, motion) {
          var state = this.danceStates.get(stateName) || {
            speed: 1.0,
            motion: stateName,
            transitions: [],
            isLooping: false
          };
          state.motion = motion;
          this.danceStates.set(stateName, state);
        }

        /**
         * Update state looping
         */;
        AuditionCharacterAnimationData.updateStateLooping = function updateStateLooping(stateName, isLooping) {
          var state = this.danceStates.get(stateName) || {
            speed: 1.0,
            motion: stateName,
            transitions: [],
            isLooping: false
          };
          state.isLooping = isLooping;
          this.danceStates.set(stateName, state);
        }

        /**
         * Update state next
         */;
        AuditionCharacterAnimationData.updateStateNext = function updateStateNext(stateName, nextState) {
          var state = this.danceStates.get(stateName) || {
            speed: 1.0,
            motion: stateName,
            transitions: [],
            isLooping: false
          };
          state.nextState = nextState;
          this.danceStates.set(stateName, state);
        }

        /**
         * Get a dance state by name
         */;
        AuditionCharacterAnimationData.getDanceState = function getDanceState(stateName) {
          return this.danceStates.get(stateName) || null;
        }

        /**
         * Get the default state
         */;
        AuditionCharacterAnimationData.getDefaultState = function getDefaultState() {
          return this.defaultState;
        };
        AuditionCharacterAnimationData.getBeginDanceState = function getBeginDanceState() {
          return this.beginDanceState;
        }

        /**
         * Get a special state
         */;
        AuditionCharacterAnimationData.getSpecialState = function getSpecialState(type) {
          return this.specialStates.get(type) || null;
        }

        /**
         * Get the current dance sequence
         */;
        AuditionCharacterAnimationData.getDanceSequence = function getDanceSequence() {
          return [].concat(this.currentSequence);
        }

        /**
         * Get all animation names from the loaded dance data
         */;
        AuditionCharacterAnimationData.getAllAnimationNames = function getAllAnimationNames() {
          // Get all animation names from dance states
          var danceStateNames = Array.from(this.danceStates.keys());

          // Get all animation names from special states (extract motion property)
          var specialStateNames = Array.from(this.specialStates.values()).map(function (state) {
            return state.motion;
          });

          // Combine both arrays and remove duplicates
          return danceStateNames.concat(specialStateNames);
        }

        /**
         * Update special state speed
         */;
        AuditionCharacterAnimationData.updateSpecialStateSpeed = function updateSpecialStateSpeed(stateName, speed) {
          for (var _iterator = _createForOfIteratorHelperLoose(this.specialStates.entries()), _step; !(_step = _iterator()).done;) {
            var _step$value = _step.value,
              key = _step$value[0],
              state = _step$value[1];
            if (state.motion === stateName) {
              state.speed = speed;
              this.specialStates.set(key, state);
              break;
            }
          }
        }

        /**
         * Update special state motion
         */;
        AuditionCharacterAnimationData.updateSpecialStateMotion = function updateSpecialStateMotion(stateName, motion) {
          for (var _iterator2 = _createForOfIteratorHelperLoose(this.specialStates.entries()), _step2; !(_step2 = _iterator2()).done;) {
            var _step2$value = _step2.value,
              key = _step2$value[0],
              state = _step2$value[1];
            if (state.motion === stateName) {
              state.motion = motion;
              this.specialStates.set(key, state);
              break;
            }
          }
        }

        /**
         * Update special state transitions
         */;
        AuditionCharacterAnimationData.updateSpecialStateTransitions = function updateSpecialStateTransitions(stateName, transition) {
          for (var _iterator3 = _createForOfIteratorHelperLoose(this.specialStates.entries()), _step3; !(_step3 = _iterator3()).done;) {
            var _step3$value = _step3.value,
              key = _step3$value[0],
              state = _step3$value[1];
            if (state.motion === stateName) {
              state.transitions.push(transition);
              this.specialStates.set(key, state);
              break;
            }
          }
        }

        /**
         * Update special state looping
         */;
        AuditionCharacterAnimationData.updateSpecialStateLooping = function updateSpecialStateLooping(stateName, isLooping) {
          for (var _iterator4 = _createForOfIteratorHelperLoose(this.specialStates.entries()), _step4; !(_step4 = _iterator4()).done;) {
            var _step4$value = _step4.value,
              key = _step4$value[0],
              state = _step4$value[1];
            if (state.motion === stateName) {
              state.isLooping = isLooping;
              this.specialStates.set(key, state);
              break;
            }
          }
        };
        return AuditionCharacterAnimationData;
      }(), _class2.specialStates = new Map(), _class2.danceStates = new Map(), _class2.defaultState = '', _class2.beginDanceState = '', _class2.currentSequence = [], _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionGameplayController.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AuditionAudioManager.ts', './AuditionBeatSystem.ts', './AuditionScoringSystem.ts', './AuditionCharacterAnimation.ts', './AuditionUIManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Button, Node, ProgressBar, director, Component, AuditionAudioManager, AuditionBeatSystem, AuditionAccuracyRating, AuditionScoringSystem, AuditionCharacterAnimation, AuditionUIManager, FeedbackType;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Button = module.Button;
      Node = module.Node;
      ProgressBar = module.ProgressBar;
      director = module.director;
      Component = module.Component;
    }, function (module) {
      AuditionAudioManager = module.AuditionAudioManager;
    }, function (module) {
      AuditionBeatSystem = module.AuditionBeatSystem;
      AuditionAccuracyRating = module.AuditionAccuracyRating;
    }, function (module) {
      AuditionScoringSystem = module.AuditionScoringSystem;
    }, function (module) {
      AuditionCharacterAnimation = module.AuditionCharacterAnimation;
    }, function (module) {
      AuditionUIManager = module.AuditionUIManager;
      FeedbackType = module.FeedbackType;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _class3;
      cclegacy._RF.push({}, "88430rgcWxFCqXyHcVl7nDY", "AuditionGameplayController", undefined);
      // Game state enum
      var GameState = /*#__PURE__*/function (GameState) {
        GameState[GameState["INIT"] = 0] = "INIT";
        GameState[GameState["PLAYING"] = 1] = "PLAYING";
        GameState[GameState["PAUSED"] = 2] = "PAUSED";
        GameState[GameState["GAME_OVER"] = 3] = "GAME_OVER";
        return GameState;
      }(GameState || {});
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Controller for the Gameplay scene
       * Integrates beat system, scoring, character animations, and UI
       */
      var AuditionGameplayController = exports('AuditionGameplayController', (_dec = ccclass('AuditionGameplayController'), _dec2 = property(AuditionBeatSystem), _dec3 = property(AuditionScoringSystem), _dec4 = property(AuditionCharacterAnimation), _dec5 = property(Button), _dec6 = property(Node), _dec7 = property(Button), _dec8 = property(Button), _dec9 = property(Button), _dec10 = property(ProgressBar), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionGameplayController, _Component);
        function AuditionGameplayController() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Core gameplay components
          _initializerDefineProperty(_this, "beatSystem", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "scoringSystem", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "characterAnimation", _descriptor3, _assertThisInitialized(_this));
          // UI elements
          _initializerDefineProperty(_this, "pauseButton", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "pauseMenu", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "resumeButton", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "restartButton", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "quitButton", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songProgressBar", _descriptor9, _assertThisInitialized(_this));
          // State tracking
          _this.gameState = GameState.INIT;
          _this.songStartTime = 0;
          _this.songDuration = 0;
          _this.notesProcessed = 0;
          _this.currentSong = null;
          //test data should load from csv
          // Available songs in the game
          _this.availableSongs = [
          // {
          //     id: 'song0211',
          //     title: ' (Crooked)',
          //     artist: 'G-Dragon',
          //     difficulty: 3,
          //     bpm: 130,
          //     audioPath: 'song0211',
          //     previewStart: 30000,
          //     previewEnd: 45000
          // },
          // {
          //     id: 'song0502',
          //     title: 'Growl',
          //     artist: 'EXO',
          //     difficulty: 2,
          //     bpm: 90,
          //     audioPath: 'song0502',
          //     previewStart: 25000,
          //     previewEnd: 40000
          // }, 
          {
            id: 'DauCoLoiLam_ATVNCG_Full',
            title: 'u C Li Lm',
            artist: 'ATVNCG',
            difficulty: 1,
            bpm: 128,
            audioPath: 'DauCoLoiLam_ATVNCG_Full',
            previewStart: 35000,
            previewEnd: 50000
          }, {
            id: 'TrongCom_ATVNCG',
            title: 'Trng Cm',
            artist: 'ATVNCG',
            difficulty: 2,
            bpm: 86,
            audioPath: 'TrongCom_ATVNCG',
            previewStart: 35000,
            previewEnd: 50000
          }];
          return _this;
        }
        var _proto = AuditionGameplayController.prototype;
        /**
         * Returns the list of available songs in the game
         * @returns Array of SongData objects
         */
        _proto.getAvailableSongs = function getAvailableSongs() {
          return this.availableSongs;
        }

        /**
         * Returns the list of unlocked songs in the game
         * @returns Array of SongData objects
         */;
        _proto.getUnlockedSongs = function getUnlockedSongs() {
          return this.availableSongs;
        }

        /**
         * Returns the high score for a given song
         * @param songId The ID of the song
         * @returns The high score for the song
         */;
        _proto.getHighScore = function getHighScore(songId) {
          return 0;
        }

        /**
         * Returns true if a song is unlocked
         * @param songId The ID of the song 
         * @returns True if the song is unlocked, false otherwise
         */;
        _proto.isSongUnlocked = function isSongUnlocked(songId) {
          return true;
        };
        _proto.onLoad = function onLoad() {
          // Set up singleton instance
          if (AuditionGameplayController._instance !== null) {
            this.node.destroy();
            return;
          }
          AuditionGameplayController._instance = this;
        };
        _proto.start = function start() {
          // Setup UI
          // Setup button events
          this.setupButtonEvents();

          // Reset scoring system
          if (this.scoringSystem) {
            this.scoringSystem.reset();

            // Connect scoring system to UI
            this.scoringSystem.onScoreUpdate(this.updateScoreDisplay.bind(this));
            this.scoringSystem.onComboUpdate(this.updateComboDisplay.bind(this));
            this.beatSystem.setScoreCallback(this.onScoringProcessed.bind(this));
          }

          // Reset character animation
          if (this.characterAnimation) {
            this.characterAnimation.resetToIdle();
          }

          // Select a random song from available songs
          if (this.availableSongs && this.availableSongs.length > 0) {
            var randomIndex = Math.floor(Math.random() * this.availableSongs.length);
            var randomSong = this.availableSongs[randomIndex];
            this.startSong(randomSong.id);
            console.log("Starting random song: " + randomSong.id);
          } else {
            console.error('No available songs found');
          }

          // UIManager.instance.showDialog(POPUP.MESSAGE, [{
          //     title: "Hello",
          //     message: "This is a test message",
          //     buttonText: "OK",
          //     buttonCallback: () => {
          //         this.startSong("song0211");
          //     }
          // }]);
        };

        _proto.startSong = function startSong(songId) {
          this.gameState = GameState.INIT;
          console.log("Starting song: " + songId);

          // Find the song data
          var songData = this.availableSongs.find(function (song) {
            return song.id === songId;
          });
          if (!songData) {
            console.error("Song with id " + songId + " not found");
            return;
          }
          this.currentSong = songData;
          // Initialize gameplay
          this.initGameplay();
          AuditionUIManager.instance.showGameplay(this.currentSong);
        }

        /**
         * Initialize gameplay with current song
         */;
        _proto.initGameplay = function initGameplay() {
          var _this2 = this;
          var audioManager = AuditionAudioManager.instance;
          if (!audioManager || !this.beatSystem) {
            console.error('Required components not found');
            return;
          }

          // Get current song
          if (!this.currentSong) {
            console.error('No song selected');
            return;
          }

          // Load both song audio and dance data concurrently
          Promise.all([audioManager.loadSong(this.currentSong.audioPath), this.characterAnimation.loadDanceData(this.currentSong.id)]).then(function (_ref) {
            var songLoaded = _ref[0],
              danceDataLoaded = _ref[1];
            console.log('Song and dance data loaded successfully');
            // Get song duration from audio manager

            _this2.songDuration = audioManager.getDuration();
            _this2.characterAnimation.setMusicSpeed(_this2.currentSong.bpm);
            _this2.startGameplay();
            return _this2.songDuration;
          })["catch"](function (error) {
            console.error('Failed to load song or dance data:', error);
            throw error; // Re-throw to be caught by the outer catch
          });
        }

        /**
         * Start gameplay
         */;
        _proto.startGameplay = function startGameplay() {
          // Record start time
          this.beatSystem.setReadyCallback(function () {
            AuditionUIManager.instance.playReadyGoAnimation();
          });
          this.songStartTime = Date.now();
          // Start audio
          AuditionAudioManager.instance.playSong();
          // Start beatmap
          this.beatSystem.startBeatSystem(this.currentSong.bpm, this.songDuration);
          // Set game state to playing
          this.gameState = GameState.PLAYING;
          console.log('Gameplay started');
        }

        /**
         * Setup button event listeners
         */;
        _proto.setupButtonEvents = function setupButtonEvents() {
          // Pause button
          if (this.pauseButton) {
            this.pauseButton.node.on(Button.EventType.CLICK, this.onPauseButtonClicked, this);
          }

          // Resume button
          if (this.resumeButton) {
            this.resumeButton.node.on(Button.EventType.CLICK, this.onResumeButtonClicked, this);
          }

          // Restart button
          if (this.restartButton) {
            this.restartButton.node.on(Button.EventType.CLICK, this.onRestartButtonClicked, this);
          }

          // Quit button
          if (this.quitButton) {
            this.quitButton.node.on(Button.EventType.CLICK, this.onQuitButtonClicked, this);
          }

          // Hide pause menu initially
          if (this.pauseMenu) {
            this.pauseMenu.active = false;
          }
        }

        /**
         * Update method called every frame
         * @param dt Delta time
         */;
        _proto.update = function update(dt) {
          if (this.gameState !== GameState.PLAYING) return;

          // Update progress bar
          this.updateProgressBar();

          // Check for song completion
          var audioManager = AuditionAudioManager.instance;
          // Use the getCurrentTime to check if the song has stopped
          if (audioManager && audioManager.getCurrentTime() >= this.songDuration && this.songStartTime > 0) {
            // Song has ended naturally
            this.endGameplay();
          }
        }

        /**
         * Update progress bar
         */;
        _proto.updateProgressBar = function updateProgressBar() {
          if (!this.songProgressBar || this.songDuration <= 0) return;
          var audioManager = AuditionAudioManager.instance;
          if (!audioManager) return;
          var currentTime = audioManager.getCurrentTime();
          var progress = Math.min(1.0, currentTime / this.songDuration) * 0.9;

          // Update UI progress bar
          this.songProgressBar.progress = progress + 0.1;

          // Also update UI manager progress
          AuditionUIManager.instance.updateProgress(progress);
        }

        /**
         * Handle note processing result
         * @param rating Accuracy rating
         * @param noteType Note type
         */;
        _proto.onScoringProcessed = function onScoringProcessed(rating, noteType) {
          // Update notes processed count
          this.notesProcessed++;

          // Update scoring
          this.scoringSystem.processNoteResult(rating, noteType);

          // Update character animation
          this.characterAnimation.reactToInput(rating, this.scoringSystem.getCombo());

          // Show UI feedback
          var feedbackType;
          switch (rating) {
            case AuditionAccuracyRating.PERFECT:
              feedbackType = FeedbackType.PERFECT;
              break;
            case AuditionAccuracyRating.GOOD:
              feedbackType = FeedbackType.GREAT;
              break;
            case AuditionAccuracyRating.MISS:
              feedbackType = FeedbackType.MISS;
              break;
            default:
              feedbackType = FeedbackType.MISS;
          }
          AuditionUIManager.instance.showFeedback(feedbackType);
        }

        /**
         * Update score display
         * @param score Current score
         */;
        _proto.updateScoreDisplay = function updateScoreDisplay(score) {
          AuditionUIManager.instance.updateScore(score);
        }

        /**
         * Update combo display
         * @param combo Current combo
         */;
        _proto.updateComboDisplay = function updateComboDisplay(combo) {
          AuditionUIManager.instance.updateCombo(combo);
        }

        /**
         * End gameplay and show results
         */;
        _proto.endGameplay = function endGameplay() {
          // Set game state to game over
          this.gameState = GameState.GAME_OVER;

          // Stop audio and beatmap
          var audioManager = AuditionAudioManager.instance;
          if (audioManager) {
            audioManager.stopSong();
          }
          this.beatSystem.stopBeatSystem();

          // Get final score and stats
          var score = this.scoringSystem.getScore();
          var maxCombo = this.scoringSystem.getMaxCombo();
          var accuracy = this.scoringSystem.getAccuracyPercentage();
          var grade = this.scoringSystem.getGrade();

          // Calculate experience
          var experiencePoints = this.scoringSystem.calculateExperiencePoints();

          // Show results screen
          AuditionUIManager.instance.showResults();
          AuditionUIManager.instance.updateResults(score, accuracy, maxCombo, grade);
          console.log("Gameplay ended. Score: " + score + ", Accuracy: " + accuracy.toFixed(2) + "%, Max Combo: " + maxCombo + ", Grade: " + grade);
        }

        /**
         * Handle pause button click
         */;
        _proto.onPauseButtonClicked = function onPauseButtonClicked() {
          this.pauseGame();
        }

        /**
         * Handle resume button click
         */;
        _proto.onResumeButtonClicked = function onResumeButtonClicked() {
          this.resumeGame();
        }

        /**
         * Handle restart button click
         */;
        _proto.onRestartButtonClicked = function onRestartButtonClicked() {
          // Hide pause menu
          if (this.pauseMenu) {
            this.pauseMenu.active = false;
          }

          // Stop current gameplay
          var audioManager = AuditionAudioManager.instance;
          if (audioManager) {
            audioManager.stopSong();
          }
          this.beatSystem.stopBeatSystem();

          // Reset game state
          this.gameState = GameState.INIT;

          // Reload the scene to restart
          director.loadScene(director.getScene().name);
        }

        /**
         * Handle quit button click
         */;
        _proto.onQuitButtonClicked = function onQuitButtonClicked() {
          // Stop gameplay
          var audioManager = AuditionAudioManager.instance;
          if (audioManager) {
            audioManager.stopSong();
          }
          this.beatSystem.stopBeatSystem();

          // Reset game state
          this.gameState = GameState.INIT;
        }

        /**
         * Pause the game
         */;
        _proto.pauseGame = function pauseGame() {
          if (this.gameState !== GameState.PLAYING) return;
          this.gameState = GameState.PAUSED;

          // Pause audio
          var audioManager = AuditionAudioManager.instance;
          if (audioManager) {
            audioManager.pauseSong();
          }

          // Show pause menu
          if (this.pauseMenu) {
            this.pauseMenu.active = true;
          }
        }

        /**
         * Resume the game
         */;
        _proto.resumeGame = function resumeGame() {
          if (this.gameState !== GameState.PAUSED) return;
          this.gameState = GameState.PLAYING;

          // Resume audio
          var audioManager = AuditionAudioManager.instance;
          if (audioManager) {
            audioManager.resumeSong();
          }

          // Hide pause menu
          if (this.pauseMenu) {
            this.pauseMenu.active = false;
          }
        };
        _proto.onDestroy = function onDestroy() {
          // Clean up
          var audioManager = AuditionAudioManager.instance;
          if (audioManager) {
            audioManager.stopSong();
          }
          if (this.beatSystem) {
            this.beatSystem.stopBeatSystem();
          }
        };
        _createClass(AuditionGameplayController, null, [{
          key: "instance",
          get:
          /**
           * Get the singleton instance
           */
          function get() {
            return this._instance;
          }
        }]);
        return AuditionGameplayController;
      }(Component), _class3._instance = null, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "beatSystem", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "scoringSystem", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "characterAnimation", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "pauseButton", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "pauseMenu", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "resumeButton", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "restartButton", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "quitButton", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "songProgressBar", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionGameplayUI.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AuditionInputHandler.ts', './AuditionBeatSystem.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Label, Node, Color, UIOpacity, tween, Vec3, Sprite, Animation, Component, AuditionInputType, AuditionAccuracyRating;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Label = module.Label;
      Node = module.Node;
      Color = module.Color;
      UIOpacity = module.UIOpacity;
      tween = module.tween;
      Vec3 = module.Vec3;
      Sprite = module.Sprite;
      Animation = module.Animation;
      Component = module.Component;
    }, function (module) {
      AuditionInputType = module.AuditionInputType;
    }, function (module) {
      AuditionAccuracyRating = module.AuditionAccuracyRating;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _descriptor20;
      cclegacy._RF.push({}, "13564WRJ8BHHoVT5R2hp2xb", "AuditionGameplayUI", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Gameplay UI for Audition module
       * Manages the visual representation of gameplay elements
       */
      var AuditionGameplayUI = exports('AuditionGameplayUI', (_dec = ccclass('AuditionGameplayUI'), _dec2 = property(Label), _dec3 = property(Label), _dec4 = property(Label), _dec5 = property(Node), _dec6 = property(Label), _dec7 = property(Node), _dec8 = property([Node]), _dec9 = property(Node), _dec10 = property(Node), _dec11 = property(Node), _dec12 = property(Label), _dec13 = property(Node), _dec14 = property(Node), _dec15 = property(Node), _dec16 = property(Color), _dec17 = property(Color), _dec18 = property(Color), _dec19 = property(Color), _dec20 = property(Color), _dec21 = property(Color), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionGameplayUI, _Component);
        function AuditionGameplayUI() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Score and combo display
          _initializerDefineProperty(_this, "scoreLabel", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "comboLabel", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "multiplierLabel", _descriptor3, _assertThisInitialized(_this));
          // Accuracy feedback
          _initializerDefineProperty(_this, "accuracyFeedbackNode", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "accuracyLabel", _descriptor5, _assertThisInitialized(_this));
          // Pattern display
          _initializerDefineProperty(_this, "patternDisplay", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "patternDots", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "patternProgressBar", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "syncPointIndicator", _descriptor9, _assertThisInitialized(_this));
          // Finish move elements
          _initializerDefineProperty(_this, "finishMoveIndicator", _descriptor10, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "finishMoveLabel", _descriptor11, _assertThisInitialized(_this));
          // Virtual buttons
          _initializerDefineProperty(_this, "leftButton", _descriptor12, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "rightButton", _descriptor13, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "spaceButton", _descriptor14, _assertThisInitialized(_this));
          // Colors for different elements
          _initializerDefineProperty(_this, "leftButtonColor", _descriptor15, _assertThisInitialized(_this));
          // Light blue
          _initializerDefineProperty(_this, "rightButtonColor", _descriptor16, _assertThisInitialized(_this));
          // Coral red
          _initializerDefineProperty(_this, "spaceButtonColor", _descriptor17, _assertThisInitialized(_this));
          // Yellow
          _initializerDefineProperty(_this, "perfectColor", _descriptor18, _assertThisInitialized(_this));
          // Bright green
          _initializerDefineProperty(_this, "goodColor", _descriptor19, _assertThisInitialized(_this));
          // Amber
          _initializerDefineProperty(_this, "missColor", _descriptor20, _assertThisInitialized(_this));
          // Red
          // Active pattern tracking
          _this.currentSequence = [];
          _this.currentProgress = 0;
          // Animation references
          _this.activeFeedbackAnimation = null;
          return _this;
        }
        var _proto = AuditionGameplayUI.prototype;
        _proto.onLoad = function onLoad() {
          // Initialize UI elements
          this.resetUI();
        }

        /**
         * Reset all UI elements to their default state
         */;
        _proto.resetUI = function resetUI() {
          // Reset score and combo display
          this.updateScore(0);
          this.updateCombo(0);
          this.updateMultiplier(1.0);

          // Hide accuracy feedback
          if (this.accuracyFeedbackNode) {
            this.accuracyFeedbackNode.active = false;
          }

          // Reset pattern display
          this.clearPatternDisplay();

          // Hide finish move indicator
          if (this.finishMoveIndicator) {
            this.finishMoveIndicator.active = false;
          }

          // Reset buttons to normal state
          this.resetButtons();
        }

        /**
         * Update the score display
         * @param score Current score
         */;
        _proto.updateScore = function updateScore(score) {
          if (this.scoreLabel) {
            this.scoreLabel.string = score.toString();
          }
        }

        /**
         * Update the combo display
         * @param combo Current combo
         */;
        _proto.updateCombo = function updateCombo(combo) {
          if (this.comboLabel) {
            if (combo > 0) {
              this.comboLabel.node.active = true;
              this.comboLabel.string = "Combo: " + combo;

              // Animate combo update
              this.pulseNode(this.comboLabel.node);
            } else {
              this.comboLabel.node.active = false;
            }
          }
        }

        /**
         * Update pattern multiplier display
         * @param multiplier Current pattern multiplier
         */;
        _proto.updateMultiplier = function updateMultiplier(multiplier) {
          if (this.multiplierLabel) {
            this.multiplierLabel.string = "x" + multiplier.toFixed(1);

            // Change color based on multiplier value
            if (multiplier > 2.0) {
              this.multiplierLabel.color = this.perfectColor;
            } else if (multiplier > 1.5) {
              this.multiplierLabel.color = this.goodColor;
            } else {
              this.multiplierLabel.color = Color.WHITE;
            }
          }
        }

        /**
         * Show accuracy feedback
         * @param rating Accuracy rating
         */;
        _proto.showAccuracyFeedback = function showAccuracyFeedback(rating) {
          var _this2 = this;
          if (!this.accuracyFeedbackNode || !this.accuracyLabel) return;

          // Stop any active animation
          if (this.activeFeedbackAnimation) {
            this.activeFeedbackAnimation.stop();
          }

          // Set text and color based on rating
          var text;
          var color;
          switch (rating) {
            case AuditionAccuracyRating.PERFECT:
              text = "PERFECT";
              color = this.perfectColor;
              break;
            case AuditionAccuracyRating.GOOD:
              text = "GOOD";
              color = this.goodColor;
              break;
            case AuditionAccuracyRating.MISS:
              text = "MISS";
              color = this.missColor;
              break;
          }
          this.accuracyLabel.string = text;
          this.accuracyLabel.color = color;
          this.accuracyFeedbackNode.active = true;

          // Create pop-up animation
          var originalScale = this.accuracyFeedbackNode.scale.clone();
          this.accuracyFeedbackNode.setScale(0, 0, 1);
          var opacity = this.accuracyFeedbackNode.getComponent(UIOpacity) || this.accuracyFeedbackNode.addComponent(UIOpacity);
          opacity.opacity = 255;

          // Animate the feedback
          this.activeFeedbackAnimation = tween(this.accuracyFeedbackNode).to(0.2, {
            scale: new Vec3(1.2, 1.2, 1)
          }).to(0.1, {
            scale: originalScale
          }).delay(0.5).to(0.3, {
            scale: new Vec3(0.8, 0.8, 1)
          }).parallel(tween(opacity).to(0.3, {
            opacity: 0
          })).call(function () {
            _this2.accuracyFeedbackNode.active = false;
            _this2.accuracyFeedbackNode.setScale(originalScale);
          }).start();
        }

        /**
         * Update the pattern display with a new sequence
         * @param sequence Array of input types in the pattern
         */;
        _proto.updatePatternDisplay = function updatePatternDisplay(sequence) {
          var _this3 = this;
          if (!this.patternDisplay) return;
          this.patternDisplay.active = true;
          this.currentSequence = sequence;
          this.currentProgress = 0;

          // Update each pattern dot
          this.patternDots.forEach(function (dot, index) {
            var sprite = dot.getComponent(Sprite);
            if (index < sequence.length) {
              sprite.color = _this3.getColorForInput(sequence[index]);
              dot.active = true;

              // Reset dot state (not completed)
              // Note: We're just using the default material state here
              // No need to set materials manually
            } else {
              dot.active = false;
            }
          });

          // Show sync point indicator after the last dot
          if (this.syncPointIndicator) {
            this.syncPointIndicator.active = true;

            // Position after the last dot
            if (sequence.length > 0 && sequence.length <= this.patternDots.length) {
              var lastDotPosition = this.patternDots[sequence.length - 1].position;
              this.syncPointIndicator.setPosition(lastDotPosition.x + 60,
              // Adjust as needed for spacing
              lastDotPosition.y, lastDotPosition.z);
            }
          }

          // Reset progress bar
          this.updatePatternProgress(0, sequence.length);
        }

        /**
         * Update the progress through the current pattern
         * @param progress Current progress (number of correct inputs)
         * @param total Total inputs in the pattern
         */;
        _proto.updatePatternProgress = function updatePatternProgress(progress, total) {
          if (!this.patternProgressBar) return;
          this.currentProgress = progress;

          // Update progress bar fill
          var progressRatio = total > 0 ? progress / total : 0;
          var barSprite = this.patternProgressBar.getComponent(Sprite);
          if (barSprite) {
            barSprite.fillRange = progressRatio;
          }

          // Update dot visuals to show completed steps
          for (var i = 0; i < this.patternDots.length; i++) {
            if (i < this.currentSequence.length) {
              var dot = this.patternDots[i];
              var sprite = dot.getComponent(Sprite);
              if (i < progress) {
                // Mark as completed
                sprite.color = this.perfectColor;
              } else {
                // Reset to normal color
                sprite.color = this.getColorForInput(this.currentSequence[i]);
              }
            }
          }

          // When all inputs are completed, highlight sync point
          if (progress === total && this.syncPointIndicator) {
            var syncSprite = this.syncPointIndicator.getComponent(Sprite);
            if (syncSprite) {
              syncSprite.color = this.perfectColor;

              // Pulse animation for sync point
              this.pulseNode(this.syncPointIndicator);
            }
          }
        }

        /**
         * Clear the pattern display
         */;
        _proto.clearPatternDisplay = function clearPatternDisplay() {
          this.currentSequence = [];
          this.currentProgress = 0;
          if (this.patternDisplay) {
            this.patternDisplay.active = false;
          }
          if (this.syncPointIndicator) {
            this.syncPointIndicator.active = false;
          }

          // Hide all dots
          this.patternDots.forEach(function (dot) {
            dot.active = false;
          });
        }

        /**
         * Show button press effect
         * @param inputType Type of input
         * @param correct Whether the input was correct
         */;
        _proto.showButtonPress = function showButtonPress(inputType, correct) {
          var button = null;
          switch (inputType) {
            case AuditionInputType.LEFT:
              button = this.leftButton;
              break;
            case AuditionInputType.RIGHT:
              button = this.rightButton;
              break;
            case AuditionInputType.SPACE:
              button = this.spaceButton;
              break;
          }
          if (!button) return;

          // Get button sprite
          var sprite = button.getComponent(Sprite);
          if (!sprite) return;

          // Store original color
          var originalColor = sprite.color.clone();

          // Set color based on correctness
          sprite.color = correct ? this.perfectColor : this.missColor;

          // Create press animation
          var originalScale = button.scale.clone();
          tween(button).to(0.05, {
            scale: new Vec3(originalScale.x * 0.9, originalScale.y * 0.9, originalScale.z)
          }).to(0.1, {
            scale: originalScale
          }).call(function () {
            // Reset color
            sprite.color = originalColor;
          }).start();
        }

        /**
         * Reset all buttons to normal state
         */;
        _proto.resetButtons = function resetButtons() {
          // Left button
          if (this.leftButton) {
            this.leftButton.setScale(1, 1, 1);
            var leftSprite = this.leftButton.getComponent(Sprite);
            if (leftSprite) leftSprite.color = this.leftButtonColor;
          }

          // Right button
          if (this.rightButton) {
            this.rightButton.setScale(1, 1, 1);
            var rightSprite = this.rightButton.getComponent(Sprite);
            if (rightSprite) rightSprite.color = this.rightButtonColor;
          }

          // Space button
          if (this.spaceButton) {
            this.spaceButton.setScale(1, 1, 1);
            var spaceSprite = this.spaceButton.getComponent(Sprite);
            if (spaceSprite) spaceSprite.color = this.spaceButtonColor;
          }
        }

        /**
         * Show finish move indicator effect
         */;
        _proto.showFinishMoveEffect = function showFinishMoveEffect() {
          var _this4 = this;
          if (!this.finishMoveIndicator || !this.finishMoveLabel) return;
          this.finishMoveIndicator.active = true;
          this.finishMoveLabel.string = "FINISH MOVE!";

          // Play animation if available
          var anim = this.finishMoveIndicator.getComponent(Animation);
          if (anim) {
            anim.play('finish_move_flash');
          } else {
            // Fallback animation if no Animation component
            this.pulseNode(this.finishMoveIndicator, 1.5, 0.5);

            // Auto-hide after animation
            setTimeout(function () {
              _this4.finishMoveIndicator.active = false;
            }, 3000);
          }
        }

        /**
         * Helper to get color for input type
         * @param input Input type
         * @returns Color for that input
         */;
        _proto.getColorForInput = function getColorForInput(input) {
          switch (input) {
            case AuditionInputType.LEFT:
              return this.leftButtonColor;
            case AuditionInputType.RIGHT:
              return this.rightButtonColor;
            case AuditionInputType.SPACE:
              return this.spaceButtonColor;
            default:
              return Color.WHITE;
          }
        }

        /**
         * Create a pulse animation for a node
         * @param node The node to animate
         * @param scale Scale factor (default: 1.2)
         * @param duration Duration in seconds (default: 0.3)
         */;
        _proto.pulseNode = function pulseNode(node, scale, duration) {
          if (scale === void 0) {
            scale = 1.2;
          }
          if (duration === void 0) {
            duration = 0.3;
          }
          if (!node) return;
          var originalScale = node.scale.clone();
          tween(node).to(duration / 2, {
            scale: new Vec3(originalScale.x * scale, originalScale.y * scale, originalScale.z)
          }).to(duration / 2, {
            scale: originalScale
          }).start();
        }

        /**
         * Show pattern skip effect (when a pattern is missed)
         */;
        _proto.showPatternSkipEffect = function showPatternSkipEffect() {
          var _this5 = this;
          if (!this.patternDisplay) return;

          // Flash red and slide out
          var opacity = this.patternDisplay.getComponent(UIOpacity) || this.patternDisplay.addComponent(UIOpacity);
          opacity.opacity = 255;
          var originalPosition = this.patternDisplay.position.clone();
          tween(this.patternDisplay).to(0.1, {
            position: new Vec3(originalPosition.x + 20, originalPosition.y, originalPosition.z)
          }).to(0.1, {
            position: new Vec3(originalPosition.x - 200, originalPosition.y, originalPosition.z)
          }).parallel(tween(opacity).to(0.2, {
            opacity: 0
          })).call(function () {
            _this5.patternDisplay.setPosition(originalPosition);
            _this5.patternDisplay.active = false;
          }).start();
        }

        /**
         * Show pattern completion effect
         * @param isFinishMove Whether this was a finish move
         */;
        _proto.showPatternCompleteEffect = function showPatternCompleteEffect(isFinishMove) {
          var _this6 = this;
          if (isFinishMove === void 0) {
            isFinishMove = false;
          }
          if (!this.patternDisplay) return;

          // Different effects based on whether it's a finish move
          if (isFinishMove) {
            this.showFinishMoveEffect();
          }

          // Fade out pattern display
          var opacity = this.patternDisplay.getComponent(UIOpacity) || this.patternDisplay.addComponent(UIOpacity);
          opacity.opacity = 255;
          tween(opacity).to(0.5, {
            opacity: 0
          }).call(function () {
            _this6.patternDisplay.active = false;
          }).start();
        };
        return AuditionGameplayUI;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "scoreLabel", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "comboLabel", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "multiplierLabel", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "accuracyFeedbackNode", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "accuracyLabel", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "patternDisplay", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "patternDots", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "patternProgressBar", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "syncPointIndicator", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "finishMoveIndicator", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "finishMoveLabel", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "leftButton", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "rightButton", [_dec14], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, "spaceButton", [_dec15], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor15 = _applyDecoratedDescriptor(_class2.prototype, "leftButtonColor", [_dec16], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(79, 195, 247);
        }
      }), _descriptor16 = _applyDecoratedDescriptor(_class2.prototype, "rightButtonColor", [_dec17], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(255, 112, 67);
        }
      }), _descriptor17 = _applyDecoratedDescriptor(_class2.prototype, "spaceButtonColor", [_dec18], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(255, 235, 59);
        }
      }), _descriptor18 = _applyDecoratedDescriptor(_class2.prototype, "perfectColor", [_dec19], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(120, 255, 120);
        }
      }), _descriptor19 = _applyDecoratedDescriptor(_class2.prototype, "goodColor", [_dec20], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(255, 193, 7);
        }
      }), _descriptor20 = _applyDecoratedDescriptor(_class2.prototype, "missColor", [_dec21], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(211, 47, 47);
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionInputHandler.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Node, Input, input, KeyCode, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Input = module.Input;
      input = module.input;
      KeyCode = module.KeyCode;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3, _class3;
      cclegacy._RF.push({}, "3e57c37p+BC+q4zA+47ifrI", "AuditionInputHandler", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Input types for the game
       */
      var AuditionInputType = exports('AuditionInputType', /*#__PURE__*/function (AuditionInputType) {
        AuditionInputType[AuditionInputType["LEFT"] = 0] = "LEFT";
        AuditionInputType[AuditionInputType["RIGHT"] = 1] = "RIGHT";
        AuditionInputType[AuditionInputType["SPACE"] = 2] = "SPACE";
        return AuditionInputType;
      }({}));

      /**
       * Input handler for Audition module
       * Manages touch and keyboard inputs
       */
      var AuditionInputHandler = exports('AuditionInputHandler', (_dec = ccclass('AuditionInputHandler'), _dec2 = property(Node), _dec3 = property(Node), _dec4 = property(Node), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionInputHandler, _Component);
        function AuditionInputHandler() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Input areas
          _initializerDefineProperty(_this, "leftInputArea", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "rightInputArea", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "spaceInputArea", _descriptor3, _assertThisInitialized(_this));
          // Internal properties
          _this.isInputEnabled = true;
          _this.inputCallbacks = new Map();
          _this.lastInputTime = new Map();
          _this.inputDebounceTime = 100;
          return _this;
        }
        var _proto = AuditionInputHandler.prototype;
        _proto.onLoad = function onLoad() {
          // Make this a singleton
          if (AuditionInputHandler._instance === null) {
            AuditionInputHandler._instance = this;
            this.initialize();
          } else {
            this.node.destroy();
          }
        }

        /**
         * Initialize input handler
         */;
        _proto.initialize = function initialize() {
          // Initialize input callbacks maps
          this.inputCallbacks.set(AuditionInputType.LEFT, []);
          this.inputCallbacks.set(AuditionInputType.RIGHT, []);
          this.inputCallbacks.set(AuditionInputType.SPACE, []);

          // Initialize last input times
          this.lastInputTime.set(AuditionInputType.LEFT, 0);
          this.lastInputTime.set(AuditionInputType.RIGHT, 0);
          this.lastInputTime.set(AuditionInputType.SPACE, 0);

          // Register touch event listeners
          this.registerTouchEvents();

          // Register keyboard event listeners
          this.registerKeyboardEvents();
          console.log('Audition Input Handler initialized');
        }

        /**
         * Register touch event listeners
         */;
        _proto.registerTouchEvents = function registerTouchEvents() {
          var _this2 = this;
          // Left input area
          if (this.leftInputArea) {
            this.leftInputArea.on(Input.EventType.TOUCH_START, function (event) {
              if (_this2.isInputEnabled) {
                _this2.handleInput(AuditionInputType.LEFT);
              }
            });
          }

          // Right input area
          if (this.rightInputArea) {
            this.rightInputArea.on(Input.EventType.TOUCH_START, function (event) {
              if (_this2.isInputEnabled) {
                _this2.handleInput(AuditionInputType.RIGHT);
              }
            });
          }

          // Space input area
          if (this.spaceInputArea) {
            this.spaceInputArea.on(Input.EventType.TOUCH_START, function (event) {
              if (_this2.isInputEnabled) {
                _this2.handleInput(AuditionInputType.SPACE);
              }
            });
          }
        }

        /**
         * Register keyboard event listeners
         */;
        _proto.registerKeyboardEvents = function registerKeyboardEvents() {
          var _this3 = this;
          input.on(Input.EventType.KEY_DOWN, function (event) {
            if (!_this3.isInputEnabled) return;
            switch (event.keyCode) {
              case KeyCode.ARROW_LEFT:
              case KeyCode.KEY_A:
                _this3.handleInput(AuditionInputType.LEFT);
                break;
              case KeyCode.ARROW_RIGHT:
              case KeyCode.KEY_D:
                _this3.handleInput(AuditionInputType.RIGHT);
                break;
              case KeyCode.SPACE:
                _this3.handleInput(AuditionInputType.SPACE);
                break;
            }
          });
        }

        /**
         * Handle input event
         * @param inputType Type of input
         */;
        _proto.handleInput = function handleInput(inputType) {
          var currentTime = Date.now();
          var lastTime = this.lastInputTime.get(inputType);

          // Check for input debouncing
          if (currentTime - lastTime < this.inputDebounceTime) {
            return;
          }

          // Update last input time
          this.lastInputTime.set(inputType, currentTime);

          // Call all registered callbacks for this input type
          var callbacks = this.inputCallbacks.get(inputType);
          if (callbacks) {
            callbacks.forEach(function (callback) {
              return callback(currentTime);
            });
          }
          console.log("Input detected: " + AuditionInputType[inputType]);
        }

        /**
         * Register a callback for an input type
         * @param inputType Type of input
         * @param callback Function to call when input is detected
         */;
        _proto.registerInputCallback = function registerInputCallback(inputType, callback) {
          var callbacks = this.inputCallbacks.get(inputType);
          if (callbacks) {
            callbacks.push(callback);
          }
        }

        /**
         * Unregister a callback for an input type
         * @param inputType Type of input
         * @param callback Function to remove
         */;
        _proto.unregisterInputCallback = function unregisterInputCallback(inputType, callback) {
          var callbacks = this.inputCallbacks.get(inputType);
          if (callbacks) {
            var index = callbacks.indexOf(callback);
            if (index !== -1) {
              callbacks.splice(index, 1);
            }
          }
        }

        /**
         * Enable or disable input
         * @param enabled Whether input should be enabled
         */;
        _proto.setInputEnabled = function setInputEnabled(enabled) {
          this.isInputEnabled = enabled;
          console.log("Input " + (enabled ? 'enabled' : 'disabled'));
        }

        /**
         * Check if input is enabled
         * @returns True if input is enabled, false otherwise
         */;
        _proto.getInputEnabled = function getInputEnabled() {
          return this.isInputEnabled;
        }

        /**
         * Set the debounce time for inputs
         * @param time Time in milliseconds
         */;
        _proto.setInputDebounceTime = function setInputDebounceTime(time) {
          this.inputDebounceTime = time;
        }

        /**
         * Get the current debounce time
         * @returns Debounce time in milliseconds
         */;
        _proto.getInputDebounceTime = function getInputDebounceTime() {
          return this.inputDebounceTime;
        }

        /**
         * Simulate an input event for auto-play functionality
         * @param inputType Type of input to simulate
         * @param time Time of the input event
         */;
        _proto.simulateInput = function simulateInput(inputType, time) {
          // Update last input time
          this.lastInputTime.set(inputType, time);

          // Call all registered callbacks for this input type
          var callbacks = this.inputCallbacks.get(inputType);
          if (callbacks) {
            callbacks.forEach(function (callback) {
              return callback(time);
            });
          }
          console.log("Simulated input: " + AuditionInputType[inputType]);
        };
        _createClass(AuditionInputHandler, null, [{
          key: "instance",
          get:
          // Minimum time between inputs (ms)
          // Singleton pattern implementation
          function get() {
            return this._instance;
          }
        }]);
        return AuditionInputHandler;
      }(Component), _class3._instance = null, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "leftInputArea", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "rightInputArea", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "spaceInputArea", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionMainMenuController.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AuditionAudioManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Button, Node, Label, Vec3, tween, UIOpacity, Component, AuditionAudioManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Button = module.Button;
      Node = module.Node;
      Label = module.Label;
      Vec3 = module.Vec3;
      tween = module.tween;
      UIOpacity = module.UIOpacity;
      Component = module.Component;
    }, function (module) {
      AuditionAudioManager = module.AuditionAudioManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10;
      cclegacy._RF.push({}, "89cd9G0+vdPI7ElDHJDudjd", "AuditionMainMenuController", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Controller for the Main Menu scene
       * Provides options for navigating to different parts of the game
       */
      var AuditionMainMenuController = exports('AuditionMainMenuController', (_dec = ccclass('AuditionMainMenuController'), _dec2 = property(Button), _dec3 = property(Button), _dec4 = property(Button), _dec5 = property(Button), _dec6 = property(Node), _dec7 = property(Label), _dec8 = property(Label), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionMainMenuController, _Component);
        function AuditionMainMenuController() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // UI elements
          _initializerDefineProperty(_this, "playButton", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "customizeButton", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "optionsButton", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "exitButton", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "logoNode", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "playerLevelLabel", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "versionLabel", _descriptor7, _assertThisInitialized(_this));
          // Audio settings
          _initializerDefineProperty(_this, "backgroundMusicPath", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "buttonSound", _descriptor9, _assertThisInitialized(_this));
          // Animation settings
          _initializerDefineProperty(_this, "animateElements", _descriptor10, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = AuditionMainMenuController.prototype;
        _proto.onLoad = function onLoad() {
          // Setup button events
          this.setupButtonEvents();

          // Initialize UI animations
          if (this.animateElements) {
            this.initializeAnimations();
          }

          // Set version label
          if (this.versionLabel) {
            this.versionLabel.string = 'v0.1.0 Alpha';
          }
        };
        _proto.start = function start() {
          // Play background music
          this.playBackgroundMusic();
        }

        /**
         * Setup button event listeners
         */;
        _proto.setupButtonEvents = function setupButtonEvents() {
          // Play button
          if (this.playButton) {
            this.playButton.node.on(Button.EventType.CLICK, this.onPlayButtonClicked, this);
          }

          // Customize button
          if (this.customizeButton) {
            this.customizeButton.node.on(Button.EventType.CLICK, this.onCustomizeButtonClicked, this);
          }

          // Options button
          if (this.optionsButton) {
            this.optionsButton.node.on(Button.EventType.CLICK, this.onOptionsButtonClicked, this);
          }

          // Exit button
          if (this.exitButton) {
            this.exitButton.node.on(Button.EventType.CLICK, this.onExitButtonClicked, this);
          }
        }

        /**
         * Initialize animations for UI elements
         */;
        _proto.initializeAnimations = function initializeAnimations() {
          // Animate logo
          if (this.logoNode) {
            // Start from slightly larger scale
            this.logoNode.scale = new Vec3(1.2, 1.2, 1);

            // Create a subtle floating animation
            tween(this.logoNode).to(2.0, {
              scale: new Vec3(1.1, 1.1, 1)
            }).to(2.0, {
              scale: new Vec3(1.2, 1.2, 1)
            }).union().repeatForever().start();
          }

          // Animate buttons (if present)
          var buttons = [this.playButton, this.customizeButton, this.optionsButton, this.exitButton];
          buttons.forEach(function (button, index) {
            if (button) {
              var originalScale = button.node.scale.clone();

              // Add hover effect
              button.node.on(Node.EventType.MOUSE_ENTER, function () {
                tween(button.node).to(0.2, {
                  scale: new Vec3(originalScale.x * 1.1, originalScale.y * 1.1, 1)
                }).start();
              });
              button.node.on(Node.EventType.MOUSE_LEAVE, function () {
                tween(button.node).to(0.2, {
                  scale: originalScale
                }).start();
              });

              // Initial animation: fade in from bottom
              button.node.setPosition(button.node.position.x, button.node.position.y - 50);

              // Setup UIOpacity component
              var opacityComp = button.node.getComponent(UIOpacity);
              if (!opacityComp) {
                opacityComp = button.node.addComponent(UIOpacity);
              }
              opacityComp.opacity = 0;

              // Tween position and opacity
              tween(button.node).delay(0.2 + index * 0.1).to(0.5, {
                position: new Vec3(button.node.position.x, button.node.position.y + 50, 0)
              }, {
                easing: 'backOut'
              }).start();

              // Tween opacity separately
              tween(opacityComp).delay(0.2 + index * 0.1).to(0.5, {
                opacity: 255
              }).start();
            }
          });
        }

        /**
         * Play background music for the menu
         */;
        _proto.playBackgroundMusic = function playBackgroundMusic() {
          var audioManager = AuditionAudioManager.instance;
          if (audioManager) {
            audioManager.loadSong(this.backgroundMusicPath).then(function () {
              audioManager.playSong();
            })["catch"](function (error) {
              console.error('Failed to load menu music:', error);
            });
          }
        }

        /**
         * Handle play button click
         */;
        _proto.onPlayButtonClicked = function onPlayButtonClicked() {
          AuditionAudioManager.instance.playSound(this.buttonSound);
        }

        /**
         * Handle customize button click
         */;
        _proto.onCustomizeButtonClicked = function onCustomizeButtonClicked() {
          AuditionAudioManager.instance.playSound(this.buttonSound);
          // Navigate to customization scene (if implemented)
          console.log('Customize button clicked - Feature coming soon');
        }

        /**
         * Handle options button click
         */;
        _proto.onOptionsButtonClicked = function onOptionsButtonClicked() {
          AuditionAudioManager.instance.playSound(this.buttonSound);
          // Navigate to options scene (if implemented)
          console.log('Options button clicked - Feature coming soon');
        }

        /**
         * Handle exit button click
         */;
        _proto.onExitButtonClicked = function onExitButtonClicked() {
          AuditionAudioManager.instance.playSound(this.buttonSound);
          console.log('Exit button clicked');
          // Implementation depends on target platform
          // For web, might just return to a landing page
        };

        _proto.onDestroy = function onDestroy() {
          // Stop background music
          var audioManager = AuditionAudioManager.instance;
          if (audioManager) {
            audioManager.stopSong();
          }
        };
        return AuditionMainMenuController;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "playButton", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "customizeButton", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "optionsButton", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "exitButton", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "logoNode", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "playerLevelLabel", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "versionLabel", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "backgroundMusicPath", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 'audition/audio/menu_music';
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "buttonSound", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 'click';
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "animateElements", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionNote.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AuditionNotePool.ts', './AuditionNoteVisual.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Component, AuditionNoteType, AuditionNoteVisual;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
    }, function (module) {
      AuditionNoteType = module.AuditionNoteType;
    }, function (module) {
      AuditionNoteVisual = module.AuditionNoteVisual;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "b06301HH+lNDJwPFjxXjoas", "AuditionNote", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Component attached to note objects in the rhythm game
       * Handles note appearance, movement, and hit effects
       */
      var AuditionNote = exports('AuditionNote', (_dec = ccclass('AuditionNote'), _dec2 = property(AuditionNoteVisual), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionNote, _Component);
        function AuditionNote() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "noteVisual", _descriptor, _assertThisInitialized(_this));
          // Note properties
          _this.noteType = AuditionNoteType.LEFT;
          _this.beatTime = 0;
          _this.targetY = 0;
          _this.startY = 0;
          _this.isMoving = false;
          _this.noteId = -1;
          return _this;
        }
        var _proto = AuditionNote.prototype;
        /**
         * Initialize note with properties
         * @param noteType Type of note
         * @param beatTime Time (ms) when the note should be hit
         * @param noteId Unique ID for the note
         */
        _proto.initialize = function initialize(noteType, beatTime, noteId) {
          this.noteType = noteType;
          this.beatTime = beatTime;
          this.noteId = noteId;

          // Initialize visual component
          if (this.noteVisual) {
            this.noteVisual.initialize();
          } else {
            console.warn('Note visual component is not assigned!');
          }

          // The name could be updated to help with recycling identification
          switch (this.noteType) {
            case AuditionNoteType.LEFT:
              this.node.name = 'LeftNote';
              break;
            case AuditionNoteType.RIGHT:
              this.node.name = 'RightNote';
              break;
          }
        }

        /**
         * Play hit animation when note is successfully hit
         * @param accuracyRating Accuracy rating of the hit
         */;
        _proto.playHitEffect = function playHitEffect(accuracyRating) {
          // Stop movement
          this.isMoving = false;

          // Use visual component to show hit effect
          if (this.noteVisual) {
            this.noteVisual.showHitEffect(accuracyRating);
          }
        }

        /**
         * Play miss animation when note is missed
         */;
        _proto.playMissEffect = function playMissEffect() {
          this.isMoving = false;

          // Use visual component to show miss effect
          if (this.noteVisual) {
            this.noteVisual.showMissEffect();
          }
        }

        /**
         * Reset the note for reuse
         */;
        _proto.reset = function reset() {
          this.isMoving = false;

          // Reset visual component
          if (this.noteVisual) {
            this.noteVisual.reset();
          }

          // Make sure node is active for next use
          this.node.active = true;
        }

        /**
         * Check if this note matches the given input type
         * @param inputType The input type to check against
         * @returns True if the note type matches the input type
         */;
        _proto.matchesInput = function matchesInput(inputType) {
          return this.noteType === inputType;
        }

        /**
         * Get the note's unique ID (for recycling)
         * @returns The note ID
         */;
        _proto.getNoteId = function getNoteId() {
          return this.noteId;
        }

        /**
         * Get the note type
         * @returns The note type
         */;
        _proto.getNoteType = function getNoteType() {
          return this.noteType;
        };
        return AuditionNote;
      }(Component), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "noteVisual", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionNotePool.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Prefab, instantiate, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Prefab = module.Prefab;
      instantiate = module.instantiate;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;
      cclegacy._RF.push({}, "dcf6eWvaXRMR72esUo9n+2S", "AuditionNotePool", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Enum representing different note types
       */
      var AuditionNoteType = exports('AuditionNoteType', /*#__PURE__*/function (AuditionNoteType) {
        AuditionNoteType[AuditionNoteType["LEFT"] = 0] = "LEFT";
        AuditionNoteType[AuditionNoteType["RIGHT"] = 1] = "RIGHT";
        return AuditionNoteType;
      }({}));

      /**
       * Object pooling system for rhythm game notes
       * Manages the creation, reuse, and recycling of note objects for optimal performance
       */
      var AuditionNotePool = exports('AuditionNotePool', (_dec = ccclass('AuditionNotePool'), _dec2 = property(Prefab), _dec3 = property(Prefab), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionNotePool, _Component);
        function AuditionNotePool() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Prefabs for different note types
          _initializerDefineProperty(_this, "leftNotePrefab", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "rightNotePrefab", _descriptor2, _assertThisInitialized(_this));
          // Pool configuration
          _initializerDefineProperty(_this, "initialPoolSize", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "expandPoolAmount", _descriptor4, _assertThisInitialized(_this));
          // Object pools for each note type
          _this.leftNotePool = [];
          _this.rightNotePool = [];
          // Active notes currently in use
          _this.activeNotes = new Map();
          // Unique ID counter for notes
          _this.nextNoteId = 0;
          return _this;
        }
        var _proto = AuditionNotePool.prototype;
        _proto.onLoad = function onLoad() {
          // Initialize the pools
          this.initializePools();
        }

        /**
         * Initialize note pools with initial sizes
         */;
        _proto.initializePools = function initializePools() {
          // Create pools for each note type
          if (this.leftNotePrefab) {
            this.createPool(AuditionNoteType.LEFT, this.initialPoolSize);
          }
          if (this.rightNotePrefab) {
            this.createPool(AuditionNoteType.RIGHT, this.initialPoolSize);
          }
        }

        /**
         * Create a pool of note objects
         * @param noteType The type of note
         * @param size The initial size of the pool
         */;
        _proto.createPool = function createPool(noteType, size) {
          var pool = this.getPoolForType(noteType);
          var prefab = this.getPrefabForType(noteType);
          if (!prefab) {
            console.error("No prefab defined for note type: " + noteType);
            return;
          }

          // Create notes and add to pool
          for (var i = 0; i < size; i++) {
            var note = instantiate(prefab);
            note.parent = this.node;
            note.active = false;
            pool.push(note);
          }
          console.log("Created pool for note type " + noteType + " with " + size + " notes");
        }

        /**
         * Get a note from the pool, creating new ones if needed
         * @param noteType The type of note to get
         * @returns A reference to the note object and its unique ID
         */;
        _proto.getNote = function getNote(noteType) {
          var pool = this.getPoolForType(noteType);

          // If pool is empty, expand it
          if (pool.length === 0) {
            this.expandPool(noteType);
          }

          // Get a note from the pool
          var noteNode = pool.pop();
          if (!noteNode) {
            console.error("Failed to get note of type " + noteType + " from pool");
            return null;
          }

          // Prepare note for use
          noteNode.active = true;

          // Generate unique ID and track the active note
          var noteId = this.nextNoteId++;
          this.activeNotes.set(noteId, noteNode);
          return {
            id: noteId,
            node: noteNode
          };
        }

        /**
         * Return a note to the pool
         * @param noteId The unique ID of the note
         */;
        _proto.recycleNote = function recycleNote(noteId) {
          var noteNode = this.activeNotes.get(noteId);
          if (!noteNode) {
            console.warn("Note with ID " + noteId + " not found in active notes");
            return;
          }

          // Reset note properties
          noteNode.active = false;
          noteNode.setPosition(0, 0, 0);
          noteNode.setScale(1, 1, 1);

          // Get the note type and return to appropriate pool
          var noteType = this.getNoteTypeFromNode(noteNode);
          var pool = this.getPoolForType(noteType);

          // Add back to pool and remove from active notes
          pool.push(noteNode);
          this.activeNotes["delete"](noteId);
        }

        /**
         * Recycle all active notes at once (for scene changes or resets)
         */;
        _proto.recycleAllNotes = function recycleAllNotes() {
          var _this2 = this;
          // Create a copy of the IDs to avoid modification during iteration
          var noteIds = Array.from(this.activeNotes.keys());

          // Recycle each note
          noteIds.forEach(function (id) {
            return _this2.recycleNote(id);
          });
        }

        /**
         * Expand a note pool when it runs out of objects
         * @param noteType The type of note pool to expand
         */;
        _proto.expandPool = function expandPool(noteType) {
          console.log("Expanding pool for note type " + noteType + " with " + this.expandPoolAmount + " more notes");
          this.createPool(noteType, this.expandPoolAmount);
        }

        /**
         * Get the appropriate pool for a note type
         * @param noteType The type of note
         * @returns The pool array for the note type
         */;
        _proto.getPoolForType = function getPoolForType(noteType) {
          switch (noteType) {
            case AuditionNoteType.LEFT:
              return this.leftNotePool;
            case AuditionNoteType.RIGHT:
              return this.rightNotePool;
            default:
              console.error("Unknown note type: " + noteType);
              return null;
          }
        }

        /**
         * Get the appropriate prefab for a note type
         * @param noteType The type of note
         * @returns The prefab for the note type
         */;
        _proto.getPrefabForType = function getPrefabForType(noteType) {
          switch (noteType) {
            case AuditionNoteType.LEFT:
              return this.leftNotePrefab;
            case AuditionNoteType.RIGHT:
              return this.rightNotePrefab;
            default:
              console.error("Unknown note type: " + noteType);
              return null;
          }
        }

        /**
         * Determine the note type from a node
         * This implementation uses a simple name-based approach, but you could use
         * a custom component or other method to identify note types
         * @param noteNode The note node to check
         * @returns The identified note type
         */;
        _proto.getNoteTypeFromNode = function getNoteTypeFromNode(noteNode) {
          // This is a simple implementation; you might want to improve this
          // based on how your notes are structured
          var nodeName = noteNode.name.toLowerCase();
          if (nodeName.includes('left')) {
            return AuditionNoteType.LEFT;
          }
          return AuditionNoteType.RIGHT;
        }

        /**
         * Get the count of active notes
         * @returns The number of active notes
         */;
        _proto.getActiveNoteCount = function getActiveNoteCount() {
          return this.activeNotes.size;
        }

        /**
         * Get available notes in the pool
         * @param noteType The type of note
         * @returns The number of notes available in the pool
         */;
        _proto.getAvailableNoteCount = function getAvailableNoteCount(noteType) {
          var pool = this.getPoolForType(noteType);
          return pool ? pool.length : 0;
        };
        return AuditionNotePool;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "leftNotePrefab", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "rightNotePrefab", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "initialPoolSize", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 20;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "expandPoolAmount", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 10;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionNoteVisual.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Sprite, UIOpacity, Color, Vec3, tween, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Sprite = module.Sprite;
      UIOpacity = module.UIOpacity;
      Color = module.Color;
      Vec3 = module.Vec3;
      tween = module.tween;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10;
      cclegacy._RF.push({}, "3407dOpf11DQZytuXaeEQcr", "AuditionNoteVisual", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Visual component for Audition Note prefabs
       * Handles visual appearance, effects, and animations for notes
       */
      var AuditionNoteVisual = exports('AuditionNoteVisual', (_dec = ccclass('AuditionNoteVisual'), _dec2 = property(Sprite), _dec3 = property(Sprite), _dec4 = property(UIOpacity), _dec5 = property(Color), _dec6 = property(Color), _dec7 = property(Color), _dec8 = property(Color), _dec9 = property(Color), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionNoteVisual, _Component);
        function AuditionNoteVisual() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Visual components
          _initializerDefineProperty(_this, "noteSprite", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "glowSprite", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "opacity", _descriptor3, _assertThisInitialized(_this));
          // Visual configuration
          _initializerDefineProperty(_this, "pulseSpeed", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "pulseIntensity", _descriptor5, _assertThisInitialized(_this));
          // Colors for different note types
          _initializerDefineProperty(_this, "leftNoteColor", _descriptor6, _assertThisInitialized(_this));
          // Light blue
          _initializerDefineProperty(_this, "rightNoteColor", _descriptor7, _assertThisInitialized(_this));
          // Coral red
          // Colors for accuracy feedback
          _initializerDefineProperty(_this, "perfectColor", _descriptor8, _assertThisInitialized(_this));
          // Bright green
          _initializerDefineProperty(_this, "goodColor", _descriptor9, _assertThisInitialized(_this));
          // Amber
          _initializerDefineProperty(_this, "missColor", _descriptor10, _assertThisInitialized(_this));
          // Red
          // Animation settings
          _this.hitAnimDuration = 0.2;
          _this.missAnimDuration = 0.4;
          _this.appearAnimDuration = 0.05;
          // State
          _this.activeTweens = [];
          _this.originalScale = new Vec3(1, 1, 1);
          _this.isHit = false;
          return _this;
        }
        var _proto = AuditionNoteVisual.prototype;
        _proto.onLoad = function onLoad() {
          // Store original scale
          if (this.node) {
            this.originalScale = this.node.getScale().clone();
          }

          // Set opacity component if not set
          if (!this.opacity) {
            this.opacity = this.getComponent(UIOpacity);
            if (!this.opacity) {
              this.opacity = this.addComponent(UIOpacity);
            }
          }
        }

        /**
         * Initialize the note's appearance based on type
         * @param type Note type
         */;
        _proto.initialize = function initialize() {
          this.isHit = false;

          // Reset transforms
          this.node.setScale(this.originalScale);
          this.node.setRotation(0, 0, 0, 1);

          // Set opacity to full
          if (this.opacity) {
            this.opacity.opacity = 255;
          }

          // Play appear animation
          // this.playAppearAnimation();
        }

        /**
         * Play animation for when note appears
         */;
        _proto.playAppearAnimation = function playAppearAnimation() {
          var _this2 = this;
          if (!this.node) return;

          // Stop any existing animations
          this.stopAllTweens();

          // Reset scale
          this.node.setScale(0, 0, 1);

          // Animate scale and opacity
          var appearTween = tween(this.node).to(this.appearAnimDuration, {
            scale: this.originalScale
          }, {
            easing: 'backOut'
          }).call(function () {
            _this2.startPulseAnimation();
          }).start();
          this.activeTweens.push(appearTween);
        }

        /**
         * Start the idle pulse animation
         */;
        _proto.startPulseAnimation = function startPulseAnimation() {
          if (!this.node || this.isHit) return;

          // Stop any existing animations
          this.stopAllTweens();

          // Create pulse animation
          var pulseTween = tween(this.node).to(this.pulseSpeed / 2, {
            scale: new Vec3(this.originalScale.x * (1 + this.pulseIntensity), this.originalScale.y * (1 + this.pulseIntensity), this.originalScale.z)
          }, {
            easing: 'sineInOut'
          }).to(this.pulseSpeed / 2, {
            scale: this.originalScale
          }, {
            easing: 'sineInOut'
          }).union().repeatForever().start();
          this.activeTweens.push(pulseTween);
        };
        _proto.stopAllTweens = function stopAllTweens() {
          this.activeTweens.forEach(function (tween) {
            return tween.stop();
          });
          this.activeTweens = [];
        }

        /**
         * Show hit effect based on accuracy
         * @param accuracyRating Accuracy rating of the hit
         */;
        _proto.showHitEffect = function showHitEffect() {
          if (!this.node) return;
          this.isHit = true;

          // Stop any existing animations
          this.stopAllTweens();

          // Play hit animation
          var targetScale = new Vec3(this.originalScale.x * 1.5, this.originalScale.y * 1.5, this.originalScale.z);
          var hitTween = tween(this.node).to(this.hitAnimDuration / 3, {
            scale: targetScale
          }, {
            easing: 'quadOut'
          }).to(this.hitAnimDuration * 2 / 3, {
            scale: this.originalScale
          }, {
            easing: 'quadIn'
          }).start();
          this.activeTweens.push(hitTween);

          // Also animate opacity
          if (this.opacity) {
            var opacityTween = tween(this.opacity).to(this.hitAnimDuration, {
              opacity: 50
            }).start();
            this.activeTweens.push(opacityTween);
          }
        }

        /**
         * Show miss effect
         */;
        _proto.showMissEffect = function showMissEffect() {
          var _this3 = this;
          if (!this.node) return;
          this.isHit = true;

          // Stop any existing animations
          this.stopAllTweens();

          // Apply miss color to glow
          if (this.glowSprite) {
            this.glowSprite.color = this.missColor;
            this.glowSprite.node.active = true;
          }

          // Play miss animation - fade and move down slightly
          var endPosition = new Vec3(this.node.position.x, this.node.position.y - 50, this.node.position.z);
          var missTween = tween(this.node).to(this.missAnimDuration, {
            position: endPosition,
            scale: new Vec3(this.originalScale.x * 0.7, this.originalScale.y * 0.7, this.originalScale.z)
          }, {
            easing: 'quadIn'
          }).call(function () {
            // Hide note after animation
            _this3.node.active = false;
          }).start();
          this.activeTweens.push(missTween);

          // Also animate opacity
          if (this.opacity) {
            var opacityTween = tween(this.opacity).to(this.missAnimDuration, {
              opacity: 0
            }).start();
            this.activeTweens.push(opacityTween);
          }
        }

        /**
         * Reset the note to its initial state
         */;
        _proto.reset = function reset() {
          // Stop any active animations
          this.stopAllTweens();

          // Reset transforms
          this.node.setScale(this.originalScale);
          this.node.setRotation(0, 0, 0, 1);

          // Reset opacity
          if (this.opacity) {
            this.opacity.opacity = 255;
          }

          // Reset glow
          if (this.glowSprite) {
            this.glowSprite.node.active = false;
          }
          this.isHit = false;
        };
        return AuditionNoteVisual;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "noteSprite", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "glowSprite", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "opacity", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "pulseSpeed", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1.0;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "pulseIntensity", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.2;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "leftNoteColor", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(79, 195, 247);
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "rightNoteColor", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(255, 112, 67);
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "perfectColor", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(120, 255, 120);
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "goodColor", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(255, 193, 7);
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "missColor", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(211, 47, 47);
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionRandomBackground.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, SpriteFrame, MeshRenderer, randomRangeInt, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      SpriteFrame = module.SpriteFrame;
      MeshRenderer = module.MeshRenderer;
      randomRangeInt = module.randomRangeInt;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "9c847FTTeVHTLgt1NPmkCyR", "AuditionRandomBackground", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var AuditionRandomBackground = exports('AuditionRandomBackground', (_dec = ccclass('AuditionRandomBackground'), _dec2 = property([SpriteFrame]), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionRandomBackground, _Component);
        function AuditionRandomBackground() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "backgroundFrames", _descriptor, _assertThisInitialized(_this));
          _this.meshRenderer = null;
          return _this;
        }
        var _proto = AuditionRandomBackground.prototype;
        _proto.onLoad = function onLoad() {
          this.meshRenderer = this.getComponent(MeshRenderer);
          if (!this.meshRenderer) {
            console.error('MeshRenderer component not found on AuditionRandomBackground');
            return;
          }
          if (this.backgroundFrames.length > 0) {
            var randomIndex = randomRangeInt(0, this.backgroundFrames.length);
            var randomFrame = this.backgroundFrames[randomIndex];
            if (this.meshRenderer.material) {
              this.meshRenderer.material.setProperty('mainTexture', randomFrame.texture);
            }
          }
        };
        _proto.update = function update(deltaTime) {};
        return AuditionRandomBackground;
      }(Component), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "backgroundFrames", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionResultsController.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AuditionAudioManager.ts', './AuditionUIManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Button, Node, Label, Vec3, UIOpacity, tween, Component, AuditionAudioManager, AuditionUIManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Button = module.Button;
      Node = module.Node;
      Label = module.Label;
      Vec3 = module.Vec3;
      UIOpacity = module.UIOpacity;
      tween = module.tween;
      Component = module.Component;
    }, function (module) {
      AuditionAudioManager = module.AuditionAudioManager;
    }, function (module) {
      AuditionUIManager = module.AuditionUIManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9;
      cclegacy._RF.push({}, "2c315k/8UpN5rJQH/P/zdLe", "AuditionResultsController", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Controller for the Results scene
       * Displays performance stats and provides navigation options
       */
      var AuditionResultsController = exports('AuditionResultsController', (_dec = ccclass('AuditionResultsController'), _dec2 = property(Button), _dec3 = property(Button), _dec4 = property(Button), _dec5 = property(Node), _dec6 = property(Node), _dec7 = property(Label), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionResultsController, _Component);
        function AuditionResultsController() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // UI components
          _initializerDefineProperty(_this, "retryButton", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "nextButton", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "mainMenuButton", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "resultsContent", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "expGainDisplay", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "expGainLabel", _descriptor6, _assertThisInitialized(_this));
          // Audio settings
          _initializerDefineProperty(_this, "backgroundMusicPath", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "buttonClickSound", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "resultsSound", _descriptor9, _assertThisInitialized(_this));
          _this.isAnimatingResults = false;
          return _this;
        }
        var _proto = AuditionResultsController.prototype;
        _proto.onLoad = function onLoad() {
          // Setup UI
          AuditionUIManager.instance.showResults();

          // Setup button events
          this.setupButtonEvents();

          // Hide results content initially for animation
          if (this.resultsContent) {
            this.resultsContent.scale = new Vec3(0.8, 0.8, 1);

            // Ensure there's a UIOpacity component
            var opacityComp = this.resultsContent.getComponent(UIOpacity);
            if (!opacityComp) {
              opacityComp = this.resultsContent.addComponent(UIOpacity);
            }
            opacityComp.opacity = 0;
          }

          // Hide exp gain display initially
          if (this.expGainDisplay) {
            this.expGainDisplay.active = false;
          }
        };
        _proto.start = function start() {
          var _this2 = this;
          // Play background music
          this.playBackgroundMusic();

          // Play results sound
          AuditionAudioManager.instance.playSound(this.resultsSound);

          // Animate results with a slight delay
          this.scheduleOnce(function () {
            _this2.animateResults();
          }, 0.5);
        }

        /**
         * Setup button event listeners
         */;
        _proto.setupButtonEvents = function setupButtonEvents() {
          // Retry button
          if (this.retryButton) {
            this.retryButton.node.on(Button.EventType.CLICK, this.onRetryButtonClicked, this);
            this.retryButton.interactable = false; // Disabled until animation completes
          }

          // Next button
          if (this.nextButton) {
            this.nextButton.node.on(Button.EventType.CLICK, this.onNextButtonClicked, this);
            this.nextButton.interactable = false; // Disabled until animation completes
          }

          // Main menu button
          if (this.mainMenuButton) {
            this.mainMenuButton.node.on(Button.EventType.CLICK, this.onMainMenuButtonClicked, this);
            this.mainMenuButton.interactable = false; // Disabled until animation completes
          }
        }

        /**
         * Play background music for the results screen
         */;
        _proto.playBackgroundMusic = function playBackgroundMusic() {
          var audioManager = AuditionAudioManager.instance;
          if (audioManager) {
            audioManager.loadSong(this.backgroundMusicPath).then(function () {
              audioManager.playSong();
            })["catch"](function (error) {
              console.error('Failed to load results music:', error);
            });
          }
        }

        /**
         * Animate the results screen appearance
         */;
        _proto.animateResults = function animateResults() {
          var _this3 = this;
          if (!this.resultsContent) return;
          this.isAnimatingResults = true;

          // Make results content visible
          this.resultsContent.active = true;

          // Animate scale and opacity
          tween(this.resultsContent).to(0.5, {
            scale: new Vec3(1, 1, 1)
          }).start();

          // Get or add UIOpacity component
          var opacityComp = this.resultsContent.getComponent(UIOpacity) || this.resultsContent.addComponent(UIOpacity);
          if (opacityComp) {
            tween(opacityComp).to(0.5, {
              opacity: 255
            }).call(function () {
              // Show experience gain after results are displayed
              _this3.scheduleOnce(function () {
                _this3.showExperienceGain();
              }, 1.0);
            }).start();
          }
        }

        /**
         * Show experience gain animation
         */;
        _proto.showExperienceGain = function showExperienceGain() {
          var _this4 = this;
          if (!this.expGainDisplay || !this.expGainLabel) return;

          // Set experience gain text - Using a default value of 100 EXP
          // Note: Implement getLastExperienceGain in AuditionGameManager
          var lastSongExp = 100; // Default value until proper implementation
          if (this.expGainLabel) {
            this.expGainLabel.string = "+" + lastSongExp + " EXP";
          }

          // Show display
          this.expGainDisplay.active = true;

          // Animate with a bounce effect
          this.expGainDisplay.scale = new Vec3(0.5, 0.5, 1);
          tween(this.expGainDisplay).to(0.3, {
            scale: new Vec3(1.2, 1.2, 1)
          }).to(0.2, {
            scale: new Vec3(1, 1, 1)
          }).call(function () {
            // Animation complete, enable buttons
            _this4.enableButtons();
            _this4.isAnimatingResults = false;
          }).start();
        }

        /**
         * Enable navigation buttons
         */;
        _proto.enableButtons = function enableButtons() {
          if (this.retryButton) {
            this.retryButton.interactable = true;
          }
          if (this.nextButton) {
            this.nextButton.interactable = true;
          }
          if (this.mainMenuButton) {
            this.mainMenuButton.interactable = true;
          }
        }

        /**
         * Handle retry button click
         */;
        _proto.onRetryButtonClicked = function onRetryButtonClicked() {
          // Play click sound
          AuditionAudioManager.instance.playSound(this.buttonClickSound);
        }

        /**
         * Handle next button click
         */;
        _proto.onNextButtonClicked = function onNextButtonClicked() {
          // Play click sound
          AuditionAudioManager.instance.playSound(this.buttonClickSound);
        }

        /**
         * Handle main menu button click
         */;
        _proto.onMainMenuButtonClicked = function onMainMenuButtonClicked() {
          // Play click sound
          AuditionAudioManager.instance.playSound(this.buttonClickSound);
        };
        _proto.onDestroy = function onDestroy() {
          // Stop any playing music
          var audioManager = AuditionAudioManager.instance;
          if (audioManager) {
            audioManager.stopSong();
          }
        };
        return AuditionResultsController;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "retryButton", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "nextButton", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "mainMenuButton", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "resultsContent", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "expGainDisplay", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "expGainLabel", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "backgroundMusicPath", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 'audition/audio/results_music';
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "buttonClickSound", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 'click';
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "resultsSound", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 'results';
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionScoringSystem.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AuditionBeatSystem.ts', './AuditionAudioManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _extends, cclegacy, _decorator, Component, AuditionAccuracyRating, AuditionAudioManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _extends = module.extends;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
    }, function (module) {
      AuditionAccuracyRating = module.AuditionAccuracyRating;
    }, function (module) {
      AuditionAudioManager = module.AuditionAudioManager;
    }],
    execute: function () {
      var _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10;
      cclegacy._RF.push({}, "2ce00HNOcFEMZsuE2WXEEkB", "AuditionScoringSystem", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Interface for storing accuracy statistics
       */

      /**
       * Scoring System for Audition module
       * Manages scores, combos, and statistics
       */
      var AuditionScoringSystem = exports('AuditionScoringSystem', (_dec = ccclass('AuditionScoringSystem'), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionScoringSystem, _Component);
        function AuditionScoringSystem() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Base score values for different accuracy ratings
          _initializerDefineProperty(_this, "perfectScore", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "goodScore", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "missScore", _descriptor3, _assertThisInitialized(_this));
          // Combo settings
          _initializerDefineProperty(_this, "comboMultiplierIncrement", _descriptor4, _assertThisInitialized(_this));
          // Increment for each combo step
          _initializerDefineProperty(_this, "maxComboMultiplier", _descriptor5, _assertThisInitialized(_this));
          // Maximum combo multiplier
          _initializerDefineProperty(_this, "comboBreakPenalty", _descriptor6, _assertThisInitialized(_this));
          // Optional penalty for breaking combo
          // Pattern-based scoring settings
          _initializerDefineProperty(_this, "patternComplexityMultiplier", _descriptor7, _assertThisInitialized(_this));
          // Multiplier per complexity level
          _initializerDefineProperty(_this, "consecutivePatternBonus", _descriptor8, _assertThisInitialized(_this));
          // Base bonus for consecutive successful patterns
          _initializerDefineProperty(_this, "finishMoveMultiplier", _descriptor9, _assertThisInitialized(_this));
          // Score multiplier for finish moves
          _initializerDefineProperty(_this, "patternSkipPenalty", _descriptor10, _assertThisInitialized(_this));
          // Penalty for skipping a pattern
          // Scoring statistics
          _this.patternsCompleted = 0;
          _this.consecutivePatterns = 0;
          _this.finishMovesCompleted = 0;
          _this.patternsSkipped = 0;
          // Score tracking
          _this.totalScore = 0;
          _this.currentCombo = 0;
          _this.maxCombo = 0;
          _this.patternMultiplier = 1.0;
          // Statistics tracking
          _this.accuracyStats = {
            perfect: 0,
            good: 0,
            miss: 0,
            total: 0
          };
          // Callbacks
          _this.onScoreUpdateCallback = null;
          _this.onComboUpdateCallback = null;
          _this.onPatternMultiplierUpdateCallback = null;
          return _this;
        }
        var _proto = AuditionScoringSystem.prototype;
        /**
         * Reset scoring system for new gameplay
         */
        _proto.reset = function reset() {
          this.totalScore = 0;
          this.currentCombo = 0;
          this.maxCombo = 0;
          this.patternMultiplier = 1.0;
          this.patternsCompleted = 0;
          this.consecutivePatterns = 0;
          this.finishMovesCompleted = 0;
          this.patternsSkipped = 0;
          this.accuracyStats = {
            perfect: 0,
            good: 0,
            miss: 0,
            total: 0
          };

          // Trigger callbacks with initial values
          if (this.onScoreUpdateCallback) {
            this.onScoreUpdateCallback(this.totalScore);
          }
          if (this.onComboUpdateCallback) {
            this.onComboUpdateCallback(this.currentCombo);
          }
          if (this.onPatternMultiplierUpdateCallback) {
            this.onPatternMultiplierUpdateCallback(this.patternMultiplier);
          }
          console.log('Scoring system reset');
        }

        /**
         * Process a note hit or miss
         * @param accuracyRating Accuracy rating of the hit
         * @param inputType Type of input used
         */;
        _proto.processNoteResult = function processNoteResult(accuracyRating, inputType) {
          // Update statistics
          this.accuracyStats.total++;
          var baseScore = 0;

          // Update accuracy counters and determine base score
          switch (accuracyRating) {
            case AuditionAccuracyRating.PERFECT:
              this.accuracyStats.perfect++;
              baseScore = this.perfectScore;
              this.updateCombo(true);
              // Play different perfect sound based on combo count (1-5)
              var perfectSound = this.currentCombo === 1 ? 'perfect' : "perfect" + Math.min(this.currentCombo, 5);
              AuditionAudioManager.instance.playSound(perfectSound);
              break;
            case AuditionAccuracyRating.GOOD:
              this.accuracyStats.good++;
              baseScore = this.goodScore;
              this.updateCombo(false);
              AuditionAudioManager.instance.playSound('good');
              break;
            case AuditionAccuracyRating.MISS:
              this.accuracyStats.miss++;
              baseScore = this.missScore;
              this.updateCombo(false);
              AuditionAudioManager.instance.playSound('miss');
              break;
          }

          // Calculate score with combo multiplier
          var comboMultiplier = 1 + Math.min(this.maxComboMultiplier - 1, this.comboMultiplierIncrement * (this.currentCombo - 1));
          var pointsEarned = accuracyRating === AuditionAccuracyRating.MISS ? baseScore : Math.floor(baseScore * comboMultiplier);

          // Update total score
          this.totalScore += pointsEarned;

          // Call score update callback
          if (this.onScoreUpdateCallback) {
            this.onScoreUpdateCallback(this.totalScore);
          }
          console.log("Note result: " + AuditionAccuracyRating[accuracyRating] + ", Score: " + this.totalScore + ", " + ("Combo: " + this.currentCombo + ", Points earned: " + pointsEarned));
        }

        /**
         * Process a complete pattern result
         * @param accuracyRating Accuracy of the sync input
         * @param complexity Pattern complexity (number of inputs)
         * @param isFinishMove Whether this was a finish move
         */;
        _proto.processPatternResult = function processPatternResult(accuracyRating, complexity, isFinishMove) {
          if (accuracyRating === AuditionAccuracyRating.MISS) {
            // Handle pattern miss
            this.patternsSkipped++;
            this.consecutivePatterns = 0;
            this.resetPatternMultiplier();

            // Apply skip penalty
            this.totalScore = Math.max(0, this.totalScore - this.patternSkipPenalty);
            console.log("Pattern missed! Score: " + this.totalScore + ", Skipped: " + this.patternsSkipped);
            return;
          }

          // Calculate base pattern score based on complexity and accuracy
          var baseScore = complexity * 50; // Base 50 points per step in pattern

          // Apply accuracy modifier
          if (accuracyRating === AuditionAccuracyRating.PERFECT) {
            baseScore *= 1.5; // 50% bonus for perfect timing
          }

          // Apply pattern multiplier (consecutive patterns bonus)
          var finalScore = Math.floor(baseScore * this.patternMultiplier);

          // Track statistics
          this.patternsCompleted++;
          this.consecutivePatterns++;
          if (isFinishMove) {
            this.finishMovesCompleted++;
            // Apply finish move multiplier
            var finishMoveBonus = Math.floor(finalScore * (this.finishMoveMultiplier - 1));
            this.totalScore += finalScore + finishMoveBonus;
            console.log("Finish move completed! Base: " + finalScore + ", Bonus: " + finishMoveBonus);
          } else {
            // Standard pattern completion
            this.totalScore += finalScore;

            // Add consecutive pattern bonus if applicable
            if (this.consecutivePatterns > 1) {
              var consecutiveBonus = this.consecutivePatternBonus * (this.consecutivePatterns - 1);
              this.totalScore += consecutiveBonus;
              console.log("Consecutive pattern bonus: +" + consecutiveBonus);
            }
          }

          // Increase pattern multiplier
          this.increasePatternMultiplier();

          // Call score update callback
          if (this.onScoreUpdateCallback) {
            this.onScoreUpdateCallback(this.totalScore);
          }
          console.log("Pattern completed! Complexity: " + complexity + ", Score added: " + finalScore + ", " + ("Total: " + this.totalScore + ", Pattern multiplier: " + this.patternMultiplier.toFixed(1) + "x"));
        }

        /**
         * Update combo counter
         * @param success Whether the note was hit successfully
         */;
        _proto.updateCombo = function updateCombo(success) {
          if (success) {
            // Increment combo
            this.currentCombo++;

            // Update max combo if needed
            if (this.currentCombo > this.maxCombo) {
              this.maxCombo = this.currentCombo;
            }
          } else {
            // Apply combo break penalty if any
            if (this.comboBreakPenalty > 0) {
              this.totalScore = Math.max(0, this.totalScore - this.comboBreakPenalty);
            }

            // Reset combo
            this.currentCombo = 0;
          }

          // Call combo update callback
          if (this.onComboUpdateCallback) {
            this.onComboUpdateCallback(this.currentCombo);
          }
        }

        /**
         * Register callback for score updates
         * @param callback Function to call when score changes
         */;
        _proto.onScoreUpdate = function onScoreUpdate(callback) {
          this.onScoreUpdateCallback = callback;
        }

        /**
         * Register callback for combo updates
         * @param callback Function to call when combo changes
         */;
        _proto.onComboUpdate = function onComboUpdate(callback) {
          this.onComboUpdateCallback = callback;
        }

        /**
         * Register callback for pattern multiplier updates
         * @param callback Function to call when pattern multiplier changes
         */;
        _proto.onPatternMultiplierUpdate = function onPatternMultiplierUpdate(callback) {
          this.onPatternMultiplierUpdateCallback = callback;
        }

        /**
         * Increase the pattern multiplier
         */;
        _proto.increasePatternMultiplier = function increasePatternMultiplier() {
          this.patternMultiplier += 0.1;
          if (this.onPatternMultiplierUpdateCallback) {
            this.onPatternMultiplierUpdateCallback(this.patternMultiplier);
          }
        }

        /**
         * Reset the pattern multiplier
         */;
        _proto.resetPatternMultiplier = function resetPatternMultiplier() {
          this.patternMultiplier = 1.0;
          if (this.onPatternMultiplierUpdateCallback) {
            this.onPatternMultiplierUpdateCallback(this.patternMultiplier);
          }
        }

        /**
         * Handle a pattern break
         */;
        _proto.handlePatternBreak = function handlePatternBreak() {
          this.consecutivePatterns = 0;
          this.resetPatternMultiplier();

          // Reset combo
          this.updateCombo(false);
        }

        /**
         * Get current total score
         * @returns Total score
         */;
        _proto.getScore = function getScore() {
          return this.totalScore;
        }

        /**
         * Get current combo
         * @returns Current combo
         */;
        _proto.getCombo = function getCombo() {
          return this.currentCombo;
        }

        /**
         * Get maximum combo achieved
         * @returns Maximum combo
         */;
        _proto.getMaxCombo = function getMaxCombo() {
          return this.maxCombo;
        }

        /**
         * Get accuracy statistics
         * @returns Accuracy statistics object
         */;
        _proto.getAccuracyStats = function getAccuracyStats() {
          return _extends({}, this.accuracyStats);
        }

        /**
         * Calculate accuracy percentage
         * @returns Accuracy percentage (0-100)
         */;
        _proto.getAccuracyPercentage = function getAccuracyPercentage() {
          if (this.accuracyStats.total === 0) {
            return 0;
          }

          // Calculate weighted accuracy: Perfect = 100%, Good = 50%, Miss = 0%
          var weightedSum = this.accuracyStats.perfect * 1.0 + this.accuracyStats.good * 0.5 + this.accuracyStats.miss * 0.0;
          return weightedSum / this.accuracyStats.total * 100;
        }

        /**
         * Get grade based on accuracy and completion
         * @returns Letter grade (S, A, B, C, D, F)
         */;
        _proto.getGrade = function getGrade() {
          var accuracy = this.getAccuracyPercentage();
          if (accuracy >= 95) return 'S';
          if (accuracy >= 90) return 'A';
          if (accuracy >= 80) return 'B';
          if (accuracy >= 70) return 'C';
          if (accuracy >= 60) return 'D';
          return 'F';
        }

        /**
         * Calculate experience points earned based on performance
         * @returns Experience points
         */;
        _proto.calculateExperiencePoints = function calculateExperiencePoints() {
          var baseXP = Math.floor(this.totalScore / 100);
          var accuracyBonus = Math.floor(this.getAccuracyPercentage() / 10);
          var comboBonus = Math.floor(this.maxCombo / 10);
          var patternBonus = this.patternsCompleted * 2;
          var finishMoveBonus = this.finishMovesCompleted * 10;
          return baseXP + accuracyBonus + comboBonus + patternBonus + finishMoveBonus;
        }

        /**
         * Get pattern completion statistics
         * @returns Object with pattern statistics
         */;
        _proto.getPatternStats = function getPatternStats() {
          return {
            completed: this.patternsCompleted,
            skipped: this.patternsSkipped,
            finishMoves: this.finishMovesCompleted
          };
        };
        return AuditionScoringSystem;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "perfectScore", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 100;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "goodScore", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 50;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "missScore", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "comboMultiplierIncrement", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "maxComboMultiplier", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 3.0;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "comboBreakPenalty", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "patternComplexityMultiplier", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.2;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "consecutivePatternBonus", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 50;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "finishMoveMultiplier", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 2.0;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "patternSkipPenalty", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 100;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionSongItemComponent.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Label, Sprite, Button, Node, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Label = module.Label;
      Sprite = module.Sprite;
      Button = module.Button;
      Node = module.Node;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7;
      cclegacy._RF.push({}, "6a29cIl249M9qUzgX5Tgjl0", "AuditionSongItemComponent", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Interface for song data to be displayed
       */

      /**
       * Component for song item prefabs in the song selection list
       */
      var AuditionSongItemComponent = exports('AuditionSongItemComponent', (_dec = ccclass('AuditionSongItemComponent'), _dec2 = property(Label), _dec3 = property(Label), _dec4 = property(Label), _dec5 = property(Label), _dec6 = property(Sprite), _dec7 = property(Button), _dec8 = property(Node), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionSongItemComponent, _Component);
        function AuditionSongItemComponent() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "titleLabel", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "artistLabel", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "difficultyLabel", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "highScoreLabel", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "lockIcon", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "selectButton", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "selectedIndicator", _descriptor7, _assertThisInitialized(_this));
          // Song data
          _this.songId = '';
          _this.unlocked = false;
          // Callback for selection
          _this.onSelect = null;
          return _this;
        }
        var _proto = AuditionSongItemComponent.prototype;
        /**
         * Setup the song item with data
         * @param data Song item data
         */
        _proto.setup = function setup(data) {
          this.songId = data.id;
          this.unlocked = data.unlocked;

          // Set labels
          if (this.titleLabel) {
            this.titleLabel.string = data.title;
          }
          if (this.artistLabel) {
            this.artistLabel.string = data.artist;
          }
          if (this.difficultyLabel) {
            // Display difficulty as stars
            var difficultyText = '';
            for (var i = 0; i < data.difficulty; i++) {
              difficultyText += '';
            }
            this.difficultyLabel.string = difficultyText;
          }
          if (this.highScoreLabel) {
            this.highScoreLabel.string = data.highScore > 0 ? data.highScore.toString() : '-';
          }

          // Show/hide lock icon
          if (this.lockIcon) {
            this.lockIcon.node.active = !data.unlocked;
          }

          // Set button interactable
          if (this.selectButton) {
            this.selectButton.interactable = data.unlocked;
            this.selectButton.node.on(Button.EventType.CLICK, this.onButtonClicked, this);
          }

          // Hide selected indicator initially
          if (this.selectedIndicator) {
            this.selectedIndicator.active = false;
          }
        }

        /**
         * Handle button click
         */;
        _proto.onButtonClicked = function onButtonClicked() {
          if (!this.unlocked) return;

          // Call selection callback
          if (this.onSelect) {
            this.onSelect(this.songId);
          }

          // Show selected indicator
          if (this.selectedIndicator) {
            this.selectedIndicator.active = true;
          }
        }

        /**
         * Set selected state
         * @param selected Whether this item is selected
         */;
        _proto.setSelected = function setSelected(selected) {
          if (this.selectedIndicator) {
            this.selectedIndicator.active = selected;
          }
        };
        return AuditionSongItemComponent;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "titleLabel", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "artistLabel", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "difficultyLabel", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "highScoreLabel", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "lockIcon", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "selectButton", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "selectedIndicator", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionSongSelectionController.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AuditionAudioManager.ts', './AuditionUIManager.ts', './AuditionGameplayController.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Button, ScrollView, Node, Prefab, Label, instantiate, Layout, Component, AuditionAudioManager, AuditionUIManager, AuditionGameplayController;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Button = module.Button;
      ScrollView = module.ScrollView;
      Node = module.Node;
      Prefab = module.Prefab;
      Label = module.Label;
      instantiate = module.instantiate;
      Layout = module.Layout;
      Component = module.Component;
    }, function (module) {
      AuditionAudioManager = module.AuditionAudioManager;
    }, function (module) {
      AuditionUIManager = module.AuditionUIManager;
    }, function (module) {
      AuditionGameplayController = module.AuditionGameplayController;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13;
      cclegacy._RF.push({}, "1e799boHRpGq74bdTFaeFfD", "AuditionSongSelectionController", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Interface for song data to be displayed
       */

      /**
       * Controller for the Song Selection scene
       * Displays available songs and allows the player to select one to play
       */
      var AuditionSongSelectionController = exports('AuditionSongSelectionController', (_dec = ccclass('AuditionSongSelectionController'), _dec2 = property(Button), _dec3 = property(ScrollView), _dec4 = property(Node), _dec5 = property(Prefab), _dec6 = property(Label), _dec7 = property(Label), _dec8 = property(Label), _dec9 = property(Label), _dec10 = property(Label), _dec11 = property(Button), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionSongSelectionController, _Component);
        function AuditionSongSelectionController() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "backButton", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songListScrollView", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songListContent", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songItemPrefab", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songTitleLabel", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "artistLabel", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "difficultyLabel", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "bpmLabel", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "highScoreLabel", _descriptor9, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "playButton", _descriptor10, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "backgroundMusicPath", _descriptor11, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "previewVolume", _descriptor12, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "buttonSound", _descriptor13, _assertThisInitialized(_this));
          _this.selectedSongId = null;
          _this.previewTimer = null;
          return _this;
        }
        var _proto = AuditionSongSelectionController.prototype;
        _proto.onLoad = function onLoad() {
          // Setup UI
          AuditionUIManager.instance.showSongSelection();

          // Setup button events
          this.setupButtonEvents();

          // Load background music
          this.playBackgroundMusic();
        };
        _proto.start = function start() {
          // Populate song list
          this.populateSongList();

          // Reset selection
          this.clearSongSelection();
        }

        /**
         * Setup button event listeners
         */;
        _proto.setupButtonEvents = function setupButtonEvents() {
          // Back button
          if (this.backButton) {
            this.backButton.node.on(Button.EventType.CLICK, this.onBackButtonClicked, this);
          }

          // Play button
          if (this.playButton) {
            this.playButton.node.on(Button.EventType.CLICK, this.onPlayButtonClicked, this);
            this.playButton.interactable = false; // Disabled until a song is selected
          }
        }

        /**
         * Play background music for the selection screen
         */;
        _proto.playBackgroundMusic = function playBackgroundMusic() {
          var audioManager = AuditionAudioManager.instance;
          if (audioManager) {
            audioManager.loadSong(this.backgroundMusicPath).then(function () {
              audioManager.playSong();
            })["catch"](function (error) {
              console.error('Failed to load selection music:', error);
            });
          }
        }

        /**
         * Populate the song list from available songs
         */;
        _proto.populateSongList = function populateSongList() {
          var _this2 = this;
          // Clear existing content
          if (this.songListContent) {
            this.songListContent.removeAllChildren();
          }

          // Get songs from game manager
          var gameManager = AuditionGameplayController.instance;
          if (!gameManager) return;
          var availableSongs = gameManager.getAvailableSongs();
          var unlockedSongs = gameManager.getUnlockedSongs();

          // Create a song item for each song
          availableSongs.forEach(function (song) {
            if (_this2.songItemPrefab) {
              var _songItem$getChildByN, _songItem$getChildByN2;
              var songItem = instantiate(_this2.songItemPrefab);

              // Set song item data
              var songNameLabel = (_songItem$getChildByN = songItem.getChildByName('SongName')) == null ? void 0 : _songItem$getChildByN.getComponent(Label);
              if (songNameLabel) {
                songNameLabel.string = song.title;
              }

              // Set difficulty stars
              var difficultyNode = songItem.getChildByName('Difficulty');
              if (difficultyNode) {
                var difficultyStars = difficultyNode.children;
                for (var i = 0; i < difficultyStars.length; i++) {
                  difficultyStars[i].active = i < song.difficulty;
                }
              }

              // Set locked status
              var lockedIcon = songItem.getChildByName('LockedIcon');
              if (lockedIcon) {
                lockedIcon.active = !gameManager.isSongUnlocked(song.id);
              }

              // Set high score
              var highScoreLabel = (_songItem$getChildByN2 = songItem.getChildByName('HighScore')) == null ? void 0 : _songItem$getChildByN2.getComponent(Label);
              if (highScoreLabel) {
                var highScore = gameManager.getHighScore(song.id);
                highScoreLabel.string = highScore > 0 ? "High Score: " + highScore : '';
              }

              // Add click event
              var button = songItem.getComponent(Button);
              if (button) {
                var isUnlocked = gameManager.isSongUnlocked(song.id);
                button.interactable = isUnlocked;
                if (isUnlocked) {
                  button.node.on(Button.EventType.CLICK, function () {
                    _this2.onSongSelected(song.id);
                  });
                }
              }

              // Add to list
              _this2.songListContent.addChild(songItem);
            }
          });

          // Update layout
          var layout = this.songListContent.getComponent(Layout);
          if (layout) {
            layout.updateLayout();
          }
        }

        /**
         * Handle song selection
         * @param songId The selected song ID
         */;
        _proto.onSongSelected = function onSongSelected(songId) {
          AuditionAudioManager.instance.playSound(this.buttonSound);
          this.selectedSongId = songId;

          // Update UI with song details
          var gameManager = AuditionGameplayController.instance;
          if (!gameManager) return;
          var selectedSong = gameManager.getAvailableSongs().find(function (song) {
            return song.id === songId;
          });
          if (!selectedSong) return;

          // Update song details
          if (this.songTitleLabel) {
            this.songTitleLabel.string = selectedSong.title;
          }
          if (this.artistLabel) {
            this.artistLabel.string = selectedSong.artist;
          }
          if (this.difficultyLabel) {
            this.difficultyLabel.string = "Difficulty: " + selectedSong.difficulty;
          }
          if (this.bpmLabel) {
            this.bpmLabel.string = "BPM: " + selectedSong.bpm;
          }
          if (this.highScoreLabel) {
            var highScore = gameManager.getHighScore(songId);
            this.highScoreLabel.string = highScore > 0 ? "High Score: " + highScore : 'No records yet';
          }

          // Enable play button
          if (this.playButton) {
            this.playButton.interactable = true;
          }

          // Play song preview
          this.playPreview(selectedSong);
        }

        /**
         * Play a preview of the selected song
         * @param song The song data
         */;
        _proto.playPreview = function playPreview(song) {
          var _this3 = this;
          var audioManager = AuditionAudioManager.instance;
          if (!audioManager) return;

          // Stop any current preview
          this.stopPreview();

          // Load and play the song preview
          audioManager.loadSong(song.audioPath).then(function () {
            audioManager.setMusicVolume(_this3.previewVolume);
            // Play from preview start time
            audioManager.playSong(song.previewStart);

            // Set a timer to stop the preview at the end time
            var previewDuration = song.previewEnd - song.previewStart;
            _this3.previewTimer = setTimeout(function () {
              _this3.stopPreview();
              _this3.playBackgroundMusic();
            }, previewDuration);
          })["catch"](function (error) {
            console.error('Failed to play song preview:', error);
          });
        }

        /**
         * Stop the current preview
         */;
        _proto.stopPreview = function stopPreview() {
          // Clear preview timer
          if (this.previewTimer) {
            clearTimeout(this.previewTimer);
            this.previewTimer = null;
          }

          // Stop audio
          var audioManager = AuditionAudioManager.instance;
          if (audioManager) {
            audioManager.stopSong();
          }
        }

        /**
         * Clear song selection
         */;
        _proto.clearSongSelection = function clearSongSelection() {
          this.selectedSongId = null;

          // Reset UI
          if (this.songTitleLabel) {
            this.songTitleLabel.string = 'Select a Song';
          }
          if (this.artistLabel) {
            this.artistLabel.string = '';
          }
          if (this.difficultyLabel) {
            this.difficultyLabel.string = '';
          }
          if (this.bpmLabel) {
            this.bpmLabel.string = '';
          }
          if (this.highScoreLabel) {
            this.highScoreLabel.string = '';
          }

          // Disable play button
          if (this.playButton) {
            this.playButton.interactable = false;
          }
        }

        /**
         * Handle back button click
         */;
        _proto.onBackButtonClicked = function onBackButtonClicked() {
          AuditionAudioManager.instance.playSound(this.buttonSound);
        }

        /**
         * Handle play button click
         */;
        _proto.onPlayButtonClicked = function onPlayButtonClicked() {
          if (!this.selectedSongId) return;
          AuditionAudioManager.instance.playSound(this.buttonSound);
        };
        _proto.onDestroy = function onDestroy() {
          // Stop preview
          this.stopPreview();

          // Stop background music
          var audioManager = AuditionAudioManager.instance;
          if (audioManager) {
            audioManager.stopSong();
          }
        };
        return AuditionSongSelectionController;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "backButton", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "songListScrollView", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "songListContent", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "songItemPrefab", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "songTitleLabel", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "artistLabel", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "difficultyLabel", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "bpmLabel", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "highScoreLabel", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "playButton", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "backgroundMusicPath", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 'audition/audio/selection_music';
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "previewVolume", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.5;
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "buttonSound", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 'click';
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AuditionUIManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AuditionAudioManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createForOfIteratorHelperLoose, _createClass, cclegacy, _decorator, Node, Label, Sprite, Animation, ParticleSystem2D, Color, Component, AuditionAudioManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createForOfIteratorHelperLoose = module.createForOfIteratorHelperLoose;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Label = module.Label;
      Sprite = module.Sprite;
      Animation = module.Animation;
      ParticleSystem2D = module.ParticleSystem2D;
      Color = module.Color;
      Component = module.Component;
    }, function (module) {
      AuditionAudioManager = module.AuditionAudioManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _class3;
      cclegacy._RF.push({}, "04144GbENxMebPIzsW6q1M6", "AuditionUIManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * UI state enum
       */
      var UIState = /*#__PURE__*/function (UIState) {
        UIState[UIState["MAIN_MENU"] = 0] = "MAIN_MENU";
        UIState[UIState["SONG_SELECTION"] = 1] = "SONG_SELECTION";
        UIState[UIState["GAMEPLAY"] = 2] = "GAMEPLAY";
        UIState[UIState["RESULTS"] = 3] = "RESULTS";
        UIState[UIState["SETTINGS"] = 4] = "SETTINGS";
        return UIState;
      }(UIState || {});
      /**
       * Feedback type enum for visual feedback
       */
      var FeedbackType = exports('FeedbackType', /*#__PURE__*/function (FeedbackType) {
        FeedbackType[FeedbackType["PERFECT"] = 0] = "PERFECT";
        FeedbackType[FeedbackType["GREAT"] = 1] = "GREAT";
        FeedbackType[FeedbackType["COOL"] = 2] = "COOL";
        FeedbackType[FeedbackType["MISS"] = 3] = "MISS";
        return FeedbackType;
      }({}));

      /**
       * UI Manager for Audition module
       * Manages UI screens, transitions, and common functionality
       */
      var AuditionUIManager = exports('AuditionUIManager', (_dec = ccclass('AuditionUIManager'), _dec2 = property({
        type: Node,
        group: {
          name: "UI Screens",
          id: "screens"
        }
      }), _dec3 = property({
        type: Node,
        group: {
          name: "UI Screens",
          id: "screens"
        }
      }), _dec4 = property({
        type: Node,
        group: {
          name: "UI Screens",
          id: "screens"
        }
      }), _dec5 = property({
        type: Node,
        group: {
          name: "UI Screens",
          id: "screens"
        }
      }), _dec6 = property({
        type: Node,
        group: {
          name: "UI Screens",
          id: "screens"
        }
      }), _dec7 = property({
        type: Label,
        group: {
          name: "Gameplay UI",
          id: "gameplay"
        }
      }), _dec8 = property({
        type: Label,
        group: {
          name: "Gameplay UI",
          id: "gameplay"
        }
      }), _dec9 = property({
        type: Sprite,
        group: {
          name: "Gameplay UI",
          id: "gameplay"
        }
      }), _dec10 = property({
        type: Animation,
        group: {
          name: "Gameplay UI",
          id: "gameplay"
        }
      }), _dec11 = property({
        type: Label,
        group: {
          name: "Results UI",
          id: "results"
        }
      }), _dec12 = property({
        type: Label,
        group: {
          name: "Results UI",
          id: "results"
        }
      }), _dec13 = property({
        type: Label,
        group: {
          name: "Results UI",
          id: "results"
        }
      }), _dec14 = property({
        type: Label,
        group: {
          name: "Results UI",
          id: "results"
        }
      }), _dec15 = property({
        type: Label,
        group: {
          name: "Song Info",
          id: "songInfo"
        }
      }), _dec16 = property({
        type: Label,
        group: {
          name: "Song Info",
          id: "songInfo"
        }
      }), _dec17 = property({
        type: Label,
        group: {
          name: "Song Info",
          id: "songInfo"
        }
      }), _dec18 = property({
        type: [Node],
        tooltip: "Feedback animation nodes in order: perfect, good, cool, miss"
      }), _dec19 = property(ParticleSystem2D), _dec20 = property({
        type: Animation,
        group: {
          name: "Feedback",
          id: "feedback"
        }
      }), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(AuditionUIManager, _Component);
        function AuditionUIManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          //#endregion
          //#region UI Screen Properties
          _initializerDefineProperty(_this, "mainMenuScreen", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songSelectionScreen", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "gameplayScreen", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "resultsScreen", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "settingsScreen", _descriptor5, _assertThisInitialized(_this));
          //#endregion
          //#region Gameplay UI Properties
          _initializerDefineProperty(_this, "scoreLabel", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "comboCountLabel", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "progressBar", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "readyGoAnimation", _descriptor9, _assertThisInitialized(_this));
          //#endregion
          //#region Results UI Properties
          _initializerDefineProperty(_this, "finalScoreLabel", _descriptor10, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "accuracyLabel", _descriptor11, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "maxComboLabel", _descriptor12, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "gradeLabel", _descriptor13, _assertThisInitialized(_this));
          //#endregion
          //#region Song Info Properties
          _initializerDefineProperty(_this, "songNameLabel", _descriptor14, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "artistNameLabel", _descriptor15, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "bpmLabel", _descriptor16, _assertThisInitialized(_this));
          //#endregion
          //#region Feedback Properties
          _initializerDefineProperty(_this, "feedbackNodes", _descriptor17, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "particleSystemPerfectFragments", _descriptor18, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "animScoreFeedBacks", _descriptor19, _assertThisInitialized(_this));
          //#endregion
          //#region State Management
          _this.currentUIState = UIState.MAIN_MENU;
          _this.feedbackTween = null;
          _this.comboTween = null;
          _this.feedbackAnimNames = ["perfect", "great", "cool", "miss"];
          return _this;
        }
        var _proto = AuditionUIManager.prototype;
        //#endregion
        //#region Lifecycle Methods
        _proto.onLoad = function onLoad() {
          if (AuditionUIManager._instance === null) {
            AuditionUIManager._instance = this;
          } else {
            this.node.destroy();
          }
        }

        //#endregion

        //#region Screen Management
        ;

        _proto.showMainMenu = function showMainMenu() {
          this.hideAllScreens();
          if (this.mainMenuScreen) {
            this.mainMenuScreen.active = true;
            this.currentUIState = UIState.MAIN_MENU;
          }
          console.log('Showing main menu');
        };
        _proto.showSongSelection = function showSongSelection() {
          this.hideAllScreens();
          if (this.songSelectionScreen) {
            this.songSelectionScreen.active = true;
            this.currentUIState = UIState.SONG_SELECTION;
          }
          console.log('Showing song selection');
        };
        _proto.showGameplay = function showGameplay(songData) {
          this.hideAllScreens();
          if (this.gameplayScreen) {
            this.gameplayScreen.active = true;
            this.currentUIState = UIState.GAMEPLAY;
          }
          console.log('Showing gameplay');
          if (this.songNameLabel) {
            this.songNameLabel.string = songData.title;
          }
          if (this.artistNameLabel) {
            this.artistNameLabel.string = songData.artist;
          }
          if (this.bpmLabel) {
            this.bpmLabel.string = songData.bpm.toString() + " BPM";
          }
        };
        _proto.showResults = function showResults() {
          this.hideAllScreens();
          if (this.resultsScreen) {
            this.resultsScreen.active = true;
            this.currentUIState = UIState.RESULTS;
          }
          console.log('Showing results');
        };
        _proto.showSettings = function showSettings() {
          this.hideAllScreens();
          if (this.settingsScreen) {
            this.settingsScreen.active = true;
            this.currentUIState = UIState.SETTINGS;
          }
          console.log('Showing settings');
        };
        _proto.hideAllScreens = function hideAllScreens() {
          if (this.mainMenuScreen) this.mainMenuScreen.active = false;
          if (this.songSelectionScreen) this.songSelectionScreen.active = false;
          if (this.gameplayScreen) this.gameplayScreen.active = false;
          if (this.resultsScreen) this.resultsScreen.active = false;
          if (this.settingsScreen) this.settingsScreen.active = false;
        }
        //#endregion

        //#region Gameplay UI Updates
        ;

        _proto.updateScore = function updateScore(score) {
          if (this.scoreLabel) {
            this.scoreLabel.string = this.formatNumberWithZeros(score, 8);
          }
        };
        _proto.updateCombo = function updateCombo(combo) {
          if (this.comboCountLabel) {
            this.comboCountLabel.string = "x" + combo.toString();
            this.comboCountLabel.node.active = combo > 1;
          }
        };
        _proto.updateProgress = function updateProgress(progress) {
          if (this.progressBar) {
            this.progressBar.fillRange = Math.max(0, Math.min(1, progress));
          }
        };
        _proto.playReadyGoAnimation = function playReadyGoAnimation() {
          this.readyGoAnimation.node.active = true;
          this.readyGoAnimation.play();
          AuditionAudioManager.instance.playSound("s_ready");
          this.scheduleOnce(function () {
            AuditionAudioManager.instance.playSound("s_go");
          }, 1.0);
        }
        //#endregion

        //#region Results UI Updates
        ;

        _proto.updateResults = function updateResults(score, accuracy, maxCombo, grade) {
          if (this.finalScoreLabel) {
            this.finalScoreLabel.string = this.formatNumberWithZeros(score, 8);
          }
          if (this.accuracyLabel) {
            this.accuracyLabel.string = accuracy.toFixed(2) + "%";
          }
          if (this.maxComboLabel) {
            this.maxComboLabel.string = "" + maxCombo;
          }
          if (this.gradeLabel) {
            this.gradeLabel.string = grade;
            this.setGradeColor(grade);
          }
        };
        _proto.setGradeColor = function setGradeColor(grade) {
          switch (grade) {
            case 'S':
              this.gradeLabel.color = new Color(255, 215, 0, 255); // Gold
              break;
            case 'A':
              this.gradeLabel.color = new Color(0, 191, 255, 255); // Blue
              break;
            case 'B':
              this.gradeLabel.color = new Color(50, 205, 50, 255); // Green
              break;
            case 'C':
              this.gradeLabel.color = new Color(255, 165, 0, 255); // Orange
              break;
            case 'D':
              this.gradeLabel.color = new Color(255, 69, 0, 255); // Red
              break;
            case 'F':
              this.gradeLabel.color = new Color(128, 128, 128, 255); // Gray
              break;
          }
        }
        //#endregion

        //#region Utility Methods
        ;

        _proto.formatNumberWithZeros = function formatNumberWithZeros(num, length) {
          var result = num.toString();
          while (result.length < length) {
            result = '0' + result;
          }
          return result;
        };
        _proto.getCurrentUIState = function getCurrentUIState() {
          return this.currentUIState;
        }
        //#endregion

        //#region Feedback System
        ;

        _proto.showFeedback = function showFeedback(type) {
          for (var _iterator = _createForOfIteratorHelperLoose(this.feedbackNodes), _step; !(_step = _iterator()).done;) {
            var node = _step.value;
            node.active = false;
          }
          if (this.feedbackNodes[type]) {
            this.feedbackNodes[type].active = true;
          }
          var animName = this.feedbackAnimNames[type];
          this.animScoreFeedBacks.play(animName);
        }
        //#endregion
        ;

        _createClass(AuditionUIManager, [{
          key: "perfectAnimNode",
          get: function get() {
            return this.feedbackNodes[0];
          }
        }, {
          key: "goodNode",
          get: function get() {
            return this.feedbackNodes[1];
          }
        }, {
          key: "coolNode",
          get: function get() {
            return this.feedbackNodes[2];
          }
        }, {
          key: "missNode",
          get: function get() {
            return this.feedbackNodes[3];
          }
        }], [{
          key: "instance",
          get: function get() {
            return this._instance;
          }
        }]);
        return AuditionUIManager;
      }(Component), _class3._instance = null, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "mainMenuScreen", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "songSelectionScreen", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "gameplayScreen", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "resultsScreen", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "settingsScreen", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "scoreLabel", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "comboCountLabel", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "progressBar", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "readyGoAnimation", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "finalScoreLabel", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "accuracyLabel", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "maxComboLabel", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "gradeLabel", [_dec14], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, "songNameLabel", [_dec15], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor15 = _applyDecoratedDescriptor(_class2.prototype, "artistNameLabel", [_dec16], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor16 = _applyDecoratedDescriptor(_class2.prototype, "bpmLabel", [_dec17], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor17 = _applyDecoratedDescriptor(_class2.prototype, "feedbackNodes", [_dec18], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor18 = _applyDecoratedDescriptor(_class2.prototype, "particleSystemPerfectFragments", [_dec19], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor19 = _applyDecoratedDescriptor(_class2.prototype, "animScoreFeedBacks", [_dec20], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/base.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './type.ts', './slot.ts'], function (exports) {
  var _createClass, cclegacy, ValueType, ConcretePrecisionType, TextureConcretePrecision, ShaderSlot;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      ValueType = module.ValueType;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
      TextureConcretePrecision = module.TextureConcretePrecision;
    }, function (module) {
      ShaderSlot = module.ShaderSlot;
    }],
    execute: function () {
      cclegacy._RF.push({}, "d0751arZzVMdrvnQr4rAMJC", "base", undefined);
      var ShaderNodeProp = exports('ShaderNodeProp', function ShaderNodeProp(defValue, data) {
        this.value = void 0;
        this.data = void 0;
        if (defValue instanceof ValueType) {
          this.value = defValue.clone();
        } else {
          this.value = defValue;
        }
        this.data = data;
      });
      var ShaderNode = exports('ShaderNode', /*#__PURE__*/function () {
        function ShaderNode() {
          this.priority = 0;
          this.uuid = '';
          this.slots = [];
          this.depChunks = [];
          this.defines = [];
          this.isMasterNode = false;
          this.isPropertyNode = false;
          this.concretePrecisionType = ConcretePrecisionType.Min;
          this.fixedConcretePrecision = 0;
          // subgraphNode: SubGraphNode | null = null;
          this.inputs = [];
          this.outputs = [];
          this.props = new Map();
          this.data = {};
        }
        var _proto = ShaderNode.prototype;
        _proto.init = function init() {
          var _this = this;
          this.slots.length = 0;
          this.inputs.length = 0;
          this.outputs.length = 0;
          if (this.data.inputs) {
            this.data.inputs.forEach(function (s) {
              var slot = new ShaderSlot(s, _this);
              _this.inputs.push(slot);
              _this.slots.push(slot);
            });
          }
          if (this.data.outputs) {
            this.data.outputs.forEach(function (s) {
              var slot = new ShaderSlot(s, _this);
              _this.outputs.push(slot);
              _this.slots.push(slot);
            });
          }
          if (this.data.props) {
            this.data.props.forEach(function (prop) {
              var p = new ShaderNodeProp(prop["default"], prop);
              _this.props.set(prop.display, p);
            });
          }
        };
        _proto.beforeGenreateCode = function beforeGenreateCode() {};
        _proto.addDependency = function addDependency(dep) {
          if (dep === this) {
            return;
          }
          if (!this.deps.includes(dep)) {
            this.deps.push(dep);
          }
        };
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          var _this2 = this;
          if (this.fixedConcretePrecision > 0) {
            this.slots.forEach(function (slot) {
              slot._concretePrecision = _this2.fixedConcretePrecision;
            });
          }
          if (this.concretePrecisionType !== ConcretePrecisionType.Fixed) {
            var finalPrecision = 1;
            if (this.concretePrecisionType === ConcretePrecisionType.Min) {
              finalPrecision = 999;
              this.inputs.forEach(function (slot) {
                var concretePrecision = slot.concretePrecision;
                if (slot.connectSlot) {
                  concretePrecision = slot.connectSlot.concretePrecision;
                }
                finalPrecision = Math.min(finalPrecision, concretePrecision);
              });
            } else if (this.concretePrecisionType === ConcretePrecisionType.Max) {
              finalPrecision = -999;
              this.inputs.forEach(function (slot) {
                var concretePrecision = slot.concretePrecision;
                if (slot.connectSlot) {
                  concretePrecision = slot.connectSlot.concretePrecision;
                }
                finalPrecision = Math.max(finalPrecision, concretePrecision);
              });
            } else if (this.concretePrecisionType === ConcretePrecisionType.Texture) {
              finalPrecision = TextureConcretePrecision.Texture2D;
            } else {
              console.error('Not supported ConcretePrecisionType : ' + this.concretePrecisionType);
            }
            this.slots.forEach(function (slot) {
              slot._concretePrecision = finalPrecision;
            });
          }
        };
        _proto.setPriority = function setPriority(priority) {
          this.priority = Math.max(priority, this.priority);
          for (var i = 0; i < this.deps.length; i++) {
            this.deps[i].setPriority(this.priority + 1);
          }
        };
        _proto.getPropWithName = function getPropWithName(name) {
          var p;
          if (this.props) {
            p = this.props.get(name);
          }
          return p || new ShaderNodeProp(null, null);
        };
        _proto.getSlotWithSlotName = function getSlotWithSlotName(name) {
          return this.slots.find(function (s) {
            return s.displayName === name;
          });
        };
        _proto.getOutputSlotWithSlotName = function getOutputSlotWithSlotName(name) {
          return this.outputs.find(function (s) {
            return s.displayName === name;
          });
        };
        _proto.getOutputVarName = function getOutputVarName(idx) {
          return this.outputs[idx].varName;
        };
        _proto.getOutputVarDefine = function getOutputVarDefine(idx) {
          return this.outputs[idx].varDefine;
        };
        _proto.getInputValue = function getInputValue(idx) {
          return this.inputs[idx].slotValue;
        };
        _proto.generateCode = function generateCode() {
          return '';
        };
        _createClass(ShaderNode, [{
          key: "type",
          get: function get() {
            return this.constructor.name;
          }
        }, {
          key: "deps",
          get: function get() {
            var deps = [];
            this.inputs.forEach(function (i) {
              if (i.connectSlot) {
                deps.push(i.connectSlot.node);
              }
            });
            return deps;
          }
        }]);
        return ShaderNode;
      }());

      // export class ShaderEdgeSlot {
      //     id = 0;
      //     nodeUuid = '';

      //     set (data: any) {
      //         this.id = data.m_SlotId;
      //         this.nodeUuid = data.m_NodeGUIDSerialized;
      //     }
      // }

      // export class ShaderEdge {
      //     type = {};
      //     data: any = {}

      //     input: ShaderEdgeSlot = new ShaderEdgeSlot;
      //     output: ShaderEdgeSlot = new ShaderEdgeSlot;

      //     constructor (data: any) {
      //         this.type = data.typeInfo;
      //         this.data = getJsonObject(data.JSONnodeData);

      //         this.input.set(this.data.m_InputSlot);
      //         this.output.set(this.data.m_OutputSlot);
      //     }
      // }
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/BeatmapManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AudioManager2.ts', './resourceUtil.ts', './MTDefines.ts'], function (exports) {
  var _createClass, _asyncToGenerator, _regeneratorRuntime, cclegacy, _decorator, JsonAsset, MagicTilesAudioManager, resourceUtil, NoteType;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
      _asyncToGenerator = module.asyncToGenerator;
      _regeneratorRuntime = module.regeneratorRuntime;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      JsonAsset = module.JsonAsset;
    }, function (module) {
      MagicTilesAudioManager = module.MagicTilesAudioManager;
    }, function (module) {
      resourceUtil = module.resourceUtil;
    }, function (module) {
      NoteType = module.NoteType;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "f0997PWuMBCn4LtP5qegoPj", "BeatmapManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * BeatmapManager for Magic Tiles 3
       * Handles beatmap loading, parsing, and providing data to other modules
       */
      var BeatmapManager = exports('BeatmapManager', (_dec = ccclass("BeatmapManager"), _dec(_class = (_class2 = /*#__PURE__*/function () {
        function BeatmapManager() {
          // Reference to the audio manager
          this.audioManager = MagicTilesAudioManager.instance;
          // Store loaded beatmaps in memory 
          this.beatmaps = new Map();
          // Currently active beatmap
          this.activeBeatmap = null;
          // Path to the beatmap directory
          this.beatmapDirectory = "magic_tiles/beatmaps";
          // Maximum number of lanes (columns) for the game
          this.maxLanes = 4;
          this.init();
        }
        var _proto = BeatmapManager.prototype;
        _proto.init = function init() {
          // Initialize the beatmap manager
          console.log("BeatmapManager initialized");
        }

        /**
         * Load a list of available beatmaps from the beatmap index file
         * @returns Promise that resolves with an array of beatmap metadata
         */;
        _proto.loadBeatmapIndex = /*#__PURE__*/
        function () {
          var _loadBeatmapIndex = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            var indexData;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _context.next = 3;
                  return this.loadJsonAsset(this.beatmapDirectory + "/index");
                case 3:
                  indexData = _context.sent;
                  if (!(!indexData || !Array.isArray(indexData))) {
                    _context.next = 6;
                    break;
                  }
                  throw new Error("Invalid beatmap index data");
                case 6:
                  return _context.abrupt("return", indexData);
                case 9:
                  _context.prev = 9;
                  _context.t0 = _context["catch"](0);
                  console.error("Failed to load beatmap index:", _context.t0);
                  return _context.abrupt("return", []);
                case 13:
                case "end":
                  return _context.stop();
              }
            }, _callee, this, [[0, 9]]);
          }));
          function loadBeatmapIndex() {
            return _loadBeatmapIndex.apply(this, arguments);
          }
          return loadBeatmapIndex;
        }()
        /**
         * Load a specific beatmap by ID
         * @param beatmapId The ID of the beatmap to load
         * @returns Promise that resolves with the loaded beatmap or null if loading failed
         */;

        _proto.loadBeatmapInfo = /*#__PURE__*/
        function () {
          var _loadBeatmapInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(beatmapId) {
            var beatmapData, beatmap;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  if (!this.beatmaps.has(beatmapId)) {
                    _context2.next = 3;
                    break;
                  }
                  this.activeBeatmap = this.beatmaps.get(beatmapId);
                  return _context2.abrupt("return", this.activeBeatmap);
                case 3:
                  _context2.prev = 3;
                  _context2.next = 6;
                  return this.loadJsonAsset(this.beatmapDirectory + "/" + beatmapId);
                case 6:
                  beatmapData = _context2.sent;
                  if (beatmapData) {
                    _context2.next = 9;
                    break;
                  }
                  throw new Error("Failed to load beatmap data for ID: " + beatmapId);
                case 9:
                  // Validate the beatmap data
                  beatmap = this.validateBeatmap(beatmapData); // Store the validated beatmap
                  this.beatmaps.set(beatmapId, beatmap);

                  // Set as active beatmap
                  this.activeBeatmap = beatmap;
                  return _context2.abrupt("return", beatmap);
                case 15:
                  _context2.prev = 15;
                  _context2.t0 = _context2["catch"](3);
                  console.error("Failed to load beatmap " + beatmapId + ":", _context2.t0);
                  return _context2.abrupt("return", null);
                case 19:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this, [[3, 15]]);
          }));
          function loadBeatmapInfo(_x) {
            return _loadBeatmapInfo.apply(this, arguments);
          }
          return loadBeatmapInfo;
        }()
        /**
         * Validate and parse the raw beatmap data
         * @param data The raw beatmap data to validate
         * @returns The validated and processed beatmap
         */;

        _proto.validateBeatmap = function validateBeatmap(data) {
          // Check if the data has the required properties
          if (!data.metadata) {
            throw new Error("Invalid beatmap format: missing metadata or notes");
          }

          // Check metadata fields
          var requiredMetadataFields = ["id", "title", "artist", "bpm", "difficulty", "difficultyName", "audioPath", "midiPath"];
          for (var _i = 0, _requiredMetadataFiel = requiredMetadataFields; _i < _requiredMetadataFiel.length; _i++) {
            var field = _requiredMetadataFiel[_i];
            if (!data.metadata[field]) {
              throw new Error("Invalid beatmap metadata: missing " + field);
            }
          }

          // Create a properly formatted beatmap object
          var beatmap = {
            metadata: {
              id: data.metadata.id,
              title: data.metadata.title,
              artist: data.metadata.artist,
              bpm: data.metadata.bpm,
              difficulty: data.metadata.difficulty,
              difficultyName: data.metadata.difficultyName,
              level: data.metadata.level || 1,
              preview: {
                start: data.metadata.previewStart || 0,
                end: data.metadata.previewEnd || 30
              },
              audioPath: data.metadata.audioPath,
              midiPath: data.metadata.midiPath,
              backgroundImage: data.metadata.backgroundImage || "",
              coverImage: data.metadata.coverImage || ""
            },
            notes: []
          };
          return beatmap;
        }

        /**
         * Update the notes data for a beatmap while minimizing object creation
         * @param id The beatmap ID
         * @param notes The raw note data
         * @returns The updated beatmap or null if not found
         */;
        _proto.updateNotes = function updateNotes(id, notes) {
          if (this.beatmaps.has(id)) {
            var beatmap = this.beatmaps.get(id);

            // Convert notes and update the beatmap
            beatmap.notes = this.convertNotes(notes, beatmap.notes);
            this.beatmaps.set(id, beatmap);
            return beatmap;
          }
          return null;
        }

        /**
         * Convert raw note data to optimized game notes while minimizing object creation
         * @param notes The raw note data to convert
         * @param existingNotes Optional array of existing notes to reuse
         * @returns Array of processed and optimized notes
         */;
        _proto.convertNotes = function convertNotes(notes, existingNotes) {
          if (existingNotes === void 0) {
            existingNotes = [];
          }
          var newLength = notes.length;
          var resultNotes;

          // If we already have an array with sufficient capacity, reuse it
          if (existingNotes.length >= newLength) {
            // Reuse existing array and just update values
            for (var i = 0; i < newLength; i++) {
              var node = notes[i];
              existingNotes[i].midi = node.midi;
              existingNotes[i].time = node.time;
              existingNotes[i].lane = this.getLandById(node.midi);
              existingNotes[i].duration = node.duration;
              existingNotes[i].durationTicks = node.durationTicks;
              existingNotes[i].velocity = node.velocity;
              existingNotes[i].type = this.getNoteType(node);
            }
            // If the new array is smaller, truncate the existing one
            if (existingNotes.length > newLength) {
              existingNotes.length = newLength;
            }
            resultNotes = existingNotes;
          } else {
            // Need to create a new array
            resultNotes = new Array(newLength);

            // Use existing objects where possible
            for (var _i2 = 0; _i2 < newLength; _i2++) {
              var _node = notes[_i2];
              if (_i2 < existingNotes.length) {
                // Reuse existing note object
                resultNotes[_i2] = existingNotes[_i2];
                resultNotes[_i2].midi = _node.midi;
                resultNotes[_i2].time = _node.time;
                resultNotes[_i2].lane = this.getLandById(_node.midi);
                resultNotes[_i2].duration = _node.duration;
                resultNotes[_i2].durationTicks = _node.durationTicks;
                resultNotes[_i2].velocity = _node.velocity;
                resultNotes[_i2].type = this.getNoteType(_node);
              } else {
                // Create new note object
                resultNotes[_i2] = {
                  midi: _node.midi,
                  time: _node.time,
                  lane: this.getLandById(_node.midi),
                  duration: _node.duration,
                  durationTicks: _node.durationTicks,
                  velocity: _node.velocity,
                  type: this.getNoteType(_node)
                };
              }
            }
          }

          // Sort in place with a more efficient implementation if needed
          resultNotes.sort(function (a, b) {
            return a.time - b.time;
          });

          // After sorting, calculate durations for non-hold notes based on the next note time
          for (var _i3 = 0; _i3 < resultNotes.length - 1; _i3++) {
            var currentNote = resultNotes[_i3];
            var nextNote = resultNotes[_i3 + 1];

            // Check if the next note has the same time as current note
            // If so, look for the note after that (i + 2)
            if (nextNote.time === currentNote.time && _i3 + 2 < resultNotes.length) {
              nextNote = resultNotes[_i3 + 2];
            }

            // Only adjust duration for tap notes (not hold notes)
            if (currentNote.type !== NoteType.HOLD) {
              // Set duration to the time difference between this note and the next
              currentNote.duration = Math.min(nextNote.time - currentNote.time, 0.23);
            }
          }

          // Handle the last note if it's not a hold note
          if (resultNotes.length > 0) {
            var lastNote = resultNotes[resultNotes.length - 1];
            if (lastNote.type !== NoteType.HOLD) {
              // For the last note, we could set a default duration or leave as is
              // Here we set a small default duration if it's not already set
              if (lastNote.duration <= 0) {
                lastNote.duration = 0.2; // Default duration for the last note
              }
            }
          }

          return resultNotes;
        };
        _proto.getLandById = function getLandById(nodeId) {
          return nodeId - 96;
        };
        _proto.getNoteType = function getNoteType(node) {
          if (node.duration > 0.3) {
            return NoteType.HOLD;
          }
          return NoteType.TAP;
        }

        /**
         * Load a JSON asset from the resources directory
         * @param path Path to the JSON asset (without extension)
         * @returns Promise that resolves with the parsed JSON data
         */;
        _proto.loadJsonAsset = function loadJsonAsset(path) {
          return new Promise(function (resolve, reject) {
            resourceUtil.loadRes(path, JsonAsset, function (err, jsonAsset) {
              if (err) {
                reject(err);
                return;
              }
              if (!jsonAsset) {
                reject(new Error("JSON asset not found at path: " + path));
                return;
              }
              resolve(jsonAsset.json);
            });
          });
        }

        /**
         * Load the audio and MIDI files for the active beatmap
         * @returns Promise that resolves when loading is complete
         */;
        _proto.loadBeatmapAudioData = /*#__PURE__*/
        function () {
          var _loadBeatmapAudioData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
            var _this$activeBeatmap$m, audioPath, midiPath;
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  if (this.activeBeatmap) {
                    _context3.next = 3;
                    break;
                  }
                  console.error("No active beatmap to load audio for");
                  return _context3.abrupt("return", null);
                case 3:
                  _context3.prev = 3;
                  // Load the audio and MIDI using the audio manager
                  _this$activeBeatmap$m = this.activeBeatmap.metadata, audioPath = _this$activeBeatmap$m.audioPath, midiPath = _this$activeBeatmap$m.midiPath;
                  _context3.next = 7;
                  return this.audioManager.loadBeatmapAudioData(audioPath, midiPath);
                case 7:
                  return _context3.abrupt("return", _context3.sent);
                case 10:
                  _context3.prev = 10;
                  _context3.t0 = _context3["catch"](3);
                  console.error("Failed to load beatmap audio:", _context3.t0);
                  return _context3.abrupt("return", null);
                case 14:
                case "end":
                  return _context3.stop();
              }
            }, _callee3, this, [[3, 10]]);
          }));
          function loadBeatmapAudioData() {
            return _loadBeatmapAudioData.apply(this, arguments);
          }
          return loadBeatmapAudioData;
        }()
        /**
         * Get the active beatmap
         * @returns The currently active beatmap or null if none is loaded
         */;

        _proto.getActiveBeatmap = function getActiveBeatmap() {
          return this.activeBeatmap;
        }

        /**
         * Get the notes for the active beatmap
         * @returns Array of notes from the active beatmap or empty array if none is loaded
         */;
        _proto.getNotes = function getNotes() {
          return this.activeBeatmap ? this.activeBeatmap.notes : [];
        }

        /**
         * Calculate the difficulty rating based on note density and patterns
         * @param beatmap The beatmap to calculate difficulty for
         * @returns A difficulty rating between 1-10
         */;
        _proto.calculateDifficulty = function calculateDifficulty(beatmap) {
          var notes = beatmap.notes;
          if (!notes.length) return 1;

          // Factor 1: Note density (notes per second)
          var totalDuration = notes[notes.length - 1].time - notes[0].time;
          var notesPerSecond = notes.length / (totalDuration || 1);

          // Factor 2: Percentage of complex notes (hold and slide)
          var complexNotes = notes.filter(function (note) {
            return note.type !== NoteType.TAP;
          }).length;
          var complexNotePercentage = complexNotes / notes.length;

          // Factor 3: Lane changes - quick transitions between lanes are harder
          var laneChanges = 0;
          for (var i = 1; i < notes.length; i++) {
            if (notes[i].lane !== notes[i - 1].lane) {
              laneChanges++;
            }
          }
          var laneChangeRate = laneChanges / (notes.length - 1);

          // Factor 4: Time between notes - quick successive notes are harder
          var shortIntervals = 0;
          for (var _i4 = 1; _i4 < notes.length; _i4++) {
            var interval = notes[_i4].time - notes[_i4 - 1].time;
            if (interval < 0.3) {
              // Less than 300ms between notes
              shortIntervals++;
            }
          }
          var shortIntervalRate = shortIntervals / (notes.length - 1);

          // Calculate final difficulty score (1-10 scale)
          var difficulty = 1 + notesPerSecond * 0.5 + complexNotePercentage * 2 + laneChangeRate * 2 + shortIntervalRate * 3;

          // Cap at 10
          return Math.min(Math.round(difficulty * 10) / 10, 10);
        }

        /**
         * Get a preview section of the beatmap for the song selection screen
         * @param beatmapId ID of the beatmap to get preview for
         * @returns A subset of notes that fall within the preview time range
         */;
        _proto.getBeatmapPreview = function getBeatmapPreview(beatmapId) {
          var beatmap = this.beatmaps.get(beatmapId);
          if (!beatmap) return [];
          var _beatmap$metadata$pre = beatmap.metadata.preview,
            start = _beatmap$metadata$pre.start,
            end = _beatmap$metadata$pre.end;
          return beatmap.notes.filter(function (note) {
            return note.time >= start && note.time <= end;
          });
        }

        /**
         * Validate a custom beatmap format and convert it if valid
         * @param customData Raw data from a custom beatmap format
         * @returns A valid beatmap object or null if invalid
         */;
        _proto.validateCustomBeatmap = function validateCustomBeatmap(customData) {
          try {
            // Implement custom beatmap validation logic here
            // This would depend on the format of custom beatmaps
            // For now, we'll just use our standard validation
            return this.validateBeatmap(customData);
          } catch (err) {
            console.error("Invalid custom beatmap format:", err);
            return null;
          }
        }

        /**
         * Adds a temporary beatmap for drag and drop functionality
         * @param id The temporary beatmap ID
         * @param beatmap The beatmap data
         * @returns The added beatmap
         */;
        _proto.addTempBeatmap = function addTempBeatmap(id, beatmap) {
          // Add to our collection
          this.beatmaps.set(id, beatmap);

          // Set as active beatmap
          this.activeBeatmap = beatmap;
          return beatmap;
        };
        _createClass(BeatmapManager, null, [{
          key: "instance",
          get:
          // Singleton pattern
          function get() {
            if (!this._instance) {
              this._instance = new BeatmapManager();
            }
            return this._instance;
          }
        }]);
        return BeatmapManager;
      }(), _class2._instance = null, _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/boolean.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "21fbes9bMJN6oBb3TRVMZZ3", "boolean", undefined);
      var Boolean = exports('default', (_dec = register({
        menu: 'Input/Basic/Boolean',
        title: 'Boolean'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Boolean, _ShaderNode);
        function Boolean() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.data = {
            inputs: [slot('In', 0, 'float', 'vector')],
            outputs: [slot('Out', 0, 'float', 'vector')]
          };
          return _this;
        }
        var _proto = Boolean.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = " + input0 + ";\n        ";
        };
        return Boolean;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/branch.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "2f31f/lK6hGfInMVVNdS8Sy", "branch", undefined);
      var Branch = exports('default', (_dec = register({
        menu: 'Logic/Branch',
        title: 'Branch'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Branch, _ShaderNode);
        function Branch() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Max;
          _this.data = {
            inputs: [slot('Predicate', false, 'boolean', 'boolean'), slot('True', Vec4.ZERO, 'vec4', 'vector'), slot('False', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Branch.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var i0 = this.getInputValue(0);
          var i1 = this.getInputValue(1);
          var i2 = this.getInputValue(2);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = (" + i0 + ") ? (" + i1 + ") : (" + i2 + ");\n        ";
        };
        return Branch;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/Bullet.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Constants.ts'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, Vec3, Component, GameConstant;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Vec3 = module.Vec3;
      Component = module.Component;
    }, function (module) {
      GameConstant = module.GameConstant;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "be613BiyadMYYQcjSzr/JtE", "Bullet", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var Bullet = exports('Bullet', (_dec = ccclass('Bullet'), _dec(_class = /*#__PURE__*/function (_Component) {
        _inheritsLoose(Bullet, _Component);
        function Bullet() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          //#region simulate physic 
          _this.gravity = -18;
          _this.elapsedTime = 0;
          _this.initialVelocity = new Vec3(0, 0, 0);
          _this.initialPosition = new Vec3();
          return _this;
        }
        var _proto = Bullet.prototype;
        _proto.shootWithVelocity = function shootWithVelocity(initialVelocity) {
          // Initialize start time and initial position
          this.gravity = -GameConstant.GAME.PHYSIC_GRAVITY;
          this.elapsedTime = 0;
          this.initialVelocity = initialVelocity;
          this.initialPosition.set(this.node.position);
        };
        _proto.stop = function stop() {
          this.initialVelocity = Vec3.ZERO.clone();
        };
        _proto.update = function update(deltaTime) {
          this.elapsedTime += deltaTime;
          // Calculate new position
          var newPos = this.calculatePosition(this.elapsedTime);

          // Update the position of the cannon shell
          this.node.setPosition(newPos);
        };
        _proto.calculatePosition = function calculatePosition(time) {
          var newPos = new Vec3();

          // Calculate the x position
          newPos.x = this.initialPosition.x + this.initialVelocity.x * time;

          // Calculate the y position
          newPos.y = this.initialPosition.y + this.initialVelocity.y * time + 0.5 * this.gravity * time * time;

          // z position (optional, if you want 3D motion)
          newPos.z = this.initialPosition.z + this.initialVelocity.z * time;
          return newPos;
        }

        //#endregion
        ;

        return Bullet;
      }(Component)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ButtonAutoSound.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './audioManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Button, EventHandler, Component, AudioManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Button = module.Button;
      EventHandler = module.EventHandler;
      Component = module.Component;
    }, function (module) {
      AudioManager = module.AudioManager;
    }],
    execute: function () {
      var _dec, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "9bf359IqNNOdo7v0PQCju2a", "ButtonAutoSound", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var ButtonAutoSound = exports('ButtonAutoSound', (_dec = ccclass('ButtonAutoSound'), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(ButtonAutoSound, _Component);
        function ButtonAutoSound() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "audioName", _descriptor, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = ButtonAutoSound.prototype;
        _proto.onLoad = function onLoad() {
          var button = this.getComponent(Button);
          if (!button) return;
          var eventHandler = new EventHandler();
          eventHandler.target = this.node;
          eventHandler.component = "ButtonAutoSound";
          eventHandler.handler = "onButtonClicked";
          button.clickEvents.push(eventHandler);
        };
        _proto.onButtonClicked = function onButtonClicked() {
          var _AudioManager$instanc;
          (_AudioManager$instanc = AudioManager.instance) == null || _AudioManager$instanc.playSound(this.audioName);
        };
        return ButtonAutoSound;
      }(Component), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "audioName", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return "A_Click_Menu";
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ButtonHotKey.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './HotKey.ts'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, Button, Hotkey;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Button = module.Button;
    }, function (module) {
      Hotkey = module.Hotkey;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "099f7MZV3JPrp3nEUGlRKH5", "ButtonHotKey", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var ButtonHotKey = exports('ButtonHotKey', (_dec = ccclass('ButtonHotKey'), _dec(_class = /*#__PURE__*/function (_Hotkey) {
        _inheritsLoose(ButtonHotKey, _Hotkey);
        function ButtonHotKey() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Hotkey.call.apply(_Hotkey, [this].concat(args)) || this;
          _this.button = null;
          return _this;
        }
        var _proto = ButtonHotKey.prototype;
        _proto.onLoad = function onLoad() {
          _Hotkey.prototype.onLoad.call(this);
          this.button = this.getComponent(Button);
        };
        _proto.trigger = function trigger() {
          _Hotkey.prototype.trigger.call(this);
          if (this.button) {
            this.button.clickEvents.forEach(function (event) {
              event.emit(null);
            });
          }
        };
        return ButtonHotKey;
      }(Hotkey)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/CameraController.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './MathUtil.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Node, Vec3, sys, input, Input, Vec2, Component, MathUtil;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Vec3 = module.Vec3;
      sys = module.sys;
      input = module.input;
      Input = module.Input;
      Vec2 = module.Vec2;
      Component = module.Component;
    }, function (module) {
      MathUtil = module.MathUtil;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7;
      cclegacy._RF.push({}, "ee594FJk7xOGo9n2U0Qsd54", "CameraController", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * 
       */
      var CameraController = exports('CameraController', (_dec = ccclass('CameraController'), _dec2 = property({
        type: Node,
        displayName: ''
      }), _dec3 = property({
        type: Node,
        displayName: ''
      }), _dec4 = property({
        displayName: ''
      }), _dec5 = property({
        displayName: ''
      }), _dec6 = property({
        displayName: ''
      }), _dec7 = property({
        displayName: ''
      }), _dec8 = property({
        displayName: ''
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(CameraController, _Component);
        function CameraController() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "cameraNode", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "targetNode", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "minDistance", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "maxDistance", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "smoothTime", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "mouseSensitivity", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "touchSensitivity", _descriptor7, _assertThisInitialized(_this));
          /**
           * 
           */
          _this.currentValue = 0;
          /**
           * 
           */
          _this.targetValue = 0;
          /**
           * 
           */
          _this.currentVelocity = 0;
          /**
           * 
           */
          _this.lastTouchesDistance = null;
          /**
           * 
           */
          _this.tempVec3 = new Vec3();
          return _this;
        }
        var _proto = CameraController.prototype;
        /**
         * 
         */
        _proto.onLoad = function onLoad() {
          this.init();
          this.registerEvent();
        }

        /**
         * 
         */;
        _proto.onDestroy = function onDestroy() {
          this.unregisterEvent();
        }

        /**
         * 
         */;
        _proto.registerEvent = function registerEvent() {
          if (sys.platform === sys.Platform.MOBILE_BROWSER) {
            // 
            input.on(Input.EventType.TOUCH_MOVE, this.onTouchMove, this);
            input.on(Input.EventType.TOUCH_END, this.onTouchEnd, this);
          } else {
            // 
            input.on(Input.EventType.MOUSE_WHEEL, this.onMouseWheel, this);
          }
        }

        /**
         * 
         */;
        _proto.unregisterEvent = function unregisterEvent() {
          if (sys.platform === sys.Platform.MOBILE_BROWSER) {
            // 
            input.off(Input.EventType.TOUCH_MOVE, this.onTouchMove, this);
            input.off(Input.EventType.TOUCH_END, this.onTouchEnd, this);
          } else {
            // 
            input.off(Input.EventType.MOUSE_WHEEL, this.onMouseWheel, this);
          }
        }

        /**
         * 
         */;
        _proto.init = function init() {
          // 
          this.cameraNode.lookAt(this.targetNode.getWorldPosition());
          // 
          var distance;
          if (sys.platform === sys.Platform.MOBILE_BROWSER) {
            distance = 15;
          } else {
            distance = 8;
          }
          this.setTarget(distance);
        }

        /**
         * 
         * @param event 
         */;
        _proto.onMouseWheel = function onMouseWheel(event) {
          var scroll = event.getScrollY() * this.mouseSensitivity;
          this.setTarget(this.targetValue - scroll);
        }

        /**
         * 
         * @param event 
         */;
        _proto.onTouchMove = function onTouchMove(event) {
          var touches = event.getAllTouches();
          if (touches.length < 2) {
            return;
          }
          // 
          var touchesDistance = Vec2.distance(touches[0].getLocation(), touches[1].getLocation());
          if (this.lastTouchesDistance !== null) {
            var diff = (touchesDistance - this.lastTouchesDistance) * this.touchSensitivity;
            this.setTarget(this.targetValue - diff);
          }
          this.lastTouchesDistance = touchesDistance;
        }

        /**
         * 
         * @param event 
         */;
        _proto.onTouchEnd = function onTouchEnd(event) {
          this.lastTouchesDistance = null;
        }

        /**
         * 
         * @param dt 
         */;
        _proto.update = function update(dt) {
          if (this.currentValue === this.targetValue) {
            return;
          }
          // 
          var current = MathUtil.smoothDamp(this.currentValue, this.targetValue, this.currentVelocity, this.smoothTime);
          // 
          this.currentVelocity = current.velocity;
          // 
          this.setCurrent(current.value);
        }

        /**
         * 
         * @param value 
         */;
        _proto.setCurrent = function setCurrent(value) {
          // 
          var direction = Vec3.subtract(this.tempVec3, this.cameraNode.getWorldPosition(), this.targetNode.getWorldPosition());
          direction.normalize().multiplyScalar(value);
          this.cameraNode.setWorldPosition(direction);
          // 
          this.currentValue = value;
        }

        /**
         * 
         * @param value 
         */;
        _proto.setTarget = function setTarget(value) {
          // 
          this.targetValue = MathUtil.clamp(value, this.minDistance, this.maxDistance);
        };
        return CameraController;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "cameraNode", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "targetNode", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "minDistance", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 5;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "maxDistance", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 50;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "smoothTime", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "mouseSensitivity", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.05;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "touchSensitivity", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.05;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/Cannon.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ProjectileMath.ts', './TrajectoryDrawer.ts', './VectorUtil.ts', './Bullet.ts', './audioManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Node, Prefab, Enum, SkeletalAnimation, Vec3, tween, v3, easing, instantiate, director, Component, ProjectileMath, TrajectoryDrawer, VectorUtil, Bullet, AudioManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Prefab = module.Prefab;
      Enum = module.Enum;
      SkeletalAnimation = module.SkeletalAnimation;
      Vec3 = module.Vec3;
      tween = module.tween;
      v3 = module.v3;
      easing = module.easing;
      instantiate = module.instantiate;
      director = module.director;
      Component = module.Component;
    }, function (module) {
      ProjectileMath = module.ProjectileMath;
    }, function (module) {
      TrajectoryDrawer = module.TrajectoryDrawer;
    }, function (module) {
      VectorUtil = module.VectorUtil;
    }, function (module) {
      Bullet = module.Bullet;
    }, function (module) {
      AudioManager = module.AudioManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12;
      cclegacy._RF.push({}, "af3dac0xL5BLrK8YABTwvI2", "Cannon", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var Mode = /*#__PURE__*/function (Mode) {
        Mode[Mode["FIXED_ALL"] = 1] = "FIXED_ALL";
        Mode[Mode["FIXED_PITCH_ANGLE"] = 2] = "FIXED_PITCH_ANGLE";
        Mode[Mode["FIXED_VELOCITY"] = 3] = "FIXED_VELOCITY";
        Mode[Mode["UNFIXED"] = 4] = "UNFIXED";
        return Mode;
      }(Mode || {});
      var Cannon = exports('Cannon', (_dec = ccclass('Cannon'), _dec2 = property({
        type: Node,
        displayName: 'yawAxis',
        group: {
          name: 'Configs',
          id: '1'
        }
      }), _dec3 = property({
        type: Node,
        displayName: 'pitchAxis',
        group: {
          name: 'Configs',
          id: '1'
        }
      }), _dec4 = property({
        type: Node,
        displayName: 'firePoint',
        group: {
          name: 'Configs',
          id: '1'
        }
      }), _dec5 = property({
        type: Prefab,
        displayName: 'bulletPrefab',
        group: {
          name: 'model',
          id: '2'
        }
      }), _dec6 = property({
        type: Node,
        group: {
          name: 'model',
          id: '2'
        }
      }), _dec7 = property({
        type: Enum(Mode),
        displayName: 'mode',
        group: {
          name: 'settings',
          id: '3'
        }
      }), _dec8 = property({
        displayName: 'fixedPitchAngle',
        visible: function visible() {
          return this.mode === Mode.FIXED_PITCH_ANGLE || this.mode === Mode.FIXED_ALL;
        },
        group: {
          name: 'settings',
          id: '3'
        }
      }), _dec9 = property({
        displayName: 'fixedVelocity',
        visible: function visible() {
          return this.mode === Mode.FIXED_VELOCITY || this.mode === Mode.FIXED_ALL;
        },
        group: {
          name: 'settings',
          id: '3'
        }
      }), _dec10 = property({
        displayName: 'useSmallPitchAngle',
        visible: function visible() {
          return this.mode === Mode.FIXED_VELOCITY;
        },
        group: {
          name: 'settings',
          id: '3'
        }
      }), _dec11 = property({
        type: TrajectoryDrawer,
        displayName: 'trajectoryDrawer',
        group: {
          name: 'trajectory',
          id: '4'
        }
      }), _dec12 = property({
        displayName: 'showTrajectory',
        visible: function visible() {
          return this.trajectoryDrawer != null;
        },
        group: {
          name: 'trajectory',
          id: '4'
        }
      }), _dec13 = property({
        type: [SkeletalAnimation],
        group: {
          name: "Animation",
          id: "5"
        }
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(Cannon, _Component);
        function Cannon() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "yawAxis", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "pitchAxis", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "firePoint", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "bulletPrefab", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "bulletContainer", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "mode", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "fixedPitchAngle", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "fixedVelocity", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "useSmallPitchAngle", _descriptor9, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "trajectoryDrawer", _descriptor10, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "_showTrajectory", _descriptor11, _assertThisInitialized(_this));
          _this.velocity = 0;
          _this.curTargetPos = new Vec3(0, 0.753, -7.671);
          //#region animations
          _initializerDefineProperty(_this, "shootAnimations", _descriptor12, _assertThisInitialized(_this));
          _this.shootAnimationState = [];
          return _this;
        }
        var _proto = Cannon.prototype;
        _proto.rotateTo = function rotateTo(pitch, yaw) {
          this.pitch = pitch;
          this.yaw = yaw;
        };
        _proto.aim = function aim(targetPos) {
          this.curTargetPos.set(targetPos);
          var direction = Vec3.subtract(new Vec3(), targetPos, this.mainPosition);
          var yawAngle = -VectorUtil.signedAngle(direction, this.mainForward, this.mainUp);
          var pitchAngle = NaN,
            time = NaN,
            velocity = NaN;
          var fixedTrajectoryDistance = false;
          switch (this.mode) {
            case Mode.FIXED_ALL:
              {
                pitchAngle = this.fixedPitchAngle;
                velocity = this.fixedVelocity;
                fixedTrajectoryDistance = true;
                break;
              }
            case Mode.FIXED_PITCH_ANGLE:
              {
                pitchAngle = this.fixedPitchAngle;
                velocity = this.calculateVelocity(targetPos, -pitchAngle);
                break;
              }
            case Mode.FIXED_VELOCITY:
              {
                velocity = this.fixedVelocity;
                var _this$calculateAngle = this.calculateAngle(targetPos, velocity),
                  angle1 = _this$calculateAngle.angle1,
                  angle2 = _this$calculateAngle.angle2;
                if (!isNaN(angle1) && !isNaN(angle2)) {
                  if (this.useSmallPitchAngle) {
                    pitchAngle = -Math.min(angle1, angle2);
                  } else {
                    pitchAngle = -Math.max(angle1, angle2);
                  }
                } else {
                  fixedTrajectoryDistance = true;
                }
                break;
              }
            case Mode.UNFIXED:
              {
                var result = this.calculateWithMaxHeight(targetPos);
                pitchAngle = -result.angle;
                velocity = result.velocity;
                time = result.time;
                break;
              }
          }
          if (isNaN(pitchAngle)) {
            pitchAngle = this.pitch;
          }
          this.rotateTo(pitchAngle, yawAngle);
          if (!isNaN(velocity)) {
            this.velocity = velocity;
          }
          if (this.trajectoryDrawer) {
            this.drawTrajectory(targetPos, -this.pitch, this.velocity, fixedTrajectoryDistance);
          }
          return {
            time: time,
            velocity: velocity,
            pitchAngle: pitchAngle
          };
        }

        //return time to target
        ;

        _proto.fire = function fire(targetPos) {
          var flyTime = 0.0;
          if (targetPos) {
            var _this$aim = this.aim(targetPos),
              time = _this$aim.time;
            flyTime = time;
          }
          var bullet = this.shoot(this.velocity);

          //do anim here
          tween(this.yawAxis).to(0.1, {
            position: v3(0.0, -0.1, 0.035)
          }).to(0.35, {
            position: v3(0.0, 0.0, 0.0)
          }, {
            easing: easing.quartOut
          }).start();
          return {
            flyTime: flyTime,
            bullet: bullet
          };
        };
        _proto.shoot = function shoot(velocity) {
          var bulletNode = this.generateBullet();
          var direction = bulletNode.forward.negative();
          direction.multiplyScalar(velocity);
          var bullet = bulletNode.getComponent(Bullet);
          bullet.shootWithVelocity(direction);
          return bullet;
        };
        _proto.drawTrajectory = function drawTrajectory(targetPos, angle, velocity, fixedDistance) {
          var firePos = this.firePoint.getWorldPosition();
          if (fixedDistance) {
            var distance = ProjectileMath.calculateDisplacementAtMoment(angle, velocity, 2).x;
            this.trajectoryDrawer.draw(firePos, targetPos, angle, velocity, distance);
          } else {
            this.trajectoryDrawer.draw(firePos, targetPos, angle, velocity);
          }
        };
        _proto.generateBullet = function generateBullet() {
          var node = instantiate(this.bulletPrefab);
          director.getScene().addChild(node);
          node.setWorldPosition(this.firePoint.getWorldPosition());
          node.setWorldRotation(this.firePoint.getWorldRotation());
          return node;
        };
        _proto.calculateDisplacement = function calculateDisplacement(targetPos) {
          var firePos = this.firePoint.getWorldPosition(),
            direction = Vec3.subtract(new Vec3(), targetPos, firePos);
          var vertical = direction.y;
          var horizontal = VectorUtil.projectOnPlane(direction, Vec3.UP).length();
          return {
            horizontal: horizontal,
            vertical: vertical
          };
        };
        _proto.calculateVelocity = function calculateVelocity(targetPos, angle) {
          var _this$calculateDispla = this.calculateDisplacement(targetPos),
            horizontal = _this$calculateDispla.horizontal,
            vertical = _this$calculateDispla.vertical;
          return ProjectileMath.calculateWithAngle(horizontal, vertical, angle);
        };
        _proto.calculateAngle = function calculateAngle(targetPos, velocity) {
          var _this$calculateDispla2 = this.calculateDisplacement(targetPos),
            horizontal = _this$calculateDispla2.horizontal,
            vertical = _this$calculateDispla2.vertical;
          return ProjectileMath.calculateWithVelocity(horizontal, vertical, velocity);
        };
        _proto.calculateWithMaxHeight = function calculateWithMaxHeight(targetPos) {
          var _this$calculateDispla3 = this.calculateDisplacement(targetPos),
            horizontal = _this$calculateDispla3.horizontal,
            vertical = _this$calculateDispla3.vertical;
          var maxHeight = Math.max(0.5, vertical + horizontal * 0.3); // 
          return ProjectileMath.calculateWithMaxHeight(horizontal, vertical, maxHeight);
        };
        _proto.fireWithAnimation = function fireWithAnimation(pos, onContact) {
          var _this2 = this;
          this.shootAnimationState = [];
          this.shootAnimations.forEach(function (anim) {
            var state = anim.getState("Shoot");
            state.speed = 1.0;
            state.time = 0.0;
            state.play();
            _this2.shootAnimationState.push(state);
          });
          this.scheduleOnce(function () {
            var _this2$fire = _this2.fire(pos),
              flyTime = _this2$fire.flyTime,
              bullet = _this2$fire.bullet;
            _this2.scheduleOnce(function () {
              onContact == null || onContact(bullet);
            }, flyTime);
            AudioManager.instance.playSound("sfx_CannonWars_Shoot");
          }, 0.6);
        }

        //#endregion
        ;

        _createClass(Cannon, [{
          key: "showTrajectory",
          get: function get() {
            return this._showTrajectory;
          },
          set: function set(value) {
            this._showTrajectory = value;
            if (this.trajectoryDrawer) {
              if (value) {
                this.curTargetPos && this.aim(this.curTargetPos);
              } else {
                this.trajectoryDrawer.clear();
              }
            }
          }
        }, {
          key: "pitch",
          get: function get() {
            return this.pitchAxis.eulerAngles.x;
          },
          set: function set(value) {
            this.pitchAxis.setRotationFromEuler(value, 0, 0);
          }
        }, {
          key: "yaw",
          get: function get() {
            return this.yawAxis.eulerAngles.y;
          },
          set: function set(value) {
            this.yawAxis.setRotationFromEuler(0, value, 0);
          }
        }, {
          key: "mainPosition",
          get: function get() {
            return this.yawAxis.getWorldPosition();
          }
        }, {
          key: "mainForward",
          get: function get() {
            return this.yawAxis.parent.forward.negative();
          }
        }, {
          key: "mainUp",
          get: function get() {
            return this.yawAxis.up;
          }
        }], [{
          key: "Mode",
          get: function get() {
            return Mode;
          }
        }]);
        return Cannon;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "yawAxis", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "pitchAxis", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "firePoint", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "bulletPrefab", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "bulletContainer", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "mode", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Mode.FIXED_PITCH_ANGLE;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "fixedPitchAngle", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return -45;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "fixedVelocity", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 5;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "useSmallPitchAngle", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "trajectoryDrawer", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "_showTrajectory", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "showTrajectory", [_dec12], Object.getOwnPropertyDescriptor(_class2.prototype, "showTrajectory"), _class2.prototype), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "shootAnimations", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ceil.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "9c519gjpitF6YbEaQTLOEve", "ceil", undefined);
      var Ceil = exports('default', (_dec = register({
        menu: 'Math/Round/Ceil',
        title: 'Ceil'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Ceil, _ShaderNode);
        function Ceil() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Ceil.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = ceil(" + input0 + ");\n        ";
        };
        return Ceil;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/CenterManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Manager.ts', './enum.ts', './ScrollManager.ts', './ViewManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, v3, Manager, AlwaysScroll, ScrollManager, ViewManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      v3 = module.v3;
    }, function (module) {
      Manager = module.Manager;
    }, function (module) {
      AlwaysScroll = module.AlwaysScroll;
    }, function (module) {
      ScrollManager = module.ScrollManager;
    }, function (module) {
      ViewManager = module.ViewManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;
      cclegacy._RF.push({}, "e5ff40NmxhKAaD04pv29iQm", "CenterManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var CenterManager = exports('CenterManager', (_dec = ccclass('CenterManager'), _dec2 = property("boolean"), _dec3 = property({
        visible: function visible() {
          return this.enabled;
        },
        tooltip: ""
      }), _dec4 = property({
        range: [0, 1],
        slide: true,
        step: 0.1,
        tooltip: "(view),,"
      }), _dec5 = property({
        range: [0, 1],
        slide: true,
        step: 0.1,
        tooltip: "(item),,"
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Manager) {
        _inheritsLoose(CenterManager, _Manager);
        function CenterManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Manager.call.apply(_Manager, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "_enabled", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "duration", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "containerAnchorPoint", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "elementAnchorPoint", _descriptor4, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = CenterManager.prototype;
        _proto.getContainerOffset = function getContainerOffset(containerAnchorPoint) {
          if (containerAnchorPoint === void 0) {
            containerAnchorPoint = this.containerAnchorPoint;
          }
          var offset = 0;
          var point = 0;
          if (this.adapter.isHorizontal) {
            point = this.adapter.multiplier == -1 ? containerAnchorPoint : 1 - containerAnchorPoint;
          } else {
            point = this.adapter.multiplier == 1 ? containerAnchorPoint : 1 - containerAnchorPoint;
          }
          offset = this.adapter.mainAxisSize * point;
          return offset;
        };
        _proto.getElementOffset = function getElementOffset(elementAnchorPoint) {
          if (elementAnchorPoint === void 0) {
            elementAnchorPoint = this.elementAnchorPoint;
          }
          var offset = 0;
          if (this.adapter.isHorizontal) {
            offset = this.adapter.multiplier == -1 ? elementAnchorPoint : 1 - elementAnchorPoint;
          } else {
            offset = this.adapter.multiplier == 1 ? elementAnchorPoint : 1 - elementAnchorPoint;
          }
          return offset;
        };
        _proto.onInit = function onInit() {
          this.adapter.scrollManager.on(ScrollManager.Event.ON_ABOUT_TO_STOP, this._onAboutToStop, this);
          this.adapter.viewManager.on(ViewManager.Event.ON_UPDATE_VIEWS, this.scrollToCenter, this, true);
        };
        _proto._onAboutToStop = function _onAboutToStop() {
          this.scrollToCenter();
        }
        /**
         * 
         * @param duration 
         */;
        _proto.scrollToCenter = function scrollToCenter(duration) {
          if (duration === void 0) {
            duration = this.duration;
          }
          if (!this.enabled) return;
          var visibleIndex = this.getCenterVisibleIndex();
          if (-1 == visibleIndex) return;
          var view = this.adapter.viewManager.getVisibleView(visibleIndex);
          this.adapter.scrollManager.scrollToGroupIndex(duration, view.index);
        }
        /**
         * 
         * @param containerAnchorPoint 
         * @param elementAnchorPoint 
         * @returns  groupIndex
         */;
        _proto.getCenterVisibleIndex = function getCenterVisibleIndex(containerAnchorPoint, elementAnchorPoint) {
          if (containerAnchorPoint === void 0) {
            containerAnchorPoint = this.containerAnchorPoint;
          }
          if (elementAnchorPoint === void 0) {
            elementAnchorPoint = this.elementAnchorPoint;
          }
          var mainAxis = this.adapter.mainAxis;
          var center = this.getContainerOffset(containerAnchorPoint);
          var visibleIndex = -1;
          var minDistance = Number.MAX_SAFE_INTEGER;
          for (var i = 0; i < this.adapter.viewManager.visibleLength; i++) {
            var view = this.adapter.viewManager.getVisibleView(i);
            if (!view || !view.group) break;
            var position = {
              x: view.group.position.x,
              y: view.group.position.y
            };
            position[mainAxis] -= this.adapter.multiplier * view.group.size[mainAxis] * elementAnchorPoint;
            var world = this.adapter.scrollManager.content.convertToWorldSpaceAR(v3(position.x, position.y));
            var local = this.adapter.scrollManager.view.convertToNodeSpaceAR(world);
            var distance = Math.abs(local[mainAxis] + this.adapter.multiplier * center);
            if (distance < minDistance) {
              minDistance = distance;
              visibleIndex = i;
            }
          }
          return visibleIndex;
        }
        /**
         * 
         * @param index  optionsIndex
         * @param alwaysScroll AlwaysScroll.Auto
         * @param priorityCheckExists  alwaysScroll != AlwaysScroll.Auto  false
         * @returns 
         */;
        _proto.getPositionByGroupIndex = function getPositionByGroupIndex(index, alwaysScroll, priorityCheckExists) {
          if (alwaysScroll === void 0) {
            alwaysScroll = AlwaysScroll.Auto;
          }
          if (priorityCheckExists === void 0) {
            priorityCheckExists = false;
          }
          var group = this.adapter.viewManager.getGroup(index);
          if (!group) {
            return null;
          }
          var target = null;
          if (alwaysScroll == AlwaysScroll.Header && this.adapter.viewManager.loopHeader) {
            // 
            if (priorityCheckExists) {
              target = this._checkExists(index);
            }
            if (target == null) {
              target = this._alwaysHeader(index, group);
            }
          } else if (alwaysScroll == AlwaysScroll.Footer && this.adapter.viewManager.loopFooter) {
            // 
            if (priorityCheckExists) {
              target = this._checkExists(index);
            }
            if (target == null) {
              target = this._alwaysFooter(index, group);
            }
          } else {
            // 
            target = this._checkExists(index);
            if (target == null) {
              // 
              var header = this.adapter.viewManager.header;
              var footer = this.adapter.viewManager.footer;
              if (header) {
                if (index > footer.index) {
                  // 
                  target = this._calcTargetFooter(footer.group, footer.index + 1, index, group);
                } else if (index < header.index) {
                  // 
                  target = this._calcTargetHeader(header.group, header.index - 1, index, group);
                }
              } else {
                // 
                // var startOptions = this.adapter.viewManager.getViewOptions(0)
                // target = this.calcTargetFooter(startOptions, startOptions.index, index)
                // TODO 
                target = {
                  position: group.position[this.adapter.mainAxis],
                  size: group.size[this.adapter.mainAxis],
                  anchor: group.anchorPoint[this.adapter.mainAxis]
                };
              }
            }
          }
          return this._convertTargetToPosition(target);
        };
        _proto._convertTargetToPosition = function _convertTargetToPosition(target) {
          var position = null;
          if (target) {
            var multiplier = this.adapter.multiplier;
            var anchor = multiplier == -1 ? target.anchor : 1 - target.anchor;
            position = -target.position;
            position -= this.getContainerOffset() * multiplier;
            position -= target.size * anchor * multiplier;
            position += target.size * this.getElementOffset() * multiplier;
          }
          return position;
        };
        _proto._checkExists = function _checkExists(index) {
          var visibleIndex = this.adapter.viewManager.getVisibleIndexByGroupIndex(index);
          if (-1 != visibleIndex) {
            var view = this.adapter.viewManager.getVisibleView(visibleIndex);
            return {
              position: view.group.position[this.adapter.mainAxis],
              size: view.group.size[this.adapter.mainAxis],
              anchor: view.group.anchorPoint[this.adapter.mainAxis]
            };
          }
          return null;
        }
        /**
         * 
         */;
        _proto._calcTargetFooter = function _calcTargetFooter(group, start, end, target) {
          var size = this.adapter.viewManager.internal_getInitFooterSize(group);
          for (var i = start; i <= end; i++) {
            size += this.adapter.viewManager.internal_accumulationSize(i);
          }
          return {
            position: this.adapter.viewManager.internal_convertSizeToFooterPosition(size, target),
            size: target.size[this.adapter.mainAxis],
            anchor: target.anchorPoint[this.adapter.mainAxis]
          };
        }
        /**
         * 
         */;
        _proto._calcTargetHeader = function _calcTargetHeader(group, start, end, target) {
          var size = this.adapter.viewManager.internal_getInitHeaderSize(group);
          for (var i = start; i >= end; i--) {
            size += this.adapter.viewManager.internal_accumulationSize(i);
          }
          return {
            position: this.adapter.viewManager.internal_convertSizeToHeaderPosition(size, target),
            size: target.size[this.adapter.mainAxis],
            anchor: target.anchorPoint[this.adapter.mainAxis]
          };
        }
        /**
         * 
         */;
        _proto._alwaysHeader = function _alwaysHeader(index, target) {
          var size = 0;
          var start = index;
          var header = this.adapter.viewManager.header;
          if (header) {
            size = this.adapter.viewManager.internal_getInitHeaderSize(header.group);
            start = header.index;
          }
          if (index != start) {
            size = this._calcSizeToHeader(start, index, size);
          }
          return {
            position: this.adapter.viewManager.internal_convertSizeToHeaderPosition(size, target),
            size: target.size[this.adapter.mainAxis],
            anchor: target.anchorPoint[this.adapter.mainAxis]
          };
        }
        /**
         * 
         * @returns 
         */;
        _proto._alwaysFooter = function _alwaysFooter(index, target) {
          var size = 0;
          var start = index;
          var footer = this.adapter.viewManager.footer;
          if (footer) {
            size = this.adapter.viewManager.internal_getInitFooterSize(footer.group);
            start = footer.index;
          }
          if (index != start) {
            size = this._calcSizeToFooter(start, index, size);
          }
          return {
            position: this.adapter.viewManager.internal_convertSizeToFooterPosition(size, target),
            size: target.size[this.adapter.mainAxis],
            anchor: target.anchorPoint[this.adapter.mainAxis]
          };
        }
        /**
         * 
         */;
        _proto._calcSizeToHeader = function _calcSizeToHeader(index, targetIndex, size) {
          do {
            index--;
            if (index < 0) {
              if (!this.adapter.viewManager.loopHeader) {
                return size;
              }
              index = this.adapter.viewManager.groupLength - 1;
            }
            size += this.adapter.viewManager.internal_accumulationSize(index);
            if (targetIndex == index) return size;
          } while (true);
        }
        /**
         * 
         */;
        _proto._calcSizeToFooter = function _calcSizeToFooter(index, targetIndex, size) {
          do {
            index++;
            if (index >= this.adapter.viewManager.groupLength) {
              if (!this.adapter.viewManager.loopFooter) {
                return size;
              }
              index = 0;
            }
            size += this.adapter.viewManager.internal_accumulationSize(index);
            if (index == targetIndex) return size;
          } while (true);
        };
        _createClass(CenterManager, [{
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(value) {
            if (value == this._enabled) return;
            this._enabled = value;
          }
        }, {
          key: "max",
          get: function get() {
            var cantainerOffset = this.getContainerOffset(this.containerAnchorPoint);
            if (this.adapter.isArrangeAxisStart) {
              return cantainerOffset;
            }
            return this.adapter.mainAxisSize - cantainerOffset;
          }
        }, {
          key: "min",
          get: function get() {
            var cantainerOffset = this.getContainerOffset(this.containerAnchorPoint);
            if (this.adapter.isArrangeAxisStart) {
              return this.adapter.mainAxisSize - cantainerOffset;
            } else {
              return cantainerOffset;
            }
          }
        }]);
        return CenterManager;
      }(Manager), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "_enabled", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "enabled", [_dec2], Object.getOwnPropertyDescriptor(_class2.prototype, "enabled"), _class2.prototype), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "duration", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "containerAnchorPoint", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "elementAnchorPoint", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/clamp.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "4637audjsFPEKaBJvnUsO5t", "clamp", undefined);
      var Clamp = exports('default', (_dec = register({
        menu: 'Math/Range/Clamp',
        title: 'Clamp'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Clamp, _ShaderNode);
        function Clamp() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector'), slot('Min', Vec4.ZERO, 'vec4', 'vector'), slot('Max', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Clamp.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var input2 = this.getInputValue(2);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = clamp(" + input0 + ", " + input1 + ", " + input2 + ");\n        ";
        };
        return Clamp;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ClickToLoadUrl.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Node, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "a48dbUuDTJPDp+LzPEDK4rA", "ClickToLoadUrl", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * 
       */
      var ClickToLoadUrl = exports('ClickToLoadUrl', (_dec = ccclass('ClickToLoadUrl'), _dec2 = property({
        multiline: true
      }), _dec3 = property({
        tooltip: ''
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(ClickToLoadUrl, _Component);
        function ClickToLoadUrl() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "url", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "openInNewTap", _descriptor2, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = ClickToLoadUrl.prototype;
        /**
         * 
         */
        _proto.onLoad = function onLoad() {
          this.registerEvent();
        }

        /**
         * 
         */;
        _proto.onDestroy = function onDestroy() {
          this.unregisterEvent();
        }

        /**
         * 
         */;
        _proto.registerEvent = function registerEvent() {
          this.node.on(Node.EventType.TOUCH_END, this.onClick, this);
        }

        /**
         * 
         */;
        _proto.unregisterEvent = function unregisterEvent() {
          this.node.off(Node.EventType.TOUCH_END, this.onClick, this);
        }

        /**
         * 
         */;
        _proto.onClick = function onClick() {
          var url = this.url;
          if (!url || url === '') {
            return;
          }
          // 
          if (this.openInNewTap) {
            // 
            window.open(url);
          } else {
            // 
            window.location.href = url;
          }
        };
        return ClickToLoadUrl;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "url", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 'https://gitee.com/ifaswind';
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "openInNewTap", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ClientEvent.ts", ['cc'], function (exports) {
  var cclegacy, _decorator;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "f3654C79/FGx7RDXCjGKZLE", "ClientEvent", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var ClientEvent = exports('ClientEvent', (_dec = ccclass("clientEvent"), _dec(_class = (_class2 = /*#__PURE__*/function () {
        function ClientEvent() {}
        /**
         * @param {string} eventName 
         * @param {function} handler 
         * @param {object} target 
         */
        ClientEvent.on = function on(eventName, handler, target) {
          var objHandler = {
            handler: handler,
            target: target
          };
          var handlerList = ClientEvent._handlers[eventName];
          if (!handlerList) {
            handlerList = [];
            ClientEvent._handlers[eventName] = handlerList;
          }
          for (var i = 0; i < handlerList.length; i++) {
            if (!handlerList[i]) {
              handlerList[i] = objHandler;
              return i;
            }
          }
          handlerList.push(objHandler);
          return handlerList.length;
        };
        /**
         * @param {string} eventName 
         * @param {function} handler 
         * @param {object} target 
         */
        ClientEvent.off = function off(eventName, handler, target) {
          var handlerList = ClientEvent._handlers[eventName];
          if (!handlerList) {
            return;
          }
          for (var i = 0; i < handlerList.length; i++) {
            var oldObj = handlerList[i];
            if (oldObj.handler === handler && (!target || target === oldObj.target)) {
              handlerList.splice(i, 1);
              break;
            }
          }
        };
        /**
         * @param {string} eventName 
         * @param  {...any} params 
         */
        ClientEvent.dispatchEvent = function dispatchEvent(eventName) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          var handlerList = ClientEvent._handlers[eventName];
          var args1 = [];
          var i;
          for (i = 1; i < arguments.length; i++) {
            args1.push(arguments[i]);
          }
          if (!handlerList) {
            return;
          }
          for (i = 0; i < handlerList.length; i++) {
            var objHandler = handlerList[i];
            if (objHandler.handler) {
              objHandler.handler.apply(objHandler.target, args1);
            }
          }
        };
        return ClientEvent;
      }(), _class2._handlers = {}, _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/color.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './input-node.ts', './utils.ts', './index3.ts', './register.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, InputNode, prop, slot, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      InputNode = module.default;
    }, function (module) {
      prop = module.prop;
      slot = module.slot;
    }, null, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "e3d34kNDmBJC7P5ldMA5yga", "color", undefined);
      var ColorNode = exports('default', (_dec = register({
        menu: 'Input/Basic/Color',
        title: 'Color'
      }), _dec(_class = /*#__PURE__*/function (_InputNode) {
        _inheritsLoose(ColorNode, _InputNode);
        function ColorNode() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _InputNode.call.apply(_InputNode, [this].concat(args)) || this;
          _this.fixedConcretePrecision = 4;
          _this.data = {
            props: [prop('Color', new Vec4(), 'color')],
            outputs: [slot('Out', new Vec4(), 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = ColorNode.prototype;
        _proto.generateCode = function generateCode() {
          var prop = this.getPropWithName('Color');
          var c = prop.value;
          return "vec4 " + this.getOutputVarName(0) + " = vec4(" + c.x + ", " + c.y + ", " + c.z + ", " + c.w + ");";
        };
        return ColorNode;
      }(InputNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/combine.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './index3.ts', './base.ts', './type.ts', './utils.ts', './register.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, Vec3, Vec2, ShaderNode, ConcretePrecisionType, slot, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
      Vec3 = module.Vec3;
      Vec2 = module.Vec2;
    }, null, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "c9cd7cUxzJGfqrBxyo6i9Gm", "combine", undefined);
      var CombineNode = exports('default', (_dec = register({
        menu: 'Channel/Combine',
        title: 'Combine'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(CombineNode, _ShaderNode);
        function CombineNode() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.data = {
            inputs: [slot('R', 0, 'float', 'vector'), slot('G', 0, 'float', 'vector'), slot('B', 0, 'float', 'vector'), slot('A', 0, 'float', 'vector')],
            outputs: [slot('RGBA', Vec4.ZERO, 'vec4', 'vector'), slot('RGB', Vec3.ZERO, 'vec3', 'vector'), slot('RG', Vec2.ZERO, 'vec2', 'vector')]
          };
          return _this;
        }
        var _proto = CombineNode.prototype;
        _proto.generateCode = function generateCode() {
          var slotR = this.getSlotWithSlotName('R');
          var slotG = this.getSlotWithSlotName('G');
          var slotB = this.getSlotWithSlotName('B');
          var slotA = this.getSlotWithSlotName('A');
          var slotRGBA = this.getSlotWithSlotName('RGBA');
          var slotRGB = this.getSlotWithSlotName('RGB');
          var slotRG = this.getSlotWithSlotName('RG');
          var code = '';
          if (slotRGBA && slotRGBA.connectSlot) {
            code += (slotRGBA == null ? void 0 : slotRGBA.varDefine) + " = vec4(" + (slotR == null ? void 0 : slotR.slotValue) + ", " + (slotG == null ? void 0 : slotG.slotValue) + ", " + (slotB == null ? void 0 : slotB.slotValue) + ", " + (slotA == null ? void 0 : slotA.slotValue) + ");\n";
          }
          if (slotRGB && slotRGB.connectSlot) {
            code += (slotRGB == null ? void 0 : slotRGB.varDefine) + " = vec3(" + (slotR == null ? void 0 : slotR.slotValue) + ", " + (slotG == null ? void 0 : slotG.slotValue) + ", " + (slotB == null ? void 0 : slotB.slotValue) + ");\n";
          }
          if (slotRG && slotRG.connectSlot) {
            code += (slotRG == null ? void 0 : slotRG.varDefine) + " = vec2(" + (slotR == null ? void 0 : slotR.slotValue) + ", " + (slotG == null ? void 0 : slotG.slotValue) + ");\n";
          }
          return code;
        };
        return CombineNode;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/comparison.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, register, ShaderNode, ConcretePrecisionType, prop, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      prop = module.prop;
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "29cf0dWHHJIo4dVJcv8q6Ik", "comparison", undefined);
      var ComparisonType = /*#__PURE__*/function (ComparisonType) {
        ComparisonType[ComparisonType["Equal"] = 0] = "Equal";
        ComparisonType[ComparisonType["NotEqual"] = 1] = "NotEqual";
        ComparisonType[ComparisonType["Less"] = 2] = "Less";
        ComparisonType[ComparisonType["LessOrEqual"] = 3] = "LessOrEqual";
        ComparisonType[ComparisonType["Greater"] = 4] = "Greater";
        ComparisonType[ComparisonType["GreaterOrEqual"] = 5] = "GreaterOrEqual";
        return ComparisonType;
      }(ComparisonType || {});
      var Comparison = exports('default', (_dec = register({
        menu: 'Logic/Comparison',
        title: 'Comparison'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Comparison, _ShaderNode);
        function Comparison() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.fixedConcretePrecision = 1;
          _this.data = {
            props: [prop('Type', ComparisonType.Equal, 'enum', {
              "enum": ComparisonType
            })],
            inputs: [slot('A', 0, 'float', 'vector'), slot('B', 0, 'float', 'vector')],
            outputs: [slot('Out', 0, 'boolean', 'boolean')]
          };
          return _this;
        }
        var _proto = Comparison.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var A = this.getInputValue(0);
          var B = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          var code = '';
          var type = this.getPropWithName('Type');
          switch (type.value) {
            case ComparisonType.Equal:
              code = "(" + A + " == " + B + ")";
              break;
            case ComparisonType.NotEqual:
              code = "(" + A + " != " + B + ")";
              break;
            case ComparisonType.Less:
              code = "(" + A + " < " + B + ")";
              break;
            case ComparisonType.LessOrEqual:
              code = "(" + A + " <= " + B + ")";
              break;
            case ComparisonType.Greater:
              code = "(" + A + " > " + B + ")";
              break;
            case ComparisonType.GreaterOrEqual:
              code = "(" + A + " >= " + B + ")";
              break;
          }
          return "\n            " + output0 + " = " + code + ";\n        ";
        };
        return Comparison;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ComponentPool.ts", ['cc'], function (exports) {
  var cclegacy, _decorator;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "bebeaAU60hJjpSfuLpkpTPQ", "ComponentPool", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var ComponentPool = exports('ComponentPool', (_dec = ccclass('ComponentPool'), _dec(_class = /*#__PURE__*/function () {
        function ComponentPool(factory, parentNode) {
          this.pool = void 0;
          this.factory = void 0;
          this.parentNode = void 0;
          this.pool = [];
          this.factory = factory;
          this.parentNode = parentNode;
        }
        var _proto = ComponentPool.prototype;
        _proto.init = function init(size) {
          for (var i = 0; i < size; i++) {
            var component = this.factory();
            component.node.parent = this.parentNode;
            this.put(component);
          }
        };
        _proto.get = function get() {
          if (this.pool.length > 0) {
            var component = this.pool.pop();
            component.node.active = true; // Reactivate the node
            return component;
          } else {
            var _component = this.factory();
            _component.node.parent = this.parentNode;
            return _component;
          }
        };
        _proto.put = function put(item) {
          item.node.active = false; // Deactivate the node
          item.node.parent = this.parentNode;
          this.pool.push(item);
        };
        _proto.putAll = function putAll(items) {
          var _this = this;
          items.forEach(function (item) {
            return _this.put(item);
          });
        };
        _proto.clear = function clear() {
          this.pool.forEach(function (component) {
            component.node.destroy(); // Or any other cleanup logic specific to your components
          });

          this.pool = [];
        };
        return ComponentPool;
      }()) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/Constants.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "5f860beWrBGtbckv8i95YZU", "Constants", undefined);
      var GameConstant = exports('GameConstant', {
        EVENT_NAME: {
          GAME_INITED: "GAME_INITED_DONE",
          USERDATA_UPDATED: "USERDATA_UPDATED",
          // trigger event after user data updated 
          USERCOIN_UPDATED: "USERCOIN_UPDATED" //if listen to USERDATA_UPDATED do not listen this 
        },

        RESOURCE_PATH: {
          GAME_MAIN_PATH: "prefab/Game"
        },
        SOUND_FILES: {
          SFX_PATH: "sounds/sfx/"
        },
        CAMERA_CONFIG: {
          MIN_SIZE: 200
        },
        CAMERA_ZOOM_THRESHOLD: 500,
        AUTO_TIME: 3.0,
        STORAGE_KEY: {
          BGM_VOLUME: "BGM_VOLUME",
          SFX_VOLUME: "SFX_VOLUME",
          USER_MODIFIER: "USER_MODIFIER"
        },
        EFFECT: {
          MOVING_UI_OBJECT: "moving",
          UI_COINS: "coins",
          UI_TURNS: "turns",
          LEVLEUP_SMALL: "levelup_small",
          LEVLEUP_BIG: "levelup_big",
          CONFETTI: "confetti",
          TEXT: "text"
        },
        GAME: {
          PHYSIC_GRAVITY: 18.0
        },
        VIEW: {
          TOPHUB: "ViewTopHub"
        }
      });

      // this will be setted by scene enviroment (prod, dev, staging,...)
      var CurrentEnviroment = exports('CurrentEnviroment', {
        API: "",
        LOG: true
      });
      var setEnvi = exports('setEnvi', function setEnvi(data) {
        CurrentEnviroment = exports('CurrentEnviroment', data);
      });
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/context.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "130e0LrRvNOq7GOFf5/5IGV", "context", undefined);
      var ShaderContext = exports('ShaderContext', /*#__PURE__*/function () {
        function ShaderContext() {
          this.shaderTemplatesDir = void 0;
          this.allNodes = [];
          this.properties = [];
          this.localVars = [];
          this.getLocalVars = [];
        }
        var _proto = ShaderContext.prototype;
        _proto.reset = function reset() {
          this.allNodes.length = 0;
          this.properties.length = 0;
          this.localVars.length = 0;
          this.getLocalVars.length = 0;
        };
        return ShaderContext;
      }());
      var shaderContext = exports('shaderContext', new ShaderContext());
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/cosine.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "2e9b7mUik5Cj7/HtwG5GjOg", "cosine", undefined);
      var Cosine = exports('default', (_dec = register({
        menu: 'Math/Trigonometry/Cosine',
        title: 'Cosine'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Cosine, _ShaderNode);
        function Cosine() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Cosine.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = cos(" + input0 + ");\n        ";
        };
        return Cosine;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/cross-product.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "13009pA4vlKI5jSuhV9uAJV", "cross-product", undefined);
      var CrossProduct = exports('default', (_dec = register({
        menu: 'Math/Vector/CrossProduct',
        title: 'CrossProduct'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(CrossProduct, _ShaderNode);
        function CrossProduct() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = CrossProduct.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = cross(" + input0 + ", " + input1 + ");\n        ";
        };
        return CrossProduct;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/CSVLoader.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "a3605ZRcydAsqLfvt2I7n/+", "CSVLoader", undefined);
      var CSVLoader = exports('CSVLoader', /*#__PURE__*/function () {
        function CSVLoader() {}
        CSVLoader.fromCSV = function fromCSV(csvString, fieldSeparator, lineBreak) {
          if (fieldSeparator === void 0) {
            fieldSeparator = ',';
          }
          if (lineBreak === void 0) {
            lineBreak = '\n';
          }
          // Split the CSV string into rows
          var rows = csvString.split(lineBreak);

          // Extract header row
          var headers = rows[0].split(fieldSeparator);

          // Remove the header row from the rows array
          rows.shift();

          // Process rows
          var data = rows.filter(function (row) {
            return row != null && row != "";
          }).map(function (row) {
            var values = row.split(fieldSeparator);
            var obj = {};
            headers.forEach(function (header, index) {
              var value = values[index].trim();
              if (value != "") {
                // Parse numeric values
                if (!isNaN(Number(value))) {
                  value = Number(value);
                }
                // Parse boolean values
                else if (value.toLowerCase() === 'true' || value.toLowerCase() === 'false') {
                  value = value.toLowerCase() === 'true';
                }
              }
              obj[header.trim()] = value;
            });
            return obj;
          });
          return data;
        };
        CSVLoader.toCSV = function toCSV(dataArray, fieldSeparator, lineBreak) {
          if (fieldSeparator === void 0) {
            fieldSeparator = ',';
          }
          if (lineBreak === void 0) {
            lineBreak = '\n';
          }
          if (dataArray.length === 0) {
            return '';
          }

          // Extract headers from the first object
          var headers = Object.keys(dataArray[0]);

          // Generate CSV header row
          var headerRow = headers.join(fieldSeparator);

          // Generate CSV data rows
          var dataRows = dataArray.map(function (data) {
            return headers.map(function (header) {
              return data[header];
            }).join(fieldSeparator);
          });

          // Combine header row and data rows
          var csvString = [headerRow].concat(dataRows).join(lineBreak);
          return csvString;
        };
        return CSVLoader;
      }());
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/csvManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _createClass, cclegacy, _decorator;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "60302ameClCGbCam2xkotxy", "csvManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var CELL_DELIMITERS = [",", ";", "\t", "|", "^"];
      var LINE_DELIMITERS = ["\r\n", "\r", "\n"];
      var getterCast = function getterCast(value, index, cast, d) {
        if (cast instanceof Array) {
          if (cast[index] === "number") {
            return Number(d[index]);
          } else if (cast[index] === "boolean") {
            return d[index] === "true" || d[index] === "t" || d[index] === "1";
          } else {
            return d[index];
          }
        } else {
          if (!isNaN(Number(value))) {
            return Number(d[index]);
          } else if (value == "false" || value == "true" || value == "t" || value == "f") {
            return d[index] === "true" || d[index] === "t" || d[index] === "1";
          } else {
            return d[index];
          }
        }
      };
      var CSV = {
        //

        /* =========================================
            * Constants ===============================
            * ========================================= */

        STANDARD_DECODE_OPTS: {
          skip: 0,
          limit: false,
          header: false,
          cast: false,
          comment: ""
        },
        STANDARD_ENCODE_OPTS: {
          delimiter: CELL_DELIMITERS[0],
          newline: LINE_DELIMITERS[0],
          skip: 0,
          limit: false,
          header: false
        },
        quoteMark: '"',
        doubleQuoteMark: '""',
        quoteRegex: /"/g,
        /* =========================================
            * Utility Functions =======================
            * ========================================= */
        assign: function assign() {
          var args = Array.prototype.slice.call(arguments);
          var base = args[0];
          var rest = args.slice(1);
          for (var i = 0, len = rest.length; i < len; i++) {
            for (var attr in rest[i]) {
              base[attr] = rest[i][attr];
            }
          }
          return base;
        },
        map: function map(collection, fn) {
          var results = [];
          for (var i = 0, len = collection.length; i < len; i++) {
            results[i] = fn(collection[i], i);
          }
          return results;
        },
        getType: function getType(obj) {
          return Object.prototype.toString.call(obj).slice(8, -1);
        },
        getLimit: function getLimit(limit, len) {
          return limit === false ? len : limit;
        },
        buildObjectConstructor: function buildObjectConstructor(fields, sample, cast) {
          return function (d) {
            var object = new Object();
            var setter = function setter(attr, value) {
              return object[attr] = value;
            };
            if (cast) {
              fields.forEach(function (attr, idx) {
                setter(attr, getterCast(sample[idx], idx, cast, d));
              });
            } else {
              fields.forEach(function (attr, idx) {
                setter(attr, getterCast(sample[idx], idx, null, d));
              });
            }
            // body.push("return object;");
            // body.join(";\n");
            return object;
          };
        },
        buildArrayConstructor: function buildArrayConstructor(fields, sample, cast) {
          return function (d) {
            var row = new Array(sample.length);
            var setter = function setter(idx, value) {
              return row[idx] = value;
            };
            if (cast) {
              fields.forEach(function (attr, idx) {
                setter(attr, getterCast(sample[idx], idx, cast, d));
              });
            } else {
              fields.forEach(function (attr, idx) {
                setter(attr, getterCast(sample[idx], idx, null, d));
              });
            }
            return row;
          };
        },
        frequency: function frequency(coll, needle, limit) {
          if (limit === void 0) limit = false;
          var count = 0;
          var lastIndex = 0;
          var maxIndex = this.getLimit(limit, coll.length);
          while (lastIndex < maxIndex) {
            lastIndex = coll.indexOf(needle, lastIndex);
            if (lastIndex === -1) break;
            lastIndex += 1;
            count++;
          }
          return count;
        },
        mostFrequent: function mostFrequent(coll, needles, limit) {
          var max = 0;
          var detected;
          for (var cur = needles.length - 1; cur >= 0; cur--) {
            if (this.frequency(coll, needles[cur], limit) > max) {
              detected = needles[cur];
            }
          }
          return detected || needles[0];
        },
        unsafeParse: function unsafeParse(text, opts, fn) {
          var lines = text.split(opts.newline);
          if (opts.skip > 0) {
            lines.splice(opts.skip);
          }
          var fields;
          var constructor;
          function cells(lines) {
            var line = lines.shift();
            if (line.indexOf('"') >= 0) {
              // 

              // , 
              var lastIndex = 0;
              var findIndex = 0;
              var count = 0;
              while (lines.length > 0) {
                lastIndex = line.indexOf('"', findIndex);
                if (lastIndex === -1 && count % 2 === 0) break;
                if (lastIndex !== -1) {
                  findIndex = lastIndex + 1;
                  count++;
                } else {
                  line = line + opts.newline + lines.shift();
                }
              }
              var list = [];
              var item;
              var quoteCount = 0;
              var start = 0;
              var end = 0;
              var length = line.length;
              for (var key in line) {
                if (!line.hasOwnProperty(key)) {
                  continue;
                }
                var numKey = parseInt(key);
                var value = line[key];
                if (numKey === 0 && value === '"') {
                  quoteCount++;
                  start = 1;
                }
                if (value === '"') {
                  quoteCount++;
                  if (line[numKey - 1] === opts.delimiter && start === numKey) {
                    start++;
                  }
                }
                if (value === '"' && quoteCount % 2 === 0) {
                  if (line[numKey + 1] === opts.delimiter || numKey + 1 === length) {
                    end = numKey;
                    item = line.substring(start, end);
                    list.push(item);
                    start = end + 2;
                    end = start;
                  }
                }
                if (value === opts.delimiter && quoteCount % 2 === 0) {
                  end = numKey;
                  if (end > start) {
                    item = line.substring(start, end);
                    list.push(item);
                    start = end + 1;
                    end = start;
                  } else if (end === start) {
                    list.push("");
                    start = end + 1;
                    end = start;
                  }
                }
              }
              end = length;
              if (end >= start) {
                item = line.substring(start, end);
                list.push(item);
              }
              return list;
            } else {
              return line.split(opts.delimiter);
            }
          }
          if (opts.header) {
            if (opts.header === true) {
              opts.comment = cells(lines); // 
              opts.cast = cells(lines); // 
              fields = cells(lines);
            } else if (this.getType(opts.header) === "Array") {
              fields = opts.header;
            }
            constructor = this.buildObjectConstructor(fields, lines[0].split(opts.delimiter), opts.cast);
          } else {
            constructor = this.buildArrayConstructor(fields, lines[0].split(opts.delimiter), opts.cast);
          }
          while (lines.length > 0) {
            var row = cells(lines);
            if (row.length > 1) {
              fn(constructor(row), fields[0]);
            }
          }
          return true;
        },
        safeParse: function safeParse(text, opts, fn) {
          var delimiter = opts.delimiter;
          var newline = opts.newline;
          var lines = text.split(newline);
          if (opts.skip > 0) {
            lines.splice(opts.skip);
          }
          return true;
        },
        encodeCells: function encodeCells(line, delimiter, newline) {
          var row = line.slice(0);
          for (var i = 0, len = row.length; i < len; i++) {
            if (row[i].indexOf(this.quoteMark) !== -1) {
              row[i] = row[i].replace(this.quoteRegex, this.doubleQuoteMark);
            }
            if (row[i].indexOf(delimiter) !== -1 || row[i].indexOf(newline) !== -1) {
              row[i] = this.quoteMark + row[i] + this.quoteMark;
            }
          }
          return row.join(delimiter);
        },
        encodeArrays: function encodeArrays(coll, opts, fn) {
          var delimiter = opts.delimiter;
          var newline = opts.newline;
          if (opts.header && this.getType(opts.header) === "Array") {
            fn(this.encodeCells(opts.header, delimiter, newline));
          }
          for (var cur = 0, lim = this.getLimit(opts.limit, coll.length); cur < lim; cur++) {
            fn(this.encodeCells(coll[cur], delimiter, newline));
          }
          return true;
        },
        encodeObjects: function encodeObjects(coll, opts, fn) {
          var delimiter = opts.delimiter;
          var newline = opts.newline;
          var header;
          var row;
          header = [];
          row = [];
          for (var key in coll[0]) {
            header.push(key);
            row.push(coll[0][key]);
          }
          if (opts.header === true) {
            fn(this.encodeCells(header, delimiter, newline));
          } else if (this.getType(opts.header) === "Array") {
            fn(this.encodeCells(opts.header, delimiter, newline));
          }

          //@ts-ignore
          fn(this.encodeCells(row, delimiter));
          for (var cur = 1, lim = this.getLimit(opts.limit, coll.length); cur < lim; cur++) {
            row = [];
            for (var key$1 = 0, len = header.length; key$1 < len; key$1++) {
              row.push(coll[cur][header[key$1]]);
            }
            fn(this.encodeCells(row, delimiter, newline));
          }
          return true;
        },
        parse: function parse(text, opts, fn) {
          var rows;
          if (this.getType(opts) === "Function") {
            fn = opts;
            opts = {};
          } else if (this.getType(fn) !== "Function") {
            rows = [];
            fn = rows.push.bind(rows);
          } else {
            rows = [];
          }

          //@ts-ignore
          opts = this.assign({}, this.STANDARD_DECODE_OPTS, opts);
          //@ts-ignore
          this.opts = opts;
          if (!opts.delimiter || !opts.newline) {
            var limit = Math.min(48, Math.floor(text.length / 20), text.length);
            opts.delimiter = opts.delimiter || this.mostFrequent(text, CELL_DELIMITERS, limit);
            opts.newline = opts.newline || this.mostFrequent(text, LINE_DELIMITERS, limit);
          }

          // modify by jl .
          return this.unsafeParse(text, opts, fn) && (rows.length > 0 ? rows : true);
        },
        encode: function encode(coll, opts, fn) {
          var lines;
          if (this.getType(opts) === "Function") {
            fn = opts;
            opts = {};
          } else if (this.getType(fn) !== "Function") {
            lines = [];
            fn = lines.push.bind(lines);
          }

          //@ts-ignore
          opts = this.assign({}, this.STANDARD_ENCODE_OPTS, opts);
          if (opts.skip > 0) {
            coll = coll.slice(opts.skip);
          }
          return (this.getType(coll[0]) === "Array" ? this.encodeArrays : this.encodeObjects)(coll, opts, fn) && (lines.length > 0 ? lines.join(opts.newline) : true);
        }
      };
      var CSVManager = exports('CSVManager', (_dec = ccclass("CSVManager"), _dec(_class = (_class2 = /*#__PURE__*/function () {
        function CSVManager() {
          this._csvTables = {};
          this._csvTableForArr = {};
          this._tableCast = {};
          this._tableComment = {};
        }
        var _proto = CSVManager.prototype;
        _proto.addTable = function addTable(tableName, tableContent, force) {
          if (this._csvTables[tableName] && !force) {
            return;
          }
          var tableData = {};
          var tableArr = [];
          var opts = {
            header: true
          };
          CSV.parse(tableContent, opts, function (row, keyName) {
            tableData[row[keyName]] = row;
            tableArr.push(row);
          });
          this._tableCast[tableName] = CSV.opts.cast;
          this._tableComment[tableName] = CSV.opts.comment;
          this._csvTables[tableName] = tableData;
          this._csvTableForArr[tableName] = tableArr;

          //this.csvTables[tableName].initFromText(tableContent);
        }

        /**
        * 
        * @param {string} tableName  
        * @returns {object} 
        */;
        _proto.getTableArr = function getTableArr(tableName) {
          return this._csvTableForArr[tableName];
        }

        /**
         * 
         * @param {string} tableName  
         * @returns {object} 
         */;
        _proto.getTable = function getTable(tableName) {
          return this._csvTables[tableName];
        }

        /**
         * 
         * @param {string} tableName 
         * @param {string} key 
         * @param {any} value 
         * @returns {Object} 
         */;
        _proto.queryOne = function queryOne(tableName, key, value) {
          var table = this.getTable(tableName);
          if (!table) {
            return null;
          }
          if (key) {
            for (var tbItem in table) {
              if (!table.hasOwnProperty(tbItem)) {
                continue;
              }
              if (table[tbItem][key] === value) {
                return table[tbItem];
              }
            }
          } else {
            return table[value];
          }
        }

        /**
         * ID
         * @param {string}tableName 
         * @param {string}ID
         * @returns {Object} 
         */;
        _proto.queryByID = function queryByID(tableName, ID) {
          //@ts-ignore
          return this.queryOne(tableName, null, ID);
        }

        /**
         * keyvalue
         * @param {string} tableName 
         * @param {string} key 
         * @param {any} value 
         * @returns {Object}
         */;
        _proto.queryAll = function queryAll(tableName, key, value) {
          var table = this.getTable(tableName);
          if (!table || !key) {
            return null;
          }
          var ret = {};
          for (var tbItem in table) {
            if (!table.hasOwnProperty(tbItem)) {
              continue;
            }
            if (table[tbItem][key] === value) {
              ret[tbItem] = table[tbItem];
            }
          }
          return ret;
        }

        /**
         *  key  values  Objectkey  ID
         * @param {string} tableName 
         * @param {string} key  
         * @param {Array}values 
         * @returns 
         */;
        _proto.queryIn = function queryIn(tableName, key, values) {
          var table = this.getTable(tableName);
          if (!table || !key) {
            return null;
          }
          var ret = {};
          var keys = Object.keys(table);
          var length = keys.length;
          for (var i = 0; i < length; i++) {
            var item = table[keys[i]];
            if (values.indexOf(item[key]) > -1) {
              ret[keys[i]] = item;
            }
          }
          return ret;
        }

        /**
         * condition key keyvalue objectkey IDvalue
         * @param {string} tableName 
         * @param {any} condition 
         * @returns 
         */;
        _proto.queryByCondition = function queryByCondition(tableName, condition) {
          if (condition.constructor !== Object) {
            return null;
          }
          var table = this.getTable(tableName);
          if (!table) {
            return null;
          }
          var ret = {};
          var tableKeys = Object.keys(table);
          var tableKeysLength = tableKeys.length;
          var keys = Object.keys(condition);
          var keysLength = keys.length;
          for (var i = 0; i < tableKeysLength; i++) {
            var item = table[tableKeys[i]];
            var fit = true;
            for (var j = 0; j < keysLength; j++) {
              var key = keys[j];
              fit = fit && condition[key] === item[key] && !ret[tableKeys[i]];
            }
            if (fit) {
              ret[tableKeys[i]] = item;
            }
          }
          return ret;
        };
        _proto.queryOneByCondition = function queryOneByCondition(tableName, condition) {
          if (condition.constructor !== Object) {
            return null;
          }
          var table = this.getTable(tableName);
          if (!table) {
            return null;
          }
          var keys = Object.keys(condition);
          var keysLength = keys.length;
          for (var keyName in table) {
            var item = table[keyName];
            var fit = true;
            for (var j = 0; j < keysLength; j++) {
              var key = keys[j];
              fit = fit && condition[key] === item[key];
            }
            if (fit) {
              return item;
            }
          }
          return null;
        };
        _createClass(CSVManager, null, [{
          key: "instance",
          get: function get() {
            if (this._instance) {
              return this._instance;
            }
            this._instance = new CSVManager();
            return this._instance;
          }
        }]);
        return CSVManager;
      }(), _class2._instance = void 0, _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/cubemap-asset.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './texture-asset.ts'], function (exports) {
  var _inheritsLoose, cclegacy, TextureAsset;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      TextureAsset = module.default;
    }],
    execute: function () {
      cclegacy._RF.push({}, "f593b68ejRHboYTcPDL7dZe", "cubemap-asset", undefined);
      var CubemapAsset = exports('default', /*#__PURE__*/function (_TextureAsset) {
        _inheritsLoose(CubemapAsset, _TextureAsset);
        function CubemapAsset() {
          return _TextureAsset.apply(this, arguments) || this;
        }
        var _proto = CubemapAsset.prototype;
        _proto.generateCode = function generateCode() {
          return "samplerCube " + this.getOutputVarName(0) + " = " + this.getInputValue(0) + ";";
        };
        return CubemapAsset;
      }(TextureAsset));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/Cursor.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './VectorUtil.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Node, Vec3, Quat, Component, VectorUtil;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Vec3 = module.Vec3;
      Quat = module.Quat;
      Component = module.Component;
    }, function (module) {
      VectorUtil = module.VectorUtil;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "3e784wgXb5FD6qDmQMPWi5v", "Cursor", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var Cursor = exports('Cursor', (_dec = ccclass('Cursor'), _dec2 = property({
        displayName: 'adaptToSurface'
      }), _dec3 = property({
        type: Node,
        displayName: 'referNode',
        visible: function visible() {
          return this.adaptToSurface;
        }
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(Cursor, _Component);
        function Cursor() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "_adaptToSurface", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "referNode", _descriptor2, _assertThisInitialized(_this));
          _this.tempVec3 = new Vec3();
          _this.tempQuat = new Quat();
          return _this;
        }
        var _proto = Cursor.prototype;
        _proto.set = function set(position, normal) {
          this.node.setWorldPosition(position);
          if (this.adaptToSurface && normal) {
            var _this$referNode$getWo, _this$referNode;
            var referPos = (_this$referNode$getWo = (_this$referNode = this.referNode) == null ? void 0 : _this$referNode.getWorldPosition()) != null ? _this$referNode$getWo : Vec3.ZERO;
            var direction = Vec3.subtract(this.tempVec3, position, referPos);
            var forward = VectorUtil.projectOnPlane(direction, normal).normalize();
            var rotation = Quat.fromViewUp(this.tempQuat, forward, normal);
            this.node.setWorldRotation(rotation);
          }
        };
        _createClass(Cursor, [{
          key: "adaptToSurface",
          get: function get() {
            return this._adaptToSurface;
          },
          set: function set(value) {
            this._adaptToSurface = value;
            if (!value) {
              this.node.setWorldRotation(Quat.fromEuler(new Quat(), 0, 0, 0));
            }
          }
        }]);
        return Cursor;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "_adaptToSurface", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "adaptToSurface", [_dec2], Object.getOwnPropertyDescriptor(_class2.prototype, "adaptToSurface"), _class2.prototype), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "referNode", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/DataManagement.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './BeatmapManager.ts'], function (exports) {
  var _inheritsLoose, _extends, _createClass, cclegacy, _decorator, sys, Component, BeatmapManager;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
      _extends = module.extends;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      sys = module.sys;
      Component = module.Component;
    }, function (module) {
      BeatmapManager = module.BeatmapManager;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "9ca9bpOcERGC7OMbq07ARhv", "DataManagement", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Player settings data structure
       */

      /**
       * Player progress data structure
       */

      /**
       * Player statistics data structure
       */

      /**
       * High score entry data structure
       */

      /**
       * Data manager for Magic Tiles 3
       * Handles all persistent data management including settings, progress, statistics, and high scores
       */
      var DataManager = exports('DataManager', (_dec = ccclass('DataManager'), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(DataManager, _Component);
        function DataManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Data caches
          _this.settings = {
            musicVolume: 0.8,
            sfxVolume: 1.0,
            noteSpeed: 1.0,
            audioOffset: 0,
            vibrationEnabled: true,
            notificationEnabled: true,
            autoPlayCount: 5,
            language: 'en',
            lastPlayedSongId: '',
            visualEffectsLevel: 2
          };
          _this.progress = {
            level: 1,
            exp: 0,
            coins: 0,
            gems: 0,
            unlockedSongs: [],
            completedTutorials: []
          };
          _this.statistics = {
            totalPlayCount: 0,
            totalPlayTime: 0,
            perfectCount: 0,
            goodCount: 0,
            okCount: 0,
            missCount: 0,
            maxCombo: 0,
            averageAccuracy: 0,
            songPlayCounts: {}
          };
          _this.highScores = {};
          // Callbacks
          _this.onSettingsChangedCallback = null;
          _this.onProgressChangedCallback = null;
          _this.onCoinsChangedCallback = null;
          // References
          _this.beatmapManager = null;
          return _this;
        }
        var _proto = DataManager.prototype;
        _proto.onLoad = function onLoad() {
          // Set singleton instance
          if (DataManager._instance === null) {
            DataManager._instance = this;
          } else {
            this.destroy();
            return;
          }

          // Get references
          this.beatmapManager = BeatmapManager.instance;

          // Load all data from storage
          this.loadAllData();
        }

        /**
         * Load all data from persistent storage
         */;
        _proto.loadAllData = function loadAllData() {
          this.loadSettings();
          this.loadProgress();
          this.loadStatistics();
          this.loadHighScores();
          console.log('All player data loaded');
        }

        /**
         * Save all data to persistent storage
         */;
        _proto.saveAllData = function saveAllData() {
          this.saveSettings();
          this.saveProgress();
          this.saveStatistics();
          this.saveHighScores();
          console.log('All player data saved');
        }

        /**
         * Load settings from storage
         */;
        _proto.loadSettings = function loadSettings() {
          var data = sys.localStorage.getItem(DataManager.SETTINGS_KEY);
          if (data) {
            try {
              var parsed = JSON.parse(data);
              // Merge with defaults to handle missing properties
              this.settings = _extends({}, this.settings, parsed);
            } catch (e) {
              console.error('Failed to parse settings data:', e);
            }
          }
        }

        /**
         * Save settings to storage
         */;
        _proto.saveSettings = function saveSettings() {
          try {
            var data = JSON.stringify(this.settings);
            sys.localStorage.setItem(DataManager.SETTINGS_KEY, data);
          } catch (e) {
            console.error('Failed to save settings data:', e);
          }
        }

        /**
         * Load player progress from storage
         */;
        _proto.loadProgress = function loadProgress() {
          var data = sys.localStorage.getItem(DataManager.PROGRESS_KEY);
          if (data) {
            try {
              var parsed = JSON.parse(data);
              // Merge with defaults to handle missing properties
              this.progress = _extends({}, this.progress, parsed);
            } catch (e) {
              console.error('Failed to parse progress data:', e);
            }
          }
        }

        /**
         * Save player progress to storage
         */;
        _proto.saveProgress = function saveProgress() {
          try {
            var data = JSON.stringify(this.progress);
            sys.localStorage.setItem(DataManager.PROGRESS_KEY, data);
          } catch (e) {
            console.error('Failed to save progress data:', e);
          }
        }

        /**
         * Load player statistics from storage
         */;
        _proto.loadStatistics = function loadStatistics() {
          var data = sys.localStorage.getItem(DataManager.STATISTICS_KEY);
          if (data) {
            try {
              var parsed = JSON.parse(data);
              // Merge with defaults to handle missing properties
              this.statistics = _extends({}, this.statistics, parsed);
            } catch (e) {
              console.error('Failed to parse statistics data:', e);
            }
          }
        }

        /**
         * Save player statistics to storage
         */;
        _proto.saveStatistics = function saveStatistics() {
          try {
            var data = JSON.stringify(this.statistics);
            sys.localStorage.setItem(DataManager.STATISTICS_KEY, data);
          } catch (e) {
            console.error('Failed to save statistics data:', e);
          }
        }

        /**
         * Load high scores from storage
         */;
        _proto.loadHighScores = function loadHighScores() {
          var data = sys.localStorage.getItem(DataManager.HIGH_SCORES_KEY);
          if (data) {
            try {
              this.highScores = JSON.parse(data);
            } catch (e) {
              console.error('Failed to parse high scores data:', e);
            }
          }
        }

        /**
         * Save high scores to storage
         */;
        _proto.saveHighScores = function saveHighScores() {
          try {
            var data = JSON.stringify(this.highScores);
            sys.localStorage.setItem(DataManager.HIGH_SCORES_KEY, data);
          } catch (e) {
            console.error('Failed to save high scores data:', e);
          }
        }

        /**
         * Get player settings
         */;
        _proto.getSettings = function getSettings() {
          return _extends({}, this.settings); // Return a copy to prevent direct modification
        }

        /**
         * Update player settings
         */;
        _proto.updateSettings = function updateSettings(newSettings) {
          // Update only the provided settings
          this.settings = _extends({}, this.settings, newSettings);

          // Save to storage
          this.saveSettings();

          // Notify listeners
          if (this.onSettingsChangedCallback) {
            this.onSettingsChangedCallback();
          }
        }

        /**
         * Get player progress
         */;
        _proto.getProgress = function getProgress() {
          return _extends({}, this.progress); // Return a copy to prevent direct modification
        }

        /**
         * Add experience points and update level if needed
         */;
        _proto.addExperience = function addExperience(exp) {
          if (exp <= 0) return;
          this.progress.exp += exp;

          // Check for level up (simple level calculation)
          var newLevel = Math.floor(Math.sqrt(this.progress.exp / 100)) + 1;
          var leveledUp = newLevel > this.progress.level;
          if (leveledUp) {
            var oldLevel = this.progress.level;
            this.progress.level = newLevel;
            console.log("Player leveled up from " + oldLevel + " to " + newLevel + "!");

            // TODO: Handle level up rewards
          }

          // Save progress
          this.saveProgress();

          // Notify listeners
          if (this.onProgressChangedCallback) {
            this.onProgressChangedCallback(this.getProgress());
          }
          return leveledUp;
        }

        /**
         * Add or subtract coins
         */;
        _proto.updateCoins = function updateCoins(amount) {
          this.progress.coins += amount;

          // Ensure coins don't go negative
          if (this.progress.coins < 0) {
            this.progress.coins = 0;
          }

          // Save progress
          this.saveProgress();

          // Notify listeners
          if (this.onCoinsChangedCallback) {
            this.onCoinsChangedCallback(this.progress.coins);
          }
          return this.progress.coins;
        }

        /**
         * Add or subtract gems
         */;
        _proto.updateGems = function updateGems(amount) {
          this.progress.gems += amount;

          // Ensure gems don't go negative
          if (this.progress.gems < 0) {
            this.progress.gems = 0;
          }

          // Save progress
          this.saveProgress();
          return this.progress.gems;
        }

        /**
         * Check if a song is unlocked
         */;
        _proto.isSongUnlocked = function isSongUnlocked(songId) {
          // Check the unlockedSongs array
          return this.progress.unlockedSongs.indexOf(songId) >= 0;
        }

        /**
         * Unlock a song
         */;
        _proto.unlockSong = function unlockSong(songId) {
          if (!this.isSongUnlocked(songId)) {
            this.progress.unlockedSongs.push(songId);
            this.saveProgress();
            return true;
          }
          return false;
        }

        /**
         * Get all unlocked songs
         */;
        _proto.getUnlockedSongs = function getUnlockedSongs() {
          return [].concat(this.progress.unlockedSongs); // Return a copy to prevent direct modification
        }

        /**
         * Get player statistics
         */;
        _proto.getStatistics = function getStatistics() {
          return _extends({}, this.statistics); // Return a copy to prevent direct modification
        }

        /**
         * Update statistics after playing a song
         */;
        _proto.updateStatistics = function updateStatistics(songId, playTime, perfect, good, ok, miss, maxCombo, accuracy) {
          // Update song play count
          if (!this.statistics.songPlayCounts[songId]) {
            this.statistics.songPlayCounts[songId] = 0;
          }
          this.statistics.songPlayCounts[songId]++;

          // Update total play count
          this.statistics.totalPlayCount++;

          // Update total play time
          this.statistics.totalPlayTime += playTime;

          // Update hit counts
          this.statistics.perfectCount += perfect;
          this.statistics.goodCount += good;
          this.statistics.okCount += ok;
          this.statistics.missCount += miss;

          // Update max combo
          if (maxCombo > this.statistics.maxCombo) {
            this.statistics.maxCombo = maxCombo;
          }

          // Update average accuracy
          // Using a weighted average based on play count
          var oldWeight = (this.statistics.totalPlayCount - 1) / this.statistics.totalPlayCount;
          var newWeight = 1 / this.statistics.totalPlayCount;
          this.statistics.averageAccuracy = this.statistics.averageAccuracy * oldWeight + accuracy * newWeight;

          // Save updated statistics
          this.saveStatistics();
        }

        /**
         * Get song play count
         */;
        _proto.getSongPlayCount = function getSongPlayCount(songId) {
          return this.statistics.songPlayCounts[songId] || 0;
        }

        /**
         * Get all song play counts
         */;
        _proto.getAllSongPlayCounts = function getAllSongPlayCounts() {
          return _extends({}, this.statistics.songPlayCounts);
        }

        /**
         * Get high score for a song
         */;
        _proto.getHighScore = function getHighScore(songId) {
          return this.highScores[songId] || null;
        }

        /**
         * Submit a new score for a song
         * Returns true if it's a new high score
         */;
        _proto.submitScore = function submitScore(songId, score, accuracy, maxCombo, perfect, good, ok, miss) {
          // Check if this is a new high score
          var currentHighScore = this.getHighScore(songId);
          var isNewHighScore = !currentHighScore || score > currentHighScore.score;
          if (isNewHighScore) {
            // Create new high score entry
            var newEntry = {
              score: score,
              accuracy: accuracy,
              maxCombo: maxCombo,
              perfect: perfect,
              good: good,
              ok: ok,
              miss: miss,
              date: Date.now()
            };

            // Save the new high score
            this.highScores[songId] = newEntry;
            this.saveHighScores();
          }
          return isNewHighScore;
        }

        /**
         * Get all high scores
         */;
        _proto.getAllHighScores = function getAllHighScores() {
          return _extends({}, this.highScores);
        }

        /**
         * Clear all data (for debugging or account reset)
         */;
        _proto.clearAllData = function clearAllData() {
          // Clear all data from storage
          sys.localStorage.removeItem(DataManager.SETTINGS_KEY);
          sys.localStorage.removeItem(DataManager.PROGRESS_KEY);
          sys.localStorage.removeItem(DataManager.STATISTICS_KEY);
          sys.localStorage.removeItem(DataManager.HIGH_SCORES_KEY);

          // Reset caches to defaults
          this.settings = {
            musicVolume: 0.8,
            sfxVolume: 1.0,
            noteSpeed: 1.0,
            audioOffset: 0,
            vibrationEnabled: true,
            notificationEnabled: true,
            autoPlayCount: 5,
            language: 'en',
            lastPlayedSongId: '',
            visualEffectsLevel: 2
          };
          this.progress = {
            level: 1,
            exp: 0,
            coins: 0,
            gems: 0,
            unlockedSongs: [],
            completedTutorials: []
          };
          this.statistics = {
            totalPlayCount: 0,
            totalPlayTime: 0,
            perfectCount: 0,
            goodCount: 0,
            okCount: 0,
            missCount: 0,
            maxCombo: 0,
            averageAccuracy: 0,
            songPlayCounts: {}
          };
          this.highScores = {};
          console.log('All player data cleared');
        }

        /**
         * Register a callback for settings changes
         */;
        _proto.onSettingsChanged = function onSettingsChanged(callback) {
          this.onSettingsChangedCallback = callback;
        }

        /**
         * Register a callback for progress changes
         */;
        _proto.onProgressChanged = function onProgressChanged(callback) {
          this.onProgressChangedCallback = callback;
        }

        /**
         * Register a callback for coins changes
         */;
        _proto.onCoinsChanged = function onCoinsChanged(callback) {
          this.onCoinsChangedCallback = callback;
        }

        /**
         * Mark a tutorial as completed
         */;
        _proto.completeTutorial = function completeTutorial(tutorialId) {
          if (this.progress.completedTutorials.indexOf(tutorialId) < 0) {
            this.progress.completedTutorials.push(tutorialId);
            this.saveProgress();
          }
        }

        /**
         * Check if a tutorial is completed
         */;
        _proto.isTutorialCompleted = function isTutorialCompleted(tutorialId) {
          return this.progress.completedTutorials.indexOf(tutorialId) >= 0;
        }

        /**
         * Export player data as JSON (for backup or transfer)
         */;
        _proto.exportData = function exportData() {
          var data = {
            settings: this.settings,
            progress: this.progress,
            statistics: this.statistics,
            highScores: this.highScores
          };
          return JSON.stringify(data);
        }

        /**
         * Import player data from JSON
         */;
        _proto.importData = function importData(jsonData) {
          try {
            var data = JSON.parse(jsonData);
            if (data.settings) this.settings = data.settings;
            if (data.progress) this.progress = data.progress;
            if (data.statistics) this.statistics = data.statistics;
            if (data.highScores) this.highScores = data.highScores;

            // Save all imported data
            this.saveAllData();
            return true;
          } catch (e) {
            console.error('Failed to import data:', e);
            return false;
          }
        };
        _createClass(DataManager, null, [{
          key: "instance",
          get: function get() {
            return DataManager._instance;
          }

          // Storage keys
        }]);

        return DataManager;
      }(Component), _class2._instance = null, _class2.SETTINGS_KEY = 'magicTiles_settings', _class2.PROGRESS_KEY = 'magicTiles_progress', _class2.STATISTICS_KEY = 'magicTiles_statistics', _class2.HIGH_SCORES_KEY = 'magicTiles_highScores', _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ddx.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "a9e8cu/8AxJgqL6Mn6GY7sg", "ddx", undefined);
      var DDX = exports('default', (_dec = register({
        menu: 'Math/Derivative/DDX',
        title: 'DDX'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(DDX, _ShaderNode);
        function DDX() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = DDX.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = dFdx(" + input0 + ");\n        ";
        };
        return DDX;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ddxy.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "ec1afn79wpEi5T7OYFN+OIo", "ddxy", undefined);
      var DDXY = exports('default', (_dec = register({
        menu: 'Math/Derivative/DDXY',
        title: 'DDXY'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(DDXY, _ShaderNode);
        function DDXY() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = DDXY.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = abs(dFdx(" + input0 + ")) + abs(dFdy(" + input0 + "));\n        ";
        };
        return DDXY;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ddy.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "8231cetsI5JAKl/k454/49j", "ddy", undefined);
      var DDY = exports('default', (_dec = register({
        menu: 'Math/Derivative/DDY',
        title: 'DDY'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(DDY, _ShaderNode);
        function DDY() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = DDY.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = dFdy(" + input0 + ");\n        ";
        };
        return DDY;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/debug.ts", ['cc'], function (exports) {
  var cclegacy, Color;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Color = module.Color;
    }],
    execute: function () {
      cclegacy._RF.push({}, "a66bdQHmTxEUris3Jx+UGmB", "debug", undefined);
      /**  */
      var DEBUG_DRAW_LINE_COLOR = exports('DEBUG_DRAW_LINE_COLOR', new Color(238, 124, 55, 255));
      var DEBUG_DRAW_FILL_COLOR = exports('DEBUG_DRAW_FILL_COLOR', new Color(88, 175, 64, 50));
      var DEBUG_DRAW_BORDER_COLOR = exports('DEBUG_DRAW_BORDER_COLOR', new Color(56, 120, 94, 255));
      var DEBUG_DRAW_LIND_WIDTH = exports('DEBUG_DRAW_LIND_WIDTH', 3);
      /** View */
      var ADAPTER_DEBUG_VIEW = exports('ADAPTER_DEBUG_VIEW', false);
      /** Content */
      var ADAPTER_DEBUG_CONTENT = exports('ADAPTER_DEBUG_CONTENT', false);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/Defines.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "6cbe82sbBRJZ5dw448hn0pZ", "Defines", undefined);
      var UserInteractEventType = exports('UserInteractEventType', /*#__PURE__*/function (UserInteractEventType) {
        UserInteractEventType[UserInteractEventType["NONE"] = 0] = "NONE";
        UserInteractEventType[UserInteractEventType["TOUCH"] = 1] = "TOUCH";
        UserInteractEventType[UserInteractEventType["DRAG"] = 2] = "DRAG";
        UserInteractEventType[UserInteractEventType["ZOOM"] = 3] = "ZOOM";
        UserInteractEventType[UserInteractEventType["SWIPE"] = 4] = "SWIPE";
        UserInteractEventType[UserInteractEventType["HOVER"] = 5] = "HOVER";
        UserInteractEventType[UserInteractEventType["DOUBLE_TOUCH"] = 6] = "DOUBLE_TOUCH";
        UserInteractEventType[UserInteractEventType["END_INTERACTED"] = 7] = "END_INTERACTED";
        return UserInteractEventType;
      }({}));
      var ViewBeginType = exports('ViewBeginType', /*#__PURE__*/function (ViewBeginType) {
        ViewBeginType[ViewBeginType["NONE"] = 0] = "NONE";
        ViewBeginType[ViewBeginType["HIDE"] = 1] = "HIDE";
        ViewBeginType[ViewBeginType["SHOW"] = 2] = "SHOW";
        return ViewBeginType;
      }({}));
      var CornerType = exports('CornerType', /*#__PURE__*/function (CornerType) {
        CornerType[CornerType["LEFT_TOP"] = 0] = "LEFT_TOP";
        CornerType[CornerType["LEFT"] = 1] = "LEFT";
        CornerType[CornerType["LEFT_BOTTOM"] = 2] = "LEFT_BOTTOM";
        CornerType[CornerType["TOP"] = 3] = "TOP";
        CornerType[CornerType["RIGHT_TOP"] = 4] = "RIGHT_TOP";
        CornerType[CornerType["RIGHT"] = 5] = "RIGHT";
        CornerType[CornerType["RIGHT_BOTTOM"] = 6] = "RIGHT_BOTTOM";
        CornerType[CornerType["BOTTOM"] = 7] = "BOTTOM";
        CornerType[CornerType["CENTER"] = 8] = "CENTER";
        return CornerType;
      }({}));
      var MissionType = exports('MissionType', /*#__PURE__*/function (MissionType) {
        MissionType["DAILY"] = "DAILY";
        MissionType["ONE_TIME"] = "ONE_TIME";
        MissionType["STREAK"] = "STREAK";
        MissionType["SOCIAL"] = "SOCIAL";
        return MissionType;
      }({}));
      var MissionRewardType = exports('MissionRewardType', /*#__PURE__*/function (MissionRewardType) {
        MissionRewardType[MissionRewardType["NORMAL"] = 0] = "NORMAL";
        MissionRewardType[MissionRewardType["CLAIMABLE"] = 1] = "CLAIMABLE";
        MissionRewardType[MissionRewardType["CLAIMED"] = 2] = "CLAIMED";
        MissionRewardType[MissionRewardType["PENDING"] = 3] = "PENDING";
        return MissionRewardType;
      }({}));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/degrees-to-radians.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "54cccLnyalN+rGU9RVdf0Ob", "degrees-to-radians", undefined);
      var DegreesToRadians = exports('default', (_dec = register({
        menu: 'Math/Trigonometry/DegreesToRadians',
        title: 'DegreesToRadians'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(DegreesToRadians, _ShaderNode);
        function DegreesToRadians() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = DegreesToRadians.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = radians(" + input0 + ");\n        ";
        };
        return DegreesToRadians;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/distance.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "1d67fgjFt5PYIIoSIE7uP03", "distance", undefined);
      var Distance = exports('default', (_dec = register({
        menu: 'Math/Vector/Distance',
        title: 'Distance'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Distance, _ShaderNode);
        function Distance() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', 0, 'float', 'vector')]
          };
          return _this;
        }
        var _proto = Distance.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = distance(" + input0 + ", " + input1 + ");\n        ";
        };
        return Distance;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/divide.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "027926d68NB7rx2YRTbh0wu", "divide", undefined);
      var Divide = exports('default', (_dec = register({
        menu: 'Math/Basic/Divide',
        title: 'Divide'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Divide, _ShaderNode);
        function Divide() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Max;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Divide.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = " + input0 + " / " + input1 + ";\n        ";
        };
        return Divide;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/dot-product.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "fe81frs65tLqqp2QPfF1tCJ", "dot-product", undefined);
      var DotProduct = exports('default', (_dec = register({
        menu: 'Math/Vector/DotProduct',
        title: 'DotProduct'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(DotProduct, _ShaderNode);
        function DotProduct() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', 0, 'float', 'vector')]
          };
          return _this;
        }
        var _proto = DotProduct.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = dot(" + input0 + ", " + input1 + ");\n        ";
        };
        return DotProduct;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/DynamicSkeletonAnimation.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Animation, resources, AnimationClip, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Animation = module.Animation;
      resources = module.resources;
      AnimationClip = module.AnimationClip;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "97270evPX5NaoJ6I7QVNd3F", "DynamicSkeletonAnimation", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var DynamicAnimationClip = exports('DynamicAnimationClip', (_dec = ccclass('DynamicAnimationClip'), _dec2 = property({
        type: Animation
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(DynamicAnimationClip, _Component);
        function DynamicAnimationClip() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "animationComponent", _descriptor, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = DynamicAnimationClip.prototype;
        _proto.start = function start() {
          var _this2 = this;
          // Dynamically load animation clip.
          resources.load("3d/animation_clips/your_animation_clip", AnimationClip, function (err, clip) {
            if (err) {
              console.error("Failed to load animation clip:", err);
              return;
            }
            if (!clip) {
              console.warn("Animation clip not found at the specified path.");
              return;
            }
            if (!_this2.animationComponent) {
              console.error("Animation component is not assigned in the editor.");
              return;
            }
            _this2.animationComponent.addClip(clip);
            _this2.animationComponent.play('your_animation_clip'); // Play the loaded animation clip
          });
        };

        return DynamicAnimationClip;
      }(Component), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "animationComponent", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/easing.ts", ['cc'], function (exports) {
  var cclegacy, easing;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      easing = module.easing;
    }],
    execute: function () {
      exports('getEasingFunction', getEasingFunction);
      cclegacy._RF.push({}, "996b7qdfwFAPbtK5uluV2M2", "easing", undefined);
      var EasingType = exports('EasingType', /*#__PURE__*/function (EasingType) {
        EasingType[EasingType["Linear"] = 0] = "Linear";
        EasingType[EasingType["SineIn"] = 1] = "SineIn";
        EasingType[EasingType["SineOut"] = 2] = "SineOut";
        EasingType[EasingType["SineInOut"] = 3] = "SineInOut";
        EasingType[EasingType["QuadIn"] = 4] = "QuadIn";
        EasingType[EasingType["QuadOut"] = 5] = "QuadOut";
        EasingType[EasingType["QuadInOut"] = 6] = "QuadInOut";
        EasingType[EasingType["CubicIn"] = 7] = "CubicIn";
        EasingType[EasingType["CubicOut"] = 8] = "CubicOut";
        EasingType[EasingType["CubicInOut"] = 9] = "CubicInOut";
        EasingType[EasingType["QuartIn"] = 10] = "QuartIn";
        EasingType[EasingType["QuartOut"] = 11] = "QuartOut";
        EasingType[EasingType["QuartInOut"] = 12] = "QuartInOut";
        EasingType[EasingType["QuintIn"] = 13] = "QuintIn";
        EasingType[EasingType["QuintOut"] = 14] = "QuintOut";
        EasingType[EasingType["QuintInOut"] = 15] = "QuintInOut";
        EasingType[EasingType["ExpoIn"] = 16] = "ExpoIn";
        EasingType[EasingType["ExpoOut"] = 17] = "ExpoOut";
        EasingType[EasingType["ExpoInOut"] = 18] = "ExpoInOut";
        EasingType[EasingType["CircIn"] = 19] = "CircIn";
        EasingType[EasingType["CircOut"] = 20] = "CircOut";
        EasingType[EasingType["CircInOut"] = 21] = "CircInOut";
        EasingType[EasingType["ElasticIn"] = 22] = "ElasticIn";
        EasingType[EasingType["ElasticOut"] = 23] = "ElasticOut";
        EasingType[EasingType["ElasticInOut"] = 24] = "ElasticInOut";
        EasingType[EasingType["BackIn"] = 25] = "BackIn";
        EasingType[EasingType["BackOut"] = 26] = "BackOut";
        EasingType[EasingType["BackInOut"] = 27] = "BackInOut";
        EasingType[EasingType["BounceIn"] = 28] = "BounceIn";
        EasingType[EasingType["BounceOut"] = 29] = "BounceOut";
        EasingType[EasingType["BounceInOut"] = 30] = "BounceInOut";
        return EasingType;
      }({}));
      function getEasingFunction(easingType) {
        var _easingFunctions;
        var easingFunctions = (_easingFunctions = {}, _easingFunctions[EasingType.Linear] = easing.linear, _easingFunctions[EasingType.SineIn] = easing.sineIn, _easingFunctions[EasingType.SineOut] = easing.sineOut, _easingFunctions[EasingType.SineInOut] = easing.sineInOut, _easingFunctions[EasingType.QuadIn] = easing.quadIn, _easingFunctions[EasingType.QuadOut] = easing.quadOut, _easingFunctions[EasingType.QuadInOut] = easing.quadInOut, _easingFunctions[EasingType.CubicIn] = easing.cubicIn, _easingFunctions[EasingType.CubicOut] = easing.cubicOut, _easingFunctions[EasingType.CubicInOut] = easing.cubicInOut, _easingFunctions[EasingType.QuartIn] = easing.quartIn, _easingFunctions[EasingType.QuartOut] = easing.quartOut, _easingFunctions[EasingType.QuartInOut] = easing.quartInOut, _easingFunctions[EasingType.QuintIn] = easing.quintIn, _easingFunctions[EasingType.QuintOut] = easing.quintOut, _easingFunctions[EasingType.QuintInOut] = easing.quintInOut, _easingFunctions[EasingType.ExpoIn] = easing.expoIn, _easingFunctions[EasingType.ExpoOut] = easing.expoOut, _easingFunctions[EasingType.ExpoInOut] = easing.expoInOut, _easingFunctions[EasingType.CircIn] = easing.circIn, _easingFunctions[EasingType.CircOut] = easing.circOut, _easingFunctions[EasingType.CircInOut] = easing.circInOut, _easingFunctions[EasingType.ElasticIn] = easing.elasticIn, _easingFunctions[EasingType.ElasticOut] = easing.elasticOut, _easingFunctions[EasingType.ElasticInOut] = easing.elasticInOut, _easingFunctions[EasingType.BackIn] = easing.backIn, _easingFunctions[EasingType.BackOut] = easing.backOut, _easingFunctions[EasingType.BackInOut] = easing.backInOut, _easingFunctions[EasingType.BounceIn] = easing.bounceIn, _easingFunctions[EasingType.BounceOut] = easing.bounceOut, _easingFunctions[EasingType.BounceInOut] = easing.bounceInOut, _easingFunctions);
        return easingFunctions[easingType];
      }
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/EffectAnimation.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './EffectTime.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Animation, EffectTime;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Animation = module.Animation;
    }, function (module) {
      EffectTime = module.EffectTime;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor, _descriptor2, _descriptor3;
      cclegacy._RF.push({}, "8ca3fmen/FAube9ooAPgxCz", "EffectAnimation", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var EffectAnimation = exports('EffectAnimation', (_dec = ccclass('EffectAnimation'), _dec2 = property(Animation), _dec(_class = (_class2 = /*#__PURE__*/function (_EffectTime) {
        _inheritsLoose(EffectAnimation, _EffectTime);
        function EffectAnimation() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _EffectTime.call.apply(_EffectTime, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "animMain", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "animName", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "delay", _descriptor3, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = EffectAnimation.prototype;
        _proto.onLoad = function onLoad() {
          this.animMain.node.active = false;
        };
        _proto.init = function init(define, recycleMe, data) {
          var _this2 = this;
          _EffectTime.prototype.init.call(this, define, recycleMe, data);
          this.scheduleOnce(function () {
            _this2.animMain.play(_this2.animName);
          }, this.delay);
        };
        return EffectAnimation;
      }(EffectTime), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "animMain", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "animName", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return "";
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "delay", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/EffectBase.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './audioManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Component, AudioManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
    }, function (module) {
      AudioManager = module.AudioManager;
    }],
    execute: function () {
      var _dec, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "4a695abDKBOU7c/73mimyQe", "EffectBase", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var EffectBase = exports('EffectBase', (_dec = ccclass('EffectBase'), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(EffectBase, _Component);
        function EffectBase() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this.define = "";
          _this.recycleMe = null;
          _initializerDefineProperty(_this, "sound", _descriptor, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = EffectBase.prototype;
        _proto.init = function init(define, recycleMe, data) {
          this.define = define;
          this.recycleMe = recycleMe;
          if (this.sound) {
            AudioManager.instance.playSound(this.sound);
          }
        };
        _proto.putToPool = function putToPool() {
          var _this$recycleMe;
          this == null || (_this$recycleMe = this.recycleMe) == null || _this$recycleMe.call(this, this);
        };
        return EffectBase;
      }(Component), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "sound", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return "";
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/EffectController.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './EffectBase.ts', './ComponentPool.ts', './resourceUtil.ts', './Constants.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Node, instantiate, Component, EffectBase, ComponentPool, resourceUtil, CurrentEnviroment;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      instantiate = module.instantiate;
      Component = module.Component;
    }, function (module) {
      EffectBase = module.EffectBase;
    }, function (module) {
      ComponentPool = module.ComponentPool;
    }, function (module) {
      resourceUtil = module.resourceUtil;
    }, function (module) {
      CurrentEnviroment = module.CurrentEnviroment;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor, _class3;
      cclegacy._RF.push({}, "f1faaHNgYdAgqUp6WWlyLaO", "EffectController", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var EffectController = exports('EffectController', (_dec = ccclass('EffectController'), _dec2 = property(Node), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(EffectController, _Component);
        function EffectController() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          //#endregion
          _this.preloadPrefabNames = [];
          _initializerDefineProperty(_this, "uiEffectContainer", _descriptor, _assertThisInitialized(_this));
          //#endregion
          //#region effects
          _this.effectPoolMap = new Map();
          return _this;
        }
        var _proto = EffectController.prototype;
        _proto.onLoad = function onLoad() {
          EffectController.instance = this;
          this.initPool();
          this.preloadEffects();
        };
        _proto.onDestroy = function onDestroy() {
          EffectController.instance = null;
        };
        _proto.start = function start() {
          this.initPool();
        }

        //#endregion pooling
        ;

        _proto.preloadEffects = function preloadEffects() {
          var _this2 = this;
          this.preloadPrefabNames.forEach(function (effect) {
            if (_this2.effectPoolMap.has(effect) == false) {
              resourceUtil.loadEffectRes(effect).then(function (prefab) {
                _this2.effectPoolMap.set(effect, _this2.createPool(prefab, _this2.uiEffectContainer, EffectBase));
              })["catch"](function (error) {
                if (CurrentEnviroment.LOG) console.error(error, effect);
              });
            }
          });
        };
        _proto.initPool = function initPool() {};
        _proto.createPool = function createPool(prefab, container, componentClass, initValue) {
          if (initValue === void 0) {
            initValue = 1;
          }
          if (!prefab || !container) return null;
          var retVal = new ComponentPool(function () {
            var obj = instantiate(prefab);
            var component = obj.getComponent(componentClass);
            if (!component) {
              console.warn("Component of the specified class not found in prefab.");
              return null;
            }
            return component;
          }, container);
          retVal.init(initValue);
          return retVal;
        };
        _proto.putEffects = function putEffects(effects, define) {
          var _this$effectPoolMap$g;
          (_this$effectPoolMap$g = this.effectPoolMap.get(define)) == null || _this$effectPoolMap$g.putAll(effects);
        };
        _proto.spawnResourceEffectAt = function spawnResourceEffectAt(pos, effect, parent, data, cb) {
          var _this3 = this;
          if (parent === void 0) {
            parent = null;
          }
          if (data === void 0) {
            data = null;
          }
          if (cb === void 0) {
            cb = function cb() {};
          }
          var spawnEffect = function spawnEffect() {
            var _this3$effectPoolMap;
            var objEffect = (_this3$effectPoolMap = _this3.effectPoolMap) == null || (_this3$effectPoolMap = _this3$effectPoolMap.get(effect)) == null ? void 0 : _this3$effectPoolMap.get();
            var define = effect;
            if (parent != null) {
              objEffect.node.parent = parent;
            }
            objEffect.node.setWorldPosition(pos);
            setTimeout(function () {
              objEffect.init(define, function (effect) {
                var _this3$effectPoolMap2;
                (_this3$effectPoolMap2 = _this3.effectPoolMap) == null || (_this3$effectPoolMap2 = _this3$effectPoolMap2.get(define)) == null || _this3$effectPoolMap2.put(effect);
              }, data);
              cb == null || cb(objEffect);
            });
          };
          if (this.effectPoolMap.has(effect) == false) {
            resourceUtil.loadEffectRes(effect).then(function (prefab) {
              _this3.effectPoolMap.set(effect, _this3.createPool(prefab, _this3.uiEffectContainer, EffectBase));
              spawnEffect();
            })["catch"](function (error) {
              if (CurrentEnviroment.LOG) console.error(error, effect);
              cb == null || cb(null, "could not find the effect prefab");
            });
          } else {
            spawnEffect();
          }
        }

        //#endregion
        ;

        return EffectController;
      }(Component), _class3.instance = null, _class3), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "uiEffectContainer", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/EffectManger.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Prefab, instantiate, director, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Prefab = module.Prefab;
      instantiate = module.instantiate;
      director = module.director;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _class3;
      cclegacy._RF.push({}, "b1385xAyyhPB6TsvEBSW4MY", "EffectManger", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property,
        executionOrder = _decorator.executionOrder;

      /**
       * 
       */
      var EffectManger = exports('EffectManger', (_dec = ccclass('EffectManger'), _dec2 = executionOrder(-1), _dec3 = property({
        type: Prefab,
        displayName: ''
      }), _dec(_class = _dec2(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(EffectManger, _Component);
        function EffectManger() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "bulletExplosionPrefab", _descriptor, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = EffectManger.prototype;
        /**
         * 
         */
        _proto.onLoad = function onLoad() {
          EffectManger._instance = this;
        }

        /**
         * 
         */;
        _proto.onDestroy = function onDestroy() {
          if (EffectManger._instance === this) {
            EffectManger._instance = null;
          }
        }

        /**
         * 
         * @param pos 
         */;
        _proto.playBulletExplosion = function playBulletExplosion(pos) {
          // 
          var node = instantiate(this.bulletExplosionPrefab);
          director.getScene().addChild(node);
          node.setWorldPosition(pos);
          // 
          this.scheduleOnce(function () {
            return node.destroy();
          }, 1);
        };
        _createClass(EffectManger, null, [{
          key: "instance",
          get:
          /**
           * 
           */
          function get() {
            return this._instance;
          }
        }]);
        return EffectManger;
      }(Component), _class3._instance = null, _class3), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "bulletExplosionPrefab", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _class2)) || _class) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/EffectMovingObject.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './EffectBase.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Sprite, Label, Node, randomRangeInt, random, Vec3, tween, v3, easing, EffectBase;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Sprite = module.Sprite;
      Label = module.Label;
      Node = module.Node;
      randomRangeInt = module.randomRangeInt;
      random = module.random;
      Vec3 = module.Vec3;
      tween = module.tween;
      v3 = module.v3;
      easing = module.easing;
    }, function (module) {
      EffectBase = module.EffectBase;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3;
      cclegacy._RF.push({}, "4dd0e4qDG1PXZh+cEHXUaeh", "EffectMovingObject", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var EffectMovingObject = exports('EffectMovingObject', (_dec = ccclass('EffectMovingObject'), _dec2 = property(Sprite), _dec3 = property(Label), _dec4 = property(Node), _dec(_class = (_class2 = /*#__PURE__*/function (_EffectBase) {
        _inheritsLoose(EffectMovingObject, _EffectBase);
        function EffectMovingObject() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _EffectBase.call.apply(_EffectBase, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "sprtMain", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "lbMain", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "nodeFollow", _descriptor3, _assertThisInitialized(_this));
          _this.data = null;
          _this.movingValue = {
            value: 0
          };
          _this.tweenValue = null;
          _this.startPoint = null;
          _this.endPoint = null;
          _this.controlPoint1 = null;
          _this.controlPoint2 = null;
          _this.scaleTime = 0.05;
          _this.holdTime = 0.15;
          _this.movingTime = 0.23;
          _this.finalScale = 0.5;
          return _this;
        }
        var _proto = EffectMovingObject.prototype;
        _proto.onDisable = function onDisable() {
          var _this$tweenValue;
          (_this$tweenValue = this.tweenValue) == null || _this$tweenValue.stop();
        };
        _proto.init = function init(define, recycleMe, data) {
          var _this2 = this,
            _this$data$text,
            _this$data;
          _EffectBase.prototype.init.call(this, define, recycleMe, data);
          this.data = data;
          this.movingValue.value = 0;
          var setText = function setText(text, scaleValue) {
            if (scaleValue === void 0) {
              scaleValue = 1.0;
            }
            if (_this2.lbMain) {
              _this2.lbMain.string = text != null ? text : "";
              _this2.lbMain.node.scale = v3(scaleValue * 1.5, scaleValue * 1.5);
              tween(_this2.lbMain.node).to(0.2, {
                scale: v3(scaleValue, scaleValue)
              }).start();
            }
          };

          //inti uis
          if (this.sprtMain && this.data.spriteFrame) {
            this.sprtMain.spriteFrame = this.data.spriteFrame;
          }
          this.startPoint = this.node.worldPosition.clone();
          this.endPoint = this.data.destination.clone();
          //text effect 
          var _this$calculateContro = this.calculateControlPoints(this.startPoint, this.endPoint, randomRangeInt(100.0, 250.0) * (random() >= 0.5 ? 1.0 : -1.0));
          this.controlPoint1 = _this$calculateContro[0];
          this.controlPoint2 = _this$calculateContro[1];
          setText((_this$data$text = (_this$data = this.data) == null ? void 0 : _this$data.text) != null ? _this$data$text : "");
          if (this.data.text2) {
            this.scheduleOnce(function () {
              setText(_this2.data.text2, 1.5);
            }, this.scaleTime + this.holdTime / 2.0);
          }
          this.doEffectSpriteMain();
          this.doEffectMoving();
        };
        _proto.getTotalTime = function getTotalTime() {
          return this.scaleTime + this.holdTime + this.movingTime;
        };
        _proto.setActive = function setActive(isActive) {
          this.node.active = isActive;
          if (this.nodeFollow) {
            this.nodeFollow.active = false;
          }
        };
        _proto.setParentForFollowNode = function setParentForFollowNode(parent) {
          if (this.nodeFollow) {
            this.nodeFollow.parent = parent;
            this.nodeFollow.setSiblingIndex(99);
          }
        };
        _proto.doEffectSpriteMain = function doEffectSpriteMain() {
          //scale action
          //effect 
          this.node.scale = Vec3.ZERO;
          tween(this.node).to(this.scaleTime, {
            scale: v3(1.5, 1.5, 1.5)
          }, {
            easing: easing.backOut
          }).delay(this.holdTime).to(this.movingTime, {
            scale: v3(this.finalScale, this.finalScale, this.finalScale)
          }, {
            easing: easing.quartIn
          }).start();
        };
        _proto.doEffectFade = function doEffectFade() {
          // const beginColor = this.sprtMain.color.clone();
          // beginColor.a = 255.0;

          // const endColor = beginColor.clone();
          // endColor.a = 0.0;

          // this.sprtMain.color = beginColor;
          // tween(this.sprtMain)
          // .delay(this.holdTime + this.scaleTime)
          // .to(this.movingTime, { color: endColor }, { easing: easing.quartIn })
          // .start();
        };
        _proto.doEffectMoving = function doEffectMoving() {
          var _this3 = this;
          //moving action
          this.tweenValue = tween(this.movingValue).delay(this.scaleTime + this.holdTime) //wait scale value
          .call(function () {
            //enable follow if have
            if (_this3.nodeFollow) {
              _this3.nodeFollow.active = true;
            }
          }).to(this.movingTime, {
            value: 1
          }, {
            easing: easing.quartIn
          }).call(function () {
            _this3.movingValue.value = 1;
            _this3.tweenValue = null;
            _this3.data.onEnd == null || _this3.data.onEnd();
            _this3.putToPool();
          }).start();
        };
        _proto.update = function update(dt) {
          this.updatePosition();
        };
        _proto.updatePosition = function updatePosition() {
          if (!this.tweenValue) return;
          this.node.worldPosition = this.cubicBezierPoint(this.startPoint, this.controlPoint1, this.controlPoint2, this.endPoint, this.movingValue.value);
          if (this.nodeFollow) {
            this.nodeFollow.worldPosition = this.node.worldPosition;
          }
        };
        _proto.cubicBezierPoint = function cubicBezierPoint(startPoint, controlPoint1, controlPoint2, endPoint, t) {
          var u = 1 - t;
          var tt = t * t;
          var uu = u * u;
          var uuu = uu * u;
          var ttt = tt * t;
          var p = new Vec3();
          p.set(uuu * startPoint.x + 3 * uu * t * controlPoint1.x + 3 * u * tt * controlPoint2.x + ttt * endPoint.x, uuu * startPoint.y + 3 * uu * t * controlPoint1.y + 3 * u * tt * controlPoint2.y + ttt * endPoint.y, uuu * startPoint.z + 3 * uu * t * controlPoint1.z + 3 * u * tt * controlPoint2.z + ttt * endPoint.z);
          return p;
        };
        _proto.calculateControlPoints = function calculateControlPoints(startPoint, endPoint, factor) {
          // Calculate direction vector from start to end
          var direction = endPoint.clone().subtract(startPoint).normalize();
          var perpendicular = new Vec3(-direction.y, direction.x);
          // Calculate control points based on the direction
          var controlPoint1 = startPoint.clone().add(perpendicular.clone().multiplyScalar(factor));
          var controlPoint2 = endPoint.clone().add(perpendicular.clone().multiplyScalar(factor));
          return [controlPoint1, controlPoint2];
        };
        return EffectMovingObject;
      }(EffectBase), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "sprtMain", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "lbMain", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "nodeFollow", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/EffectMultiMovingObject.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './EffectBase.ts', './EffectMovingObject.ts', './audioManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, randomRange, Vec3, tween, v3, EffectBase, EffectMovingObject, AudioManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      randomRange = module.randomRange;
      Vec3 = module.Vec3;
      tween = module.tween;
      v3 = module.v3;
    }, function (module) {
      EffectBase = module.EffectBase;
    }, function (module) {
      EffectMovingObject = module.EffectMovingObject;
    }, function (module) {
      AudioManager = module.AudioManager;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "79538OeyiNCXKnP2hHWrfF9", "EffectMultiMovingObject", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var EffectMultiMovingObject = exports('EffectMultiMovingObject', (_dec = ccclass('EffectMultiMovingObject'), _dec2 = property([EffectMovingObject]), _dec(_class = (_class2 = /*#__PURE__*/function (_EffectBase) {
        _inheritsLoose(EffectMultiMovingObject, _EffectBase);
        function EffectMultiMovingObject() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _EffectBase.call.apply(_EffectBase, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "childs", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "soundEachEmitterReached", _descriptor2, _assertThisInitialized(_this));
          _this.data = null;
          _this.isInited = false;
          return _this;
        }
        var _proto = EffectMultiMovingObject.prototype;
        _proto.init = function init(define, recycleMe, data) {
          var _this2 = this;
          _EffectBase.prototype.init.call(this, define, recycleMe, data);
          this.data = data;
          if (!data.randomDuration) {
            data.randomDuration = 0.0;
          }
          if (!this.isInited) {
            this.isInited = true;
            if (this.childs.length <= 0) {
              this.childs = this.node.getComponentsInChildren(EffectMovingObject);
              this.childs.forEach(function (child) {
                return child.setParentForFollowNode(_this2.node);
              });
            }
          }
          var _loop = function _loop() {
            var isActive = i < data.number;
            var randomMovingTimeRatio = randomRange(0.3, 0.65);
            var randomScaleTimeRatio = randomRange(0.1, 0.3);
            var randomHoldTimeRatio = 1.0 - randomMovingTimeRatio - randomScaleTimeRatio;
            _this2.childs[i].setActive(isActive);
            if (isActive) {
              var childNode = _this2.childs[i];
              var duration = randomRange(data.duration - data.randomDuration, data.duration + data.randomDuration);
              childNode.movingTime = randomMovingTimeRatio * duration;
              childNode.scaleTime = randomScaleTimeRatio * duration;
              var holdTime = randomHoldTimeRatio * duration;
              childNode.holdTime = 0;
              if (data.spreadDistance <= 0) {
                childNode.movingTime += holdTime;
                childNode.movingTime += childNode.scaleTime;
                childNode.scaleTime = 0;
                holdTime = 0;
              }
              childNode.finalScale = 0.0;
              if (childNode.sprtMain) {
                childNode.sprtMain.node.active = true;
                if (_this2.data.isRandomRotation) {
                  childNode.sprtMain.node.angle = randomRange(0.0, 360.0);
                }
              }
              if (data.spriteFrame && childNode.sprtMain) {
                childNode.sprtMain.spriteFrame = data.spriteFrame;
              }

              //move random around 
              childNode.node.position = Vec3.ZERO;
              tween(childNode.node).to(holdTime, {
                position: v3(randomRange(-data.spreadDistance, data.spreadDistance), randomRange(-data.spreadDistance, data.spreadDistance))
              }).call(function () {
                //start moving for childs
                childNode.init("", null, {
                  onEnd: function onEnd() {
                    if (childNode.sprtMain) {
                      childNode.sprtMain.node.active = false;
                    }
                    data.onEachObject == null || data.onEachObject(childNode);
                    if (_this2.soundEachEmitterReached) {
                      AudioManager.instance.playSound(_this2.soundEachEmitterReached);
                    }
                  },
                  destination: data.end,
                  spriteFrame: data.spriteFrame,
                  text: "",
                  text2: ""
                });
              }).start();
            }
          };
          for (var i = 0; i < this.childs.length; i++) {
            _loop();
          }
          this.scheduleOnce(function () {
            data.onEnd == null || data.onEnd();
          }, data.duration + data.randomDuration);
          this.scheduleOnce(function () {
            _this2.putToPool();
          }, (data.duration + data.randomDuration) * 1.5);
        };
        return EffectMultiMovingObject;
      }(EffectBase), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "childs", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "soundEachEmitterReached", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return "";
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/EffectParticle.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './EffectBase.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, ParticleSystem, EffectBase;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      ParticleSystem = module.ParticleSystem;
    }, function (module) {
      EffectBase = module.EffectBase;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "52b3dLzk9pE2JwkxnQV/APT", "EffectParticle", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var EffectParticle = exports('EffectParticle', (_dec = ccclass('EffectParticle'), _dec2 = property(ParticleSystem), _dec(_class = (_class2 = /*#__PURE__*/function (_EffectBase) {
        _inheritsLoose(EffectParticle, _EffectBase);
        function EffectParticle() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _EffectBase.call.apply(_EffectBase, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "particleSystems", _descriptor, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = EffectParticle.prototype;
        _proto.init = function init(define, recycleMe, data) {
          var _this$particleSystems;
          _EffectBase.prototype.init.call(this, define, recycleMe, data);
          (_this$particleSystems = this.particleSystems) == null || _this$particleSystems.forEach(function (element) {
            element == null || element.play();
          });
        };
        _proto.stopParticle = function stopParticle(delayKill) {
          var _this$particleSystems2,
            _this2 = this;
          if (delayKill === void 0) {
            delayKill = 4;
          }
          (_this$particleSystems2 = this.particleSystems) == null || _this$particleSystems2.forEach(function (element) {
            element == null || element.stopEmitting();
          });
          this.scheduleOnce(function () {
            _this2.putToPool();
          }, delayKill);
        };
        return EffectParticle;
      }(EffectBase), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "particleSystems", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/EffectPoints.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './EffectBase.ts'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, Vec3, tween, v3, easing, EffectBase;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Vec3 = module.Vec3;
      tween = module.tween;
      v3 = module.v3;
      easing = module.easing;
    }, function (module) {
      EffectBase = module.EffectBase;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "c2301FhRClBM7qSV+ZoQLbZ", "EffectPoints", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var EffectMovingObject = exports('EffectMovingObject', (_dec = ccclass('EffectMovingObject'), _dec(_class = /*#__PURE__*/function (_EffectBase) {
        _inheritsLoose(EffectMovingObject, _EffectBase);
        function EffectMovingObject() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _EffectBase.call.apply(_EffectBase, [this].concat(args)) || this;
          _this.data = null;
          _this.movingValue = {
            value: 0
          };
          _this.tweenValue = null;
          _this.startPoint = null;
          _this.endPoint = null;
          _this.controlPoint1 = null;
          _this.controlPoint2 = null;
          return _this;
        }
        var _proto = EffectMovingObject.prototype;
        _proto.onDisable = function onDisable() {
          var _this$tweenValue;
          (_this$tweenValue = this.tweenValue) == null || _this$tweenValue.stop();
        };
        _proto.init = function init(define, recycleMe, data) {
          var _this2 = this;
          _EffectBase.prototype.init.call(this, define, recycleMe, data);
          this.data = data;
          this.startPoint = this.node.worldPosition.clone();
          this.endPoint = this.data.destination.clone();
          //effect 
          var _this$calculateContro = this.calculateControlPoints(this.startPoint, this.endPoint, 500.0);
          this.controlPoint1 = _this$calculateContro[0];
          this.controlPoint2 = _this$calculateContro[1];
          this.node.scale = Vec3.ZERO;
          var scaleTime = 0.25;
          var holdTime = 0.5;
          var movingTime = 0.75;

          //scale action
          tween(this.node).to(scaleTime, {
            scale: v3(1.5, 1.5, 1.5)
          }, {
            easing: easing.backOut
          }).delay(holdTime).to(movingTime, {
            scale: v3(0.5, 0.5, 0.5)
          }, {
            easing: easing.quartIn
          }).start();

          //moving action
          this.tweenValue = tween(this.movingValue).delay(scaleTime + holdTime) //wait scale value
          .to(movingTime, {
            value: 1
          }, {
            easing: easing.quartIn
          }).call(function () {
            _this2.movingValue.value = 1;
            _this2.tweenValue = null;
            _this2.data.onEnd == null || _this2.data.onEnd();
            _this2.putToPool();
          }).start();
        };
        _proto.update = function update(dt) {
          this.updatePosition();
        };
        _proto.updatePosition = function updatePosition() {
          if (!this.tweenValue) return;
          this.node.worldPosition = this.cubicBezierPoint(this.startPoint, this.controlPoint1, this.controlPoint2, this.endPoint, this.movingValue.value);
        };
        _proto.cubicBezierPoint = function cubicBezierPoint(startPoint, controlPoint1, controlPoint2, endPoint, t) {
          var u = 1 - t;
          var tt = t * t;
          var uu = u * u;
          var uuu = uu * u;
          var ttt = tt * t;
          var p = new Vec3();
          p.set(uuu * startPoint.x + 3 * uu * t * controlPoint1.x + 3 * u * tt * controlPoint2.x + ttt * endPoint.x, uuu * startPoint.y + 3 * uu * t * controlPoint1.y + 3 * u * tt * controlPoint2.y + ttt * endPoint.y, uuu * startPoint.z + 3 * uu * t * controlPoint1.z + 3 * u * tt * controlPoint2.z + ttt * endPoint.z);
          return p;
        };
        _proto.calculateControlPoints = function calculateControlPoints(startPoint, endPoint, factor) {
          // Calculate direction vector from start to end
          var direction = endPoint.clone().subtract(startPoint).normalize();
          var perpendicular = new Vec3(-direction.y, direction.x);
          // Calculate control points based on the direction
          var controlPoint1 = startPoint.clone().add(perpendicular.clone().multiplyScalar(factor));
          var controlPoint2 = endPoint.clone().add(perpendicular.clone().multiplyScalar(factor));
          return [controlPoint1, controlPoint2];
        };
        return EffectMovingObject;
      }(EffectBase)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/EffectText.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './EffectTime.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Label, UIOpacity, Color, v3, tween, Vec3, easing, EffectTime;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Label = module.Label;
      UIOpacity = module.UIOpacity;
      Color = module.Color;
      v3 = module.v3;
      tween = module.tween;
      Vec3 = module.Vec3;
      easing = module.easing;
    }, function (module) {
      EffectTime = module.EffectTime;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "4bb4ddfy3ZF7IT9EWgZoUId", "EffectText", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var EffectText = exports('EffectText', (_dec = ccclass('EffectText'), _dec2 = property(Label), _dec3 = property(UIOpacity), _dec(_class = (_class2 = /*#__PURE__*/function (_EffectTime) {
        _inheritsLoose(EffectText, _EffectTime);
        function EffectText() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _EffectTime.call.apply(_EffectTime, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "lbMain", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "opMain", _descriptor2, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = EffectText.prototype;
        _proto.init = function init(define, recycleMe, data) {
          _EffectTime.prototype.init.call(this, define, recycleMe, data);
          var text = data.text,
            color = data.color,
            time = data.time,
            size = data.size,
            distance = data.distance;

          //init values 
          this.lbMain.string = text != null ? text : "NULL";
          this.lbMain.color = color != null ? color : Color.WHITE;
          this.lbMain.fontSize = size != null ? size : 60;
          this.node.scale = v3(1.2, 1.2);
          this.opMain.opacity = 255;
          var animTime = time != null ? time : 0.5;
          var moveDistance = distance != null ? distance : 100.0;
          tween(this.node).to(animTime, {
            scale: Vec3.ONE
          }, {
            easing: easing.quadIn
          }).start();
          tween(this.node).by(animTime, {
            worldPosition: v3(0.0, moveDistance, 0.0)
          }, {
            easing: easing.quadIn
          }).start();
          tween(this.opMain).to(animTime, {
            opacity: 0
          }, {
            easing: easing.quartIn
          }).start();
        };
        return EffectText;
      }(EffectTime), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "lbMain", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "opMain", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/EffectTime.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './EffectBase.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, ParticleSystem, ParticleSystem2D, EffectBase;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      ParticleSystem = module.ParticleSystem;
      ParticleSystem2D = module.ParticleSystem2D;
    }, function (module) {
      EffectBase = module.EffectBase;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _descriptor3;
      cclegacy._RF.push({}, "b11edLPNrlIvrzI4yYh6uVF", "EffectTime", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var EffectTime = exports('EffectTime', (_dec = ccclass('EffectTime'), _dec2 = property(ParticleSystem), _dec3 = property([ParticleSystem2D]), _dec(_class = (_class2 = /*#__PURE__*/function (_EffectBase) {
        _inheritsLoose(EffectTime, _EffectBase);
        function EffectTime() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _EffectBase.call.apply(_EffectBase, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "delayKillTime", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "particleSystems", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "particleSystem2ds", _descriptor3, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = EffectTime.prototype;
        _proto.init = function init(define, recycleMe, data) {
          var _this$particleSystems,
            _this$particleSystem,
            _this2 = this;
          _EffectBase.prototype.init.call(this, define, recycleMe, data);
          (_this$particleSystems = this.particleSystems) == null || _this$particleSystems.forEach(function (element) {
            element == null || element.play();
          });
          (_this$particleSystem = this.particleSystem2ds) == null || _this$particleSystem.forEach(function (element) {
            element.resetSystem();
          });
          this.scheduleOnce(function () {
            _this2.putToPool();
          }, this.delayKillTime);
        };
        return EffectTime;
      }(EffectBase), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "delayKillTime", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "particleSystems", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "particleSystem2ds", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ellipse.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec2, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec2 = module.Vec2;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "71cb8o0v7xEvJDEaB1PCHhM", "ellipse", undefined);
      var Ellipse = exports('default', (_dec = register({
        menu: 'Procedural/Shape/Ellipse',
        title: 'Ellipse'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Ellipse, _ShaderNode);
        function Ellipse() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.depChunks = ['shape'];
          _this.data = {
            inputs: [slot('uv', Vec2.ZERO, 'vec2', 'vector'), slot('width', 0.5, 'float', 'vector'), slot('height', 0.5, 'float', 'vector')],
            outputs: [slot('Out', 0, 'float', 'vector')]
          };
          return _this;
        }
        var _proto = Ellipse.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          if (!this.inputs[0].connectSlot) {
            input0 = 'v_uv.xy';
          }
          var input1 = this.getInputValue(1);
          var input2 = this.getInputValue(2);
          var output0 = this.getOutputVarDefine(0);
          return output0 + " = Ellipse(" + input0 + ", " + input1 + ", " + input2 + ");";
        };
        return Ellipse;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/enum.ts", ['cc'], function (exports) {
  var cclegacy, Enum;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Enum = module.Enum;
    }],
    execute: function () {
      cclegacy._RF.push({}, "f34a2opKdlGHZC9qbc+L0O/", "enum", undefined);
      var Orientation = exports('Orientation', /*#__PURE__*/function (Orientation) {
        Orientation[Orientation["Vertical"] = 0] = "Vertical";
        Orientation[Orientation["Horizontal"] = 1] = "Horizontal";
        return Orientation;
      }({}));
      var MovementType = exports('MovementType', /*#__PURE__*/function (MovementType) {
        MovementType[MovementType["Unrestricted"] = 0] = "Unrestricted";
        MovementType[MovementType["Elastic"] = 1] = "Elastic";
        MovementType[MovementType["Clamped"] = 2] = "Clamped";
        return MovementType;
      }({}));
      var ArrangeAxis = exports('ArrangeAxis', /*#__PURE__*/function (ArrangeAxis) {
        ArrangeAxis[ArrangeAxis["Start"] = 0] = "Start";
        ArrangeAxis[ArrangeAxis["End"] = 1] = "End";
        return ArrangeAxis;
      }({}));
      var StretchDirection = exports('StretchDirection', /*#__PURE__*/function (StretchDirection) {
        StretchDirection[StretchDirection["Auto"] = 0] = "Auto";
        StretchDirection[StretchDirection["Header"] = 1] = "Header";
        StretchDirection[StretchDirection["Footer"] = 2] = "Footer";
        StretchDirection[StretchDirection["Center"] = 3] = "Center";
        return StretchDirection;
      }({}));
      var Layer = exports('Layer', /*#__PURE__*/function (Layer) {
        Layer[Layer["Lowest"] = 0] = "Lowest";
        Layer[Layer["Medium"] = 1] = "Medium";
        Layer[Layer["Highest"] = 2] = "Highest";
        return Layer;
      }({}));
      var WrapMode = exports('WrapMode', /*#__PURE__*/function (WrapMode) {
        WrapMode[WrapMode["Auto"] = 0] = "Auto";
        WrapMode[WrapMode["Wrap"] = 1] = "Wrap";
        WrapMode[WrapMode["Nowrap"] = 2] = "Nowrap";
        return WrapMode;
      }({}));
      var TouchMode = exports('TouchMode', /*#__PURE__*/function (TouchMode) {
        TouchMode[TouchMode["Auto"] = 0] = "Auto";
        TouchMode[TouchMode["AlwaysAllow"] = 1] = "AlwaysAllow";
        TouchMode[TouchMode["Disabled"] = 2] = "Disabled";
        return TouchMode;
      }({}));
      var MagneticDirection = exports('MagneticDirection', /*#__PURE__*/function (MagneticDirection) {
        MagneticDirection[MagneticDirection["Header"] = 0] = "Header";
        MagneticDirection[MagneticDirection["Footer"] = 1] = "Footer";
        return MagneticDirection;
      }({}));
      var ChildAlignment = exports('ChildAlignment', /*#__PURE__*/function (ChildAlignment) {
        ChildAlignment[ChildAlignment["UpperLeft"] = 0] = "UpperLeft";
        ChildAlignment[ChildAlignment["UpperCenter"] = 1] = "UpperCenter";
        ChildAlignment[ChildAlignment["UpperRight"] = 2] = "UpperRight";
        ChildAlignment[ChildAlignment["MiddleLeft"] = 3] = "MiddleLeft";
        ChildAlignment[ChildAlignment["MiddleCenter"] = 4] = "MiddleCenter";
        ChildAlignment[ChildAlignment["MiddleRight"] = 5] = "MiddleRight";
        ChildAlignment[ChildAlignment["LowerLeft"] = 6] = "LowerLeft";
        ChildAlignment[ChildAlignment["LowerCenter"] = 7] = "LowerCenter";
        ChildAlignment[ChildAlignment["LowerRight"] = 8] = "LowerRight";
        return ChildAlignment;
      }({}));
      var ScrollDirection = exports('ScrollDirection', /*#__PURE__*/function (ScrollDirection) {
        ScrollDirection[ScrollDirection["Up"] = 0] = "Up";
        ScrollDirection[ScrollDirection["Down"] = 1] = "Down";
        ScrollDirection[ScrollDirection["Left"] = 2] = "Left";
        ScrollDirection[ScrollDirection["Right"] = 3] = "Right";
        ScrollDirection[ScrollDirection["None"] = 4] = "None";
        return ScrollDirection;
      }({}));
      var ScrollbarDirection = exports('ScrollbarDirection', /*#__PURE__*/function (ScrollbarDirection) {
        ScrollbarDirection[ScrollbarDirection["Top_To_Bottom"] = 0] = "Top_To_Bottom";
        ScrollbarDirection[ScrollbarDirection["Bottom_To_Top"] = 1] = "Bottom_To_Top";
        ScrollbarDirection[ScrollbarDirection["Left_To_Right"] = 2] = "Left_To_Right";
        ScrollbarDirection[ScrollbarDirection["Right_To_Left"] = 3] = "Right_To_Left";
        return ScrollbarDirection;
      }({}));
      var NestedDirection = exports('NestedDirection', /*#__PURE__*/function (NestedDirection) {
        NestedDirection[NestedDirection["Both"] = 0] = "Both";
        NestedDirection[NestedDirection["Header"] = 1] = "Header";
        NestedDirection[NestedDirection["Footer"] = 2] = "Footer";
        return NestedDirection;
      }({}));
      var AlwaysScroll = exports('AlwaysScroll', /*#__PURE__*/function (AlwaysScroll) {
        AlwaysScroll[AlwaysScroll["Auto"] = 0] = "Auto";
        AlwaysScroll[AlwaysScroll["Header"] = 1] = "Header";
        AlwaysScroll[AlwaysScroll["Footer"] = 2] = "Footer";
        return AlwaysScroll;
      }({}));
      var IndicatorMode = exports('IndicatorMode', /*#__PURE__*/function (IndicatorMode) {
        IndicatorMode[IndicatorMode["Normal"] = 0] = "Normal";
        IndicatorMode[IndicatorMode["Button"] = 1] = "Button";
        return IndicatorMode;
      }({}));
      var Transition = exports('Transition', /*#__PURE__*/function (Transition) {
        Transition[Transition["None"] = 0] = "None";
        Transition[Transition["ColorTint"] = 1] = "ColorTint";
        Transition[Transition["SpriteSwap"] = 2] = "SpriteSwap";
        Transition[Transition["Scale"] = 3] = "Scale";
        return Transition;
      }({}));
      var ReleaseState = exports('ReleaseState', /*#__PURE__*/function (ReleaseState) {
        ReleaseState["IDLE"] = "IDLE";
        ReleaseState["PULL"] = "PULL";
        ReleaseState["WAIT"] = "WAIT";
        ReleaseState["RELEASE"] = "RELEASE";
        return ReleaseState;
      }({}));
      var HolderEvent = exports('HolderEvent', /*#__PURE__*/function (HolderEvent) {
        HolderEvent["CREATED"] = "ADAPTER:HOLDER:CREATED";
        HolderEvent["VISIBLE"] = "ADAPTER:HOLDER:VISIBLE";
        HolderEvent["DISABLE"] = "ADAPTER:HOLDER:DISABLE";
        return HolderEvent;
      }({}));
      var ViewEvent = exports('ViewEvent', /*#__PURE__*/function (ViewEvent) {
        ViewEvent["VISIBLE"] = "ADAPTER:VIEW:VISIBLE";
        ViewEvent["DISABLE"] = "ADAPTER::VIEW:DISABLE";
        return ViewEvent;
      }({}));
      Enum(Orientation);
      Enum(MovementType);
      Enum(ArrangeAxis);
      Enum(StretchDirection);
      Enum(MagneticDirection);
      Enum(ScrollbarDirection);
      Enum(ChildAlignment);
      Enum(TouchMode);
      Enum(IndicatorMode);
      Enum(Transition);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/EscHotkey.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ButtonHotKey.ts'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, KeyCode, ButtonHotKey;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      KeyCode = module.KeyCode;
    }, function (module) {
      ButtonHotKey = module.ButtonHotKey;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "2d53e8mnhxHI4l+waizfjCg", "EscHotkey", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var EscHotkey = exports('EscHotkey', (_dec = ccclass('EscHotkey'), _dec(_class = (_class2 = /*#__PURE__*/function (_ButtonHotKey) {
        _inheritsLoose(EscHotkey, _ButtonHotKey);
        function EscHotkey() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ButtonHotKey.call.apply(_ButtonHotKey, [this].concat(args)) || this;
          _this.index = 0;
          return _this;
        }
        var _proto = EscHotkey.prototype;
        _proto.onLoad = function onLoad() {
          this.keys = [KeyCode.ESCAPE]; //forse set to esc button
          _ButtonHotKey.prototype.onLoad.call(this);
        };
        _proto.onEnable = function onEnable() {
          EscHotkey.escIndex += 1;
          this.index = EscHotkey.escIndex;
          _ButtonHotKey.prototype.onEnable.call(this);
        };
        _proto.onDisable = function onDisable() {
          EscHotkey.escIndex -= 1;
          this.index = -1;
          _ButtonHotKey.prototype.onDisable.call(this);
        };
        _proto.trigger = function trigger() {
          if (EscHotkey.escIndex < 0) return;
          if (this.index != EscHotkey.escIndex) return;
          _ButtonHotKey.prototype.trigger.call(this);
        };
        return EscHotkey;
      }(ButtonHotKey), _class2.escIndex = -1, _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/exponential.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "5c4913KTCJGjqbcTxcC/UmQ", "exponential", undefined);
      var Exponential = exports('default', (_dec = register({
        menu: 'Math/Advanced/Exponential',
        title: 'Exponential'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Exponential, _ShaderNode);
        function Exponential() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Exponential.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = exp(" + input0 + ");\n        ";
        };
        return Exponential;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/FacialEmotionController.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createForOfIteratorHelperLoose, cclegacy, _decorator, SkinnedMeshRenderer, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createForOfIteratorHelperLoose = module.createForOfIteratorHelperLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      SkinnedMeshRenderer = module.SkinnedMeshRenderer;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "6e75aYdfoVM5bOfW6DB+f+a", "FacialEmotionController", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Predefined set of emotions that can be displayed on the face
       */
      var FacialEmotion = exports('FacialEmotion', /*#__PURE__*/function (FacialEmotion) {
        FacialEmotion["NEUTRAL"] = "neutral";
        FacialEmotion["HAPPY"] = "happy";
        FacialEmotion["SAD"] = "sad";
        FacialEmotion["ANGRY"] = "angry";
        FacialEmotion["SURPRISED"] = "surprised";
        FacialEmotion["FEAR"] = "fear";
        FacialEmotion["DISGUST"] = "disgust";
        return FacialEmotion;
      }({}));

      /**
       * Controls facial expressions using blend shapes (morph targets)
       */
      var FacialEmotionController = exports('FacialEmotionController', (_dec = ccclass('FacialEmotionController'), _dec2 = property({
        type: SkinnedMeshRenderer
      }), _dec3 = property({
        tooltip: 'Define emotions with blend shape weights'
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(FacialEmotionController, _Component);
        function FacialEmotionController() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // The skinned mesh renderer component that contains the blend shapes
          _initializerDefineProperty(_this, "faceRenderer", _descriptor, _assertThisInitialized(_this));
          // Mapping of emotion names to blend shape configurations
          // Each emotion can affect multiple blend shapes with different weights
          _initializerDefineProperty(_this, "emotions", _descriptor2, _assertThisInitialized(_this));
          // Current emotion being displayed
          _this.currentEmotion = FacialEmotion.NEUTRAL;
          // For smooth transitions between emotions
          _this.isTransitioning = false;
          _this.transitionTime = 0;
          _this.transitionDuration = 0.5;
          // seconds
          _this.fromWeights = new Map();
          _this.toWeights = new Map();
          _this.blendShapeNames = [];
          // Material for controlling blend shapes via shader properties
          _this.faceMaterial = null;
          return _this;
        }
        var _proto = FacialEmotionController.prototype;
        _proto.start = function start() {
          if (!this.faceRenderer) {
            console.error('Face renderer not assigned!');
            return;
          }

          // Get the material from the renderer
          if (this.faceRenderer.material) {
            this.faceMaterial = this.faceRenderer.material;
          }

          // Get all available blend shape names
          this.blendShapeNames = this.getBlendShapeNames();

          // Initialize with neutral expression
          this.setEmotion(FacialEmotion.NEUTRAL);
        }

        /**
         * Get all blend shape names from the mesh
         * Note: This is implementation-specific and may need to be adjusted
         * based on how your model's blend shapes are named
         */;
        _proto.getBlendShapeNames = function getBlendShapeNames() {
          // This is a placeholder - you'll need to implement this based on your model
          // In Cocos Creator, you might need to inspect the model asset or use a naming convention

          // Example: If your model has blend shapes like "Happy", "Sad", etc.
          return ['eyeBrowUp', 'eyeBrowDown', 'eyeClose', 'mouthOpen', 'mouthSmile', 'mouthFrown'];
        };
        _proto.update = function update(deltaTime) {
          // Handle smooth transitions between emotions
          if (this.isTransitioning && this.faceMaterial) {
            this.transitionTime += deltaTime;
            var t = Math.min(this.transitionTime / this.transitionDuration, 1.0);

            // Apply interpolated weights to each blend shape
            for (var _iterator = _createForOfIteratorHelperLoose(this.blendShapeNames), _step; !(_step = _iterator()).done;) {
              var name = _step.value;
              var fromWeight = this.fromWeights.get(name) || 0;
              var toWeight = this.toWeights.get(name) || 0;
              var weight = this.lerp(fromWeight, toWeight, this.easeInOutQuad(t));

              // Apply the weight to the blend shape
              this.applyBlendShapeWeight(name, weight);
            }
            if (this.transitionTime >= this.transitionDuration) {
              this.isTransitioning = false;
            }
          }
        }

        /**
         * Apply a weight to a specific blend shape
         * This is implementation-specific and depends on your model
         */;
        _proto.applyBlendShapeWeight = function applyBlendShapeWeight(name, weight) {
          if (!this.faceMaterial) return;

          // In Cocos Creator, blend shapes are typically controlled via shader properties
          // The exact property name depends on your shader setup
          var propertyName = "blendShape_" + name;

          // Set the blend shape weight as a shader property
          this.faceMaterial.setProperty(propertyName, weight);
        }

        /**
         * Set a facial emotion with an optional transition duration
         * @param emotion The emotion to display
         * @param transitionDuration Time in seconds to transition to this emotion (0 for instant)
         */;
        _proto.setEmotion = function setEmotion(emotion, transitionDuration) {
          if (transitionDuration === void 0) {
            transitionDuration = 0.5;
          }
          if (!this.faceMaterial) return;

          // Find the emotion configuration
          var emotionConfig = this.emotions.find(function (e) {
            return e.name === emotion;
          });
          if (!emotionConfig) {
            console.warn("Emotion \"" + emotion + "\" not found");
            return;
          }

          // Store current weights for transition
          if (transitionDuration > 0) {
            this.fromWeights.clear();

            // Store current weights of all blend shapes
            for (var _iterator2 = _createForOfIteratorHelperLoose(this.blendShapeNames), _step2; !(_step2 = _iterator2()).done;) {
              var name = _step2.value;
              // Get current weight
              var currentWeight = this.getCurrentBlendShapeWeight(name);
              this.fromWeights.set(name, currentWeight);
            }

            // Prepare target weights
            this.toWeights.clear();
            for (var _iterator3 = _createForOfIteratorHelperLoose(emotionConfig.blendShapes), _step3; !(_step3 = _iterator3()).done;) {
              var blendShape = _step3.value;
              this.toWeights.set(blendShape.name, blendShape.weight);
            }

            // Start transition
            this.isTransitioning = true;
            this.transitionTime = 0;
            this.transitionDuration = transitionDuration;
          } else {
            // Reset all blend shapes to 0
            for (var _iterator4 = _createForOfIteratorHelperLoose(this.blendShapeNames), _step4; !(_step4 = _iterator4()).done;) {
              var _name = _step4.value;
              this.applyBlendShapeWeight(_name, 0);
            }

            // Apply the new emotion immediately
            for (var _iterator5 = _createForOfIteratorHelperLoose(emotionConfig.blendShapes), _step5; !(_step5 = _iterator5()).done;) {
              var _blendShape = _step5.value;
              this.applyBlendShapeWeight(_blendShape.name, _blendShape.weight);
            }
          }
          this.currentEmotion = emotion;
        }

        /**
         * Get the current weight of a blend shape
         * This is implementation-specific and depends on your model
         */;
        _proto.getCurrentBlendShapeWeight = function getCurrentBlendShapeWeight(name) {
          if (!this.faceMaterial) return 0;

          // Get the blend shape weight from the shader property
          var propertyName = "blendShape_" + name;

          // Try to get the property value, default to 0 if not found
          try {
            var value = this.faceMaterial.getProperty(propertyName);
            return typeof value === 'number' ? value : 0;
          } catch (e) {
            return 0;
          }
        }

        /**
         * Get the current emotion
         */;
        _proto.getCurrentEmotion = function getCurrentEmotion() {
          return this.currentEmotion;
        }

        /**
         * Linear interpolation helper
         */;
        _proto.lerp = function lerp(a, b, t) {
          return a + (b - a) * t;
        }

        /**
         * Easing function for smoother transitions
         */;
        _proto.easeInOutQuad = function easeInOutQuad(t) {
          return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        };
        return FacialEmotionController;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "faceRenderer", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "emotions", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/FacialEmotionDemo.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './FacialEmotionController.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createForOfIteratorHelperLoose, cclegacy, _decorator, Node, Button, Vec3, Component, EventHandler, FacialEmotionController, FacialEmotion;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createForOfIteratorHelperLoose = module.createForOfIteratorHelperLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Button = module.Button;
      Vec3 = module.Vec3;
      Component = module.Component;
      EventHandler = module.EventHandler;
    }, function (module) {
      FacialEmotionController = module.FacialEmotionController;
      FacialEmotion = module.FacialEmotion;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _descriptor3;
      cclegacy._RF.push({}, "72db6UNpkhFOa4J9jHDXQ/n", "FacialEmotionDemo", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Demo script showing how to use the FacialEmotionController
       */
      var FacialEmotionDemo = exports('FacialEmotionDemo', (_dec = ccclass('FacialEmotionDemo'), _dec2 = property(FacialEmotionController), _dec3 = property(Node), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(FacialEmotionDemo, _Component);
        function FacialEmotionDemo() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "faceController", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "emotionButtonsContainer", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "transitionDuration", _descriptor3, _assertThisInitialized(_this));
          _this.emotionButtons = new Map();
          return _this;
        }
        var _proto = FacialEmotionDemo.prototype;
        _proto.start = function start() {
          if (!this.faceController) {
            console.error('Face controller not assigned!');
            return;
          }

          // Set up emotion buttons if container is provided
          if (this.emotionButtonsContainer) {
            this.setupEmotionButtons();
          }

          // Start with neutral expression
          this.setEmotion(FacialEmotion.NEUTRAL);
        }

        /**
         * Set up buttons for each emotion
         */;
        _proto.setupEmotionButtons = function setupEmotionButtons() {
          var _this2 = this;
          if (!this.emotionButtonsContainer) return;

          // Get all buttons in the container
          var buttons = this.emotionButtonsContainer.getComponentsInChildren(Button);

          // Set up click handlers for each button
          var _loop = function _loop() {
            var button = _step.value;
            var buttonName = button.node.name.toLowerCase();

            // Check if button name matches an emotion
            var emotions = [FacialEmotion.NEUTRAL, FacialEmotion.HAPPY, FacialEmotion.SAD, FacialEmotion.ANGRY, FacialEmotion.SURPRISED, FacialEmotion.FEAR, FacialEmotion.DISGUST];
            var matchingEmotion = emotions.find(function (emotion) {
              return buttonName.includes(emotion.toLowerCase());
            });
            if (matchingEmotion) {
              // Store the button for later reference
              _this2.emotionButtons.set(matchingEmotion, button);

              // Add click event handler
              var clickHandler = new EventHandler();
              clickHandler.target = _this2.node;
              clickHandler.component = 'FacialEmotionDemo';
              clickHandler.handler = 'onEmotionButtonClicked';
              clickHandler.customEventData = matchingEmotion;
              button.clickEvents.push(clickHandler);
            }
          };
          for (var _iterator = _createForOfIteratorHelperLoose(buttons), _step; !(_step = _iterator()).done;) {
            _loop();
          }
        }

        /**
         * Button click handler
         */;
        _proto.onEmotionButtonClicked = function onEmotionButtonClicked(event, customData) {
          this.setEmotion(customData);
        }

        /**
         * Set a facial emotion with transition
         */;
        _proto.setEmotion = function setEmotion(emotion) {
          if (!this.faceController) return;
          console.log("Setting emotion: " + emotion);
          this.faceController.setEmotion(emotion, this.transitionDuration);

          // Update button states (optional)
          this.updateButtonStates(emotion);
        }

        /**
         * Update button states to highlight the active emotion
         */;
        _proto.updateButtonStates = function updateButtonStates(activeEmotion) {
          this.emotionButtons.forEach(function (button, emotion) {
            // You can customize how buttons appear when active/inactive
            button.interactable = emotion !== activeEmotion;

            // You could also change colors, scale, etc.
            var scale = emotion === activeEmotion ? 1.2 : 1.0;
            button.node.setScale(new Vec3(scale, scale, scale));
          });
        }

        /**
         * Example of triggering emotions based on game events
         */;
        _proto.triggerEmotionBasedOnEvent = function triggerEmotionBasedOnEvent(eventType) {
          switch (eventType) {
            case 'victory':
              this.setEmotion(FacialEmotion.HAPPY);
              break;
            case 'defeat':
              this.setEmotion(FacialEmotion.SAD);
              break;
            case 'damage':
              this.setEmotion(FacialEmotion.ANGRY);
              break;
            case 'surprise':
              this.setEmotion(FacialEmotion.SURPRISED);
              break;
            case 'scary':
              this.setEmotion(FacialEmotion.FEAR);
              break;
            case 'disgust':
              this.setEmotion(FacialEmotion.DISGUST);
              break;
            default:
              this.setEmotion(FacialEmotion.NEUTRAL);
              break;
          }
        }

        /**
         * Example of a sequence of emotions
         */;
        _proto.playEmotionSequence = function playEmotionSequence() {
          var _this3 = this;
          var sequence = [{
            emotion: FacialEmotion.SURPRISED,
            duration: 1.0
          }, {
            emotion: FacialEmotion.HAPPY,
            duration: 2.0
          }, {
            emotion: FacialEmotion.NEUTRAL,
            duration: 1.0
          }];
          var delay = 0;
          sequence.forEach(function (item) {
            _this3.scheduleOnce(function () {
              _this3.setEmotion(item.emotion);
            }, delay);
            delay += item.duration;
          });
        };
        return FacialEmotionDemo;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "faceController", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "emotionButtonsContainer", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "transitionDuration", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.5;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/FeedbackManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Tile.ts', './AudioManager2.ts', './poolManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createForOfIteratorHelperLoose, _createClass, cclegacy, _decorator, Prefab, Animation, Node, ParticleSystem2D, Label, Camera, Color, UIOpacity, instantiate, Vec3, tween, easing, Component, HitRating, MagicTilesAudioManager, PoolManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createForOfIteratorHelperLoose = module.createForOfIteratorHelperLoose;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Prefab = module.Prefab;
      Animation = module.Animation;
      Node = module.Node;
      ParticleSystem2D = module.ParticleSystem2D;
      Label = module.Label;
      Camera = module.Camera;
      Color = module.Color;
      UIOpacity = module.UIOpacity;
      instantiate = module.instantiate;
      Vec3 = module.Vec3;
      tween = module.tween;
      easing = module.easing;
      Component = module.Component;
    }, function (module) {
      HitRating = module.HitRating;
    }, function (module) {
      MagicTilesAudioManager = module.MagicTilesAudioManager;
    }, function (module) {
      PoolManager = module.PoolManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _descriptor20, _descriptor21, _descriptor22;
      cclegacy._RF.push({}, "38482d0oyNDQos3rad3oDFt", "FeedbackManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      // Enum for feedback types
      var FeedbackType = /*#__PURE__*/function (FeedbackType) {
        FeedbackType[FeedbackType["PERFECT"] = 0] = "PERFECT";
        FeedbackType[FeedbackType["GREAT"] = 1] = "GREAT";
        FeedbackType[FeedbackType["COOL"] = 2] = "COOL";
        FeedbackType[FeedbackType["MISS"] = 3] = "MISS";
        return FeedbackType;
      }(FeedbackType || {});
      /**
       * FeedbackManager for Magic Tiles 3
       * Provides visual and auditory feedback for game events
       */
      var FeedbackManager = exports('FeedbackManager', (_dec = ccclass('FeedbackManager'), _dec2 = property(Prefab), _dec3 = property(Prefab), _dec4 = property(Prefab), _dec5 = property(Prefab), _dec6 = property(Animation), _dec7 = property({
        type: [Node],
        tooltip: "Feedback animation nodes in order: perfect, good, cool, miss"
      }), _dec8 = property(ParticleSystem2D), _dec9 = property(Label), _dec10 = property(Prefab), _dec11 = property(Node), _dec12 = property(Camera), _dec13 = property(Node), _dec14 = property([Number]), _dec15 = property(Prefab), _dec16 = property(Prefab), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(FeedbackManager, _Component);
        function FeedbackManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Prefabs for rating popups
          _initializerDefineProperty(_this, "perfectPrefab", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "greatPrefab", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "coolPrefab", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "missPrefab", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "animScoreFeedBacks", _descriptor5, _assertThisInitialized(_this));
          // Individual feedback nodes
          _initializerDefineProperty(_this, "feedbackNodes", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "particleSystemPerfectFragments", _descriptor7, _assertThisInitialized(_this));
          // Combo label
          _initializerDefineProperty(_this, "comboLabel", _descriptor8, _assertThisInitialized(_this));
          // Combo popup prefab
          _initializerDefineProperty(_this, "comboPopupPrefab", _descriptor9, _assertThisInitialized(_this));
          // Container for feedback elements
          _initializerDefineProperty(_this, "feedbackContainer", _descriptor10, _assertThisInitialized(_this));
          // Camera for effects
          _initializerDefineProperty(_this, "gameCamera", _descriptor11, _assertThisInitialized(_this));
          // Animation node for camera shake
          _initializerDefineProperty(_this, "cameraShakeNode", _descriptor12, _assertThisInitialized(_this));
          // Reference to the audio manager
          _this.audioManager = null;
          // Mapping of sound effects for ratings
          _initializerDefineProperty(_this, "perfectSoundEffect", _descriptor13, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "greatSoundEffect", _descriptor14, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "coolSoundEffect", _descriptor15, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "missSoundEffect", _descriptor16, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "comboSoundEffect", _descriptor17, _assertThisInitialized(_this));
          // Combo milestones for special feedback
          _initializerDefineProperty(_this, "comboMilestones", _descriptor18, _assertThisInitialized(_this));
          // Position offsets for lane feedback
          _this.lanePositions = [];
          // Settings for feedback elements
          _initializerDefineProperty(_this, "feedbackDuration", _descriptor19, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "feedbackScaleMultiplier", _descriptor20, _assertThisInitialized(_this));
          // Add properties for score popup and message prefabs
          _initializerDefineProperty(_this, "scorePopupPrefab", _descriptor21, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "messagePopupPrefab", _descriptor22, _assertThisInitialized(_this));
          _this.feedbackAnimNames = ["perfect", "great", "cool", "miss"];
          // Private variables for custom pooling
          _this._scorePopupPool = [];
          _this._messagePopupPool = [];
          _this._scorePopupTemplate = null;
          _this._messagePopupTemplate = null;
          _this._poolRoot = null;
          /**
           * Update the combo display
           * @param combo Current combo count
           */
          _this.comboTween = null;
          return _this;
        }
        var _proto = FeedbackManager.prototype;
        _proto.onLoad = function onLoad() {
          this.audioManager = MagicTilesAudioManager.instance;

          // Initialize the combo label
          if (this.comboLabel) {
            this.comboLabel.string = "";
            this.comboLabel.node.active = false;
          }

          // Create container if not provided
          if (!this.feedbackContainer) {
            this.feedbackContainer = new Node("FeedbackContainer");
            this.feedbackContainer.parent = this.node;
          }

          // Preload object pools for better performance
          if (this.perfectPrefab) {
            PoolManager.instance.preloadPool(this.perfectPrefab, 10);
          }
          if (this.greatPrefab) {
            PoolManager.instance.preloadPool(this.greatPrefab, 10);
          }
          if (this.coolPrefab) {
            PoolManager.instance.preloadPool(this.coolPrefab, 10);
          }
          if (this.missPrefab) {
            PoolManager.instance.preloadPool(this.missPrefab, 5);
          }
          if (this.comboPopupPrefab) {
            PoolManager.instance.preloadPool(this.comboPopupPrefab, 3);
          }

          // Create and preload score popup prefab if needed
          if (!this.scorePopupPrefab) {
            // Create a score popup prefab dynamically
            this.createScorePopupPrefab();
          } else {
            PoolManager.instance.preloadPool(this.scorePopupPrefab, 1);
          }

          // Create and preload message popup prefab if needed
          if (!this.messagePopupPrefab) {
            // Create a message popup prefab dynamically
            this.createMessagePopupPrefab();
          } else {
            PoolManager.instance.preloadPool(this.messagePopupPrefab, 1);
          }
        }

        /**
         * Create a score popup prefab dynamically if one isn't provided
         */;
        _proto.createScorePopupPrefab = function createScorePopupPrefab() {
          // Since we can't create actual prefabs at runtime, we'll use a node as a template
          // and implement our own simple pooling for these specific nodes

          // Create a template node that we'll clone
          var scoreNode = new Node("ScorePopup");

          // Add label component
          var label = scoreNode.addComponent(Label);
          label.fontSize = 36;
          label.color = new Color(255, 255, 100, 255);

          // Add opacity component
          scoreNode.addComponent(UIOpacity);

          // Create a parent node for our pool if not exists
          if (!this._poolRoot) {
            this._poolRoot = new Node("PoolContainer");
            this._poolRoot.parent = this.node;
            this._poolRoot.active = false;
          }

          // Create a pool for score popups
          if (!this._scorePopupPool) {
            this._scorePopupPool = [];
          }

          // Pre-instantiate some nodes
          for (var i = 0; i < 10; i++) {
            var node = instantiate(scoreNode);
            node.parent = this._poolRoot;
            node.active = false;
            this._scorePopupPool.push(node);
          }

          // Store the template
          this._scorePopupTemplate = scoreNode;
          // The template itself should be parented to our pool root but inactive
          scoreNode.parent = this._poolRoot;
          scoreNode.active = false;
        }

        /**
         * Create a message popup prefab dynamically if one isn't provided
         */;
        _proto.createMessagePopupPrefab = function createMessagePopupPrefab() {
          // Since we can't create actual prefabs at runtime, we'll use a node as a template
          // and implement our own simple pooling for these specific nodes

          // Create a template node that we'll clone
          var messageNode = new Node("Message");

          // Add label component
          var label = messageNode.addComponent(Label);
          label.fontSize = 48;
          label.color = new Color(255, 255, 255, 255);

          // Add opacity component
          messageNode.addComponent(UIOpacity);

          // Create a parent node for our pool if not exists
          if (!this._poolRoot) {
            this._poolRoot = new Node("PoolContainer");
            this._poolRoot.parent = this.node;
            this._poolRoot.active = false;
          }

          // Create a pool for message popups
          if (!this._messagePopupPool) {
            this._messagePopupPool = [];
          }

          // Pre-instantiate some nodes
          for (var i = 0; i < 3; i++) {
            var node = instantiate(messageNode);
            node.parent = this._poolRoot;
            node.active = false;
            this._messagePopupPool.push(node);
          }

          // Store the template
          this._messagePopupTemplate = messageNode;
          // The template itself should be parented to our pool root but inactive
          messageNode.parent = this._poolRoot;
          messageNode.active = false;
        }

        /**
         * Get a score popup node from our custom pool
         */;
        _proto.getScorePopupFromPool = function getScorePopupFromPool() {
          var node;
          if (this._scorePopupPool.length > 0) {
            // Get from pool
            node = this._scorePopupPool.pop();
          } else {
            // Create new if pool is empty
            node = instantiate(this._scorePopupTemplate);
          }
          node.active = true;
          return node;
        }

        /**
         * Return a score popup node to our custom pool
         */;
        _proto.putScorePopupToPool = function putScorePopupToPool(node) {
          if (!node) return;
          node.active = false;
          node.removeFromParent();
          this._scorePopupPool.push(node);
        }

        /**
         * Get a message popup node from our custom pool
         */;
        _proto.getMessagePopupFromPool = function getMessagePopupFromPool() {
          var node;
          if (this._messagePopupPool.length > 0) {
            // Get from pool
            node = this._messagePopupPool.pop();
          } else {
            // Create new if pool is empty
            node = instantiate(this._messagePopupTemplate);
          }
          node.active = true;
          return node;
        }

        /**
         * Return a message popup node to our custom pool
         */;
        _proto.putMessagePopupToPool = function putMessagePopupToPool(node) {
          if (!node) return;
          node.active = false;
          node.removeFromParent();
          this._messagePopupPool.push(node);
        }

        /**
         * Set the positions for each lane
         * @param positions Array of position vectors for each lane
         */;
        _proto.setLanePositions = function setLanePositions(positions) {
          this.lanePositions = positions;
        }

        /**
         * Show rating feedback at a specific lane
         * @param lane Lane index
         * @param rating Hit rating
         */;
        _proto.showRatingFeedback = function showRatingFeedback(lane, rating) {
          // Get the position for this lane
          var position = this.getLanePosition(lane);

          // Get the appropriate prefab based on rating
          var prefab = null;
          var soundEffect = "";
          switch (rating) {
            case HitRating.PERFECT:
              prefab = this.perfectPrefab;
              soundEffect = this.perfectSoundEffect;
              this.showFeedback(FeedbackType.PERFECT);
              this.particleSystemPerfectFragments.resetSystem();
              break;
            case HitRating.GREAT:
              prefab = this.greatPrefab;
              soundEffect = this.greatSoundEffect;
              this.showFeedback(FeedbackType.GREAT);
              break;
            case HitRating.COOL:
              prefab = this.coolPrefab;
              soundEffect = this.coolSoundEffect;
              this.showFeedback(FeedbackType.COOL);
              break;
            case HitRating.MISS:
              prefab = this.missPrefab;
              soundEffect = this.missSoundEffect;
              this.showFeedback(FeedbackType.MISS);
              break;
          }

          // Play sound effect
          if (soundEffect) {
            this.audioManager.playSound(soundEffect);
          }

          // Show visual feedback
          if (prefab) {
            this.showFeedbackPrefab(prefab, position);
          }
        }

        /**
         * Show a feedback prefab at a specific position
         */;
        _proto.showFeedbackPrefab = function showFeedbackPrefab(prefab, position) {
          // Get node from pool instead of instantiating
          var feedbackNode = PoolManager.instance.getNode(prefab, this.feedbackContainer);
          feedbackNode.position = position;

          // Set up animations
          var opacity = feedbackNode.getComponent(UIOpacity) || feedbackNode.addComponent(UIOpacity);
          opacity.opacity = 255;

          // Reset scale
          feedbackNode.scale = new Vec3(1, 1, 1);

          // Scale and fade animation
          tween(feedbackNode).to(this.feedbackDuration * 0.3, {
            scale: new Vec3(this.feedbackScaleMultiplier, this.feedbackScaleMultiplier, 1)
          }).to(this.feedbackDuration * 0.7, {
            position: new Vec3(position.x, position.y + 50, position.z)
          }).start();
          tween(opacity).delay(this.feedbackDuration * 0.3).to(this.feedbackDuration * 0.7, {
            opacity: 0
          }).call(function () {
            // Return to pool instead of destroying
            PoolManager.instance.putNode(feedbackNode);
          }).start();
        };
        _proto.updateCombo = function updateCombo(combo) {
          if (!this.comboLabel) return;

          // Update the combo label
          if (combo > 1) {
            this.comboLabel.string = "x" + combo;
            this.comboLabel.node.active = true;

            // Animate the combo label
            if (this.comboTween) {
              this.comboTween.stop();
            }
            this.comboLabel.node.scale = new Vec3(0.0, 0.0, 0.0);
            this.comboTween = tween(this.comboLabel.node).to(0.1, {
              scale: new Vec3(1.2, 1.2, 1)
            }).delay(0.5).to(0.35, {
              scale: Vec3.ZERO
            }, {
              easing: easing.backIn
            }).start();

            // Check for combo milestones
            if (this.isComboMilestone(combo)) {
              this.showComboMilestone(combo);
            }
          } else {
            this.comboLabel.string = "";
            this.comboLabel.node.active = false;
          }
        }

        /**
         * Check if a combo count is a milestone
         */;
        _proto.isComboMilestone = function isComboMilestone(combo) {
          return this.comboMilestones.indexOf(combo) >= 0;
        }

        /**
         * Show feedback for reaching a combo milestone
         */;
        _proto.showComboMilestone = function showComboMilestone(combo) {
          // Play combo sound
          this.audioManager.playSound(this.comboSoundEffect);

          // Show combo popup if available
          if (this.comboPopupPrefab) {
            // Get from pool instead of instantiating
            var popupNode = PoolManager.instance.getNode(this.comboPopupPrefab, this.feedbackContainer);

            // Position in the center of the screen
            popupNode.position = new Vec3(0, 0, 0);

            // Reset scale
            popupNode.scale = new Vec3(1, 1, 1);

            // Update label if present
            var label = popupNode.getComponentInChildren(Label);
            if (label) {
              label.string = combo + " COMBO!";
            }

            // Animate the popup
            tween(popupNode).to(0.2, {
              scale: new Vec3(1.5, 1.5, 1)
            }).to(0.2, {
              scale: new Vec3(1, 1, 1)
            }).delay(1).to(0.3, {
              position: new Vec3(0, 100, 0)
            }).call(function () {
              // Return to pool instead of destroying
              PoolManager.instance.putNode(popupNode);
            }).start();

            // Trigger camera shake effect
            this.shakeCamera(0.2, combo / 300); // Intensity increases with combo
          }
        }

        /**
         * Shake the camera
         * @param duration Duration of the shake in seconds
         * @param intensity Intensity of the shake (0-1)
         */;
        _proto.shakeCamera = function shakeCamera(duration, intensity) {
          if (intensity === void 0) {
            intensity = 0.5;
          }
          if (!this.gameCamera && !this.cameraShakeNode) return;

          // Use animation component if available
          if (this.cameraShakeNode) {
            var animation = this.cameraShakeNode.getComponent(Animation);
            if (animation) {
              animation.play();
              this.scheduleOnce(function () {
                animation.stop();
              }, duration);
              return;
            }
          }

          // Manual camera shake as fallback
          var targetNode = this.cameraShakeNode || this.gameCamera.node;
          var originalPosition = targetNode.position.clone();

          // Maximum shake offset
          var maxOffset = 10 * intensity;

          // Create a sequence of random positions
          var shakeCount = Math.floor(duration / 0.05);
          var shakeTween = tween(targetNode);
          for (var i = 0; i < shakeCount; i++) {
            var offsetX = (Math.random() * 2 - 1) * maxOffset;
            var offsetY = (Math.random() * 2 - 1) * maxOffset;
            shakeTween = shakeTween.to(0.05, {
              position: new Vec3(originalPosition.x + offsetX, originalPosition.y + offsetY, originalPosition.z)
            });
          }

          // Return to original position
          shakeTween.to(0.1, {
            position: originalPosition
          }).start();
        }

        /**
         * Show a score popup
         * @param score Score value
         * @param position Position to show the popup
         */;
        _proto.showScorePopup = function showScorePopup(score, position) {
          var _this2 = this;
          if (position === void 0) {
            position = new Vec3(0, 0, 0);
          }
          // Check if we have a prefab to use
          if (this.scorePopupPrefab) {
            // Get a node from the pool
            var scoreNode = PoolManager.instance.getNode(this.scorePopupPrefab, this.feedbackContainer);
            scoreNode.position = position;

            // Get the label component and update text
            var label = scoreNode.getComponent(Label);
            if (label) {
              label.string = "+" + score;
            }

            // Reset opacity
            var opacity = scoreNode.getComponent(UIOpacity);
            if (opacity) {
              opacity.opacity = 255;
            }

            // Animate the score popup
            tween(scoreNode).to(0.5, {
              position: new Vec3(position.x, position.y + 80, position.z)
            }).delay(0.2).to(0.3, {
              position: new Vec3(position.x, position.y + 120, position.z)
            }).call(function () {
              // Return to pool instead of destroying
              PoolManager.instance.putNode(scoreNode);
            }).start();
          } else if (this._scorePopupTemplate) {
            // Use our custom pool if prefab is not available but we have a template
            var _scoreNode = this.getScorePopupFromPool();
            _scoreNode.parent = this.feedbackContainer;
            _scoreNode.position = position;

            // Get the label component and update text
            var _label = _scoreNode.getComponent(Label);
            if (_label) {
              _label.string = "+" + score;
            }

            // Reset opacity
            var _opacity = _scoreNode.getComponent(UIOpacity);
            if (_opacity) {
              _opacity.opacity = 255;
            }

            // Animate the score popup
            tween(_scoreNode).to(0.5, {
              position: new Vec3(position.x, position.y + 80, position.z)
            }).delay(0.2).to(0.3, {
              position: new Vec3(position.x, position.y + 120, position.z)
            }).call(function () {
              // Return to our custom pool
              _this2.putScorePopupToPool(_scoreNode);
            }).start();
          } else {
            // Fallback to the old method if no prefab or template is available
            // Create a label node
            var _scoreNode2 = new Node("ScorePopup");
            _scoreNode2.parent = this.feedbackContainer;
            _scoreNode2.position = position;

            // Add label component
            var _label2 = _scoreNode2.getComponent(Label) || _scoreNode2.addComponent(Label);
            _label2.string = "+" + score;
            _label2.fontSize = 36;
            _label2.color = new Color(255, 255, 100, 255);

            // Animate the score popup
            tween(_scoreNode2).to(0.5, {
              position: new Vec3(position.x, position.y + 80, position.z)
            }).delay(0.2).to(0.3, {
              position: new Vec3(position.x, position.y + 120, position.z)
            }).call(function () {
              _scoreNode2.removeFromParent();
              _scoreNode2.destroy();
            }).start();
          }
        }

        /**
         * Get the position for a specific lane
         */;
        _proto.getLanePosition = function getLanePosition(lane) {
          if (lane >= 0 && lane < this.lanePositions.length) {
            return this.lanePositions[lane];
          }

          // Default position at the center
          return new Vec3(0, 0, 0);
        }

        /**
         * Show a message in the center of the screen
         * @param message Text to display
         * @param duration How long to show the message
         */;
        _proto.showMessage = function showMessage(message, duration, fontSize) {
          var _this3 = this;
          if (duration === void 0) {
            duration = 2.0;
          }
          if (fontSize === void 0) {
            fontSize = 80;
          }
          // Check if we have a prefab to use
          if (this.messagePopupPrefab) {
            // Get a node from the pool
            var messageNode = PoolManager.instance.getNode(this.messagePopupPrefab, this.feedbackContainer);
            messageNode.position = new Vec3(0, 0, 0);

            // Get the label component and update text
            var label = messageNode.getComponent(Label);
            if (label) {
              label.string = message;
              label.fontSize = fontSize;
              label.lineHeight = fontSize;
            }

            // Get opacity component
            var opacity = messageNode.getComponent(UIOpacity);
            if (opacity) {
              opacity.opacity = 0;

              // Fade in and out
              tween(opacity).to(0.3, {
                opacity: 255
              }).delay(duration - 0.6).to(0.3, {
                opacity: 0
              }).call(function () {
                // Return to pool instead of destroying
                PoolManager.instance.putNode(messageNode);
              }).start();
            }
          } else if (this._messagePopupTemplate) {
            // Use our custom pool if prefab is not available but we have a template
            var _messageNode = this.getMessagePopupFromPool();
            _messageNode.parent = this.feedbackContainer;
            _messageNode.position = new Vec3(0, 0, 0);

            // Get the label component and update text
            var _label3 = _messageNode.getComponent(Label);
            if (_label3) {
              _label3.string = message;
              _label3.fontSize = fontSize;
              _label3.lineHeight = fontSize;
            }

            // Get opacity component
            var _opacity2 = _messageNode.getComponent(UIOpacity);
            if (_opacity2) {
              _opacity2.opacity = 0;

              // Fade in and out
              tween(_opacity2).to(0.3, {
                opacity: 255
              }).delay(duration - 0.6).to(0.3, {
                opacity: 0
              }).call(function () {
                // Return to our custom pool
                _this3.putMessagePopupToPool(_messageNode);
              }).start();
            }
          } else {
            // Fallback to the old method if no prefab or template is available
            // Create a label node
            var _messageNode2 = new Node("Message");
            _messageNode2.parent = this.feedbackContainer;
            _messageNode2.position = new Vec3(0, 0, 0);

            // Add label component
            var _label4 = _messageNode2.getComponent(Label) || _messageNode2.addComponent(Label);
            _label4.string = message;
            _label4.fontSize = fontSize;
            _label4.color = new Color(255, 255, 255, 255);

            // Add opacity component for fade effect
            var _opacity3 = _messageNode2.getComponent(UIOpacity) || _messageNode2.addComponent(UIOpacity);
            _opacity3.opacity = 0;

            // Fade in and out
            tween(_opacity3).to(0.3, {
              opacity: 255
            }).delay(duration - 0.6).to(0.3, {
              opacity: 0
            }).call(function () {
              _messageNode2.removeFromParent();
              _messageNode2.destroy();
            }).start();
          }
        }

        /**
         * Play haptic feedback if available
         * @param intensity Intensity of the feedback (0-1)
         */;
        _proto.playHapticFeedback = function playHapticFeedback(intensity) {
          if (intensity === void 0) {
            intensity = 0.5;
          }
          // Check if vibration is available on the device
          if ('navigator' in globalThis && 'vibrate' in navigator) {
            // Duration based on intensity (10-100ms)
            var duration = Math.floor(10 + intensity * 90);
            navigator.vibrate(duration);
          }
        }

        // Replace any methods that use the individual nodes with the array access
        // For example, if there's a showPerfect method, it might look like:
        ;

        _proto.showFeedback = function showFeedback(type) {
          // Hide all feedback nodes first
          for (var _iterator = _createForOfIteratorHelperLoose(this.feedbackNodes), _step; !(_step = _iterator()).done;) {
            var node = _step.value;
            node.active = false;
          }

          // Show the requested feedback
          if (this.feedbackNodes[type]) {
            this.feedbackNodes[type].active = true;
            // Add any animation or other logic here
          }

          var animName = this.feedbackAnimNames[type];
          this.animScoreFeedBacks.play(animName);
        }

        // Then methods like showPerfect would become:
        ;

        _proto.showPerfect = function showPerfect() {
          this.showFeedback(FeedbackType.PERFECT);
        };
        _proto.showGood = function showGood() {
          this.showFeedback(FeedbackType.GREAT);
        };
        _proto.showCool = function showCool() {
          this.showFeedback(FeedbackType.COOL);
        };
        _proto.showMiss = function showMiss() {
          this.showFeedback(FeedbackType.MISS);
        }

        /**
         * Clean up all resources when component is destroyed
         */;
        _proto.onDestroy = function onDestroy() {
          // Clean up custom pools
          if (this._scorePopupPool) {
            this._scorePopupPool.forEach(function (node) {
              if (node && node.isValid) {
                node.destroy();
              }
            });
            this._scorePopupPool = [];
          }
          if (this._messagePopupPool) {
            this._messagePopupPool.forEach(function (node) {
              if (node && node.isValid) {
                node.destroy();
              }
            });
            this._messagePopupPool = [];
          }

          // Clean up templates
          if (this._scorePopupTemplate && this._scorePopupTemplate.isValid) {
            this._scorePopupTemplate.destroy();
            this._scorePopupTemplate = null;
          }
          if (this._messagePopupTemplate && this._messagePopupTemplate.isValid) {
            this._messagePopupTemplate.destroy();
            this._messagePopupTemplate = null;
          }

          // Clean up pool root
          if (this._poolRoot && this._poolRoot.isValid) {
            this._poolRoot.destroy();
            this._poolRoot = null;
          }
        };
        _createClass(FeedbackManager, [{
          key: "perfectAnimNode",
          get:
          // For backward compatibility and easier reference
          function get() {
            return this.feedbackNodes[0];
          }
        }, {
          key: "goodNode",
          get: function get() {
            return this.feedbackNodes[1];
          }
        }, {
          key: "coolNode",
          get: function get() {
            return this.feedbackNodes[2];
          }
        }, {
          key: "missNode",
          get: function get() {
            return this.feedbackNodes[3];
          }
        }]);
        return FeedbackManager;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "perfectPrefab", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "greatPrefab", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "coolPrefab", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "missPrefab", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "animScoreFeedBacks", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "feedbackNodes", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "particleSystemPerfectFragments", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "comboLabel", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "comboPopupPrefab", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "feedbackContainer", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "gameCamera", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "cameraShakeNode", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "perfectSoundEffect", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return "perfect";
        }
      }), _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, "greatSoundEffect", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return "good";
        }
      }), _descriptor15 = _applyDecoratedDescriptor(_class2.prototype, "coolSoundEffect", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return "ok";
        }
      }), _descriptor16 = _applyDecoratedDescriptor(_class2.prototype, "missSoundEffect", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return "miss";
        }
      }), _descriptor17 = _applyDecoratedDescriptor(_class2.prototype, "comboSoundEffect", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return "combo";
        }
      }), _descriptor18 = _applyDecoratedDescriptor(_class2.prototype, "comboMilestones", [_dec14], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [50, 100, 200, 300, 500];
        }
      }), _descriptor19 = _applyDecoratedDescriptor(_class2.prototype, "feedbackDuration", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.7;
        }
      }), _descriptor20 = _applyDecoratedDescriptor(_class2.prototype, "feedbackScaleMultiplier", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1.5;
        }
      }), _descriptor21 = _applyDecoratedDescriptor(_class2.prototype, "scorePopupPrefab", [_dec15], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor22 = _applyDecoratedDescriptor(_class2.prototype, "messagePopupPrefab", [_dec16], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/float.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "68e4bUVUSRHKo5B3bmMbsMV", "float", undefined);
      var Float = exports('default', (_dec = register({
        menu: 'Input/Basic/Float',
        title: 'Float'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Float, _ShaderNode);
        function Float() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.data = {
            inputs: [slot('In', 0, 'float', 'vector')],
            outputs: [slot('Out', 0, 'float', 'vector')]
          };
          return _this;
        }
        var _proto = Float.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = " + input0 + ";\n        ";
        };
        return Float;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/floor.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "ee049iD/ZRMAqYgcXswPl0X", "floor", undefined);
      var Floor = exports('default', (_dec = register({
        menu: 'Math/Round/Floor',
        title: 'Floor'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Floor, _ShaderNode);
        function Floor() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Floor.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = floor(" + input0 + ");\n        ";
        };
        return Floor;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/fraction.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "1be9a5SW39Pr7Ypuq6zuC9D", "fraction", undefined);
      var Fraction = exports('default', (_dec = register({
        menu: 'Math/Range/Fraction',
        title: 'Fraction'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Fraction, _ShaderNode);
        function Fraction() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Fraction.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = fract(" + input0 + ");\n        ";
        };
        return Fraction;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/fresnel.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec3, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec3 = module.Vec3;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "861c8JYxalKB66ptbnD6WdM", "fresnel", undefined);
      var Fresnel = exports('default', (_dec = register({
        menu: 'Math/Vector/Fresnel',
        title: 'Fresnel'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Fresnel, _ShaderNode);
        function Fresnel() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.data = {
            inputs: [slot('Normal', Vec3.ZERO, 'vec3', 'vector'), slot('ViewDir', Vec3.ZERO, 'vec3', 'vector'), slot('Power', 0, 'float', 'vector')],
            outputs: [slot('Out', 0, 'float', 'vector')]
          };
          return _this;
        }
        var _proto = Fresnel.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var input2 = this.getInputValue(2);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = pow((1.0 - saturate(dot(normalize(" + input0 + "), normalize(" + input1 + ")))), " + input2 + ");\n        ";
        };
        return Fresnel;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/GameEnviromentSetter.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Constants.ts', './APIManager.ts', './PopupBase.ts', './audioManager.ts', './uiManager.ts', './EffectController.ts', './SceneDefine.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Node, Sprite, Label, director, Component, setEnvi, CurrentEnviroment, setFakeData, setAPIManagerURL, PopupBase, AudioManager, UIManager, EffectController, SCENE_NAME;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Sprite = module.Sprite;
      Label = module.Label;
      director = module.director;
      Component = module.Component;
    }, function (module) {
      setEnvi = module.setEnvi;
      CurrentEnviroment = module.CurrentEnviroment;
    }, function (module) {
      setFakeData = module.setFakeData;
      setAPIManagerURL = module.setAPIManagerURL;
    }, function (module) {
      PopupBase = module.PopupBase;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      EffectController = module.EffectController;
    }, function (module) {
      SCENE_NAME = module.SCENE_NAME;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7;
      cclegacy._RF.push({}, "58916U7dudCXZ4FreIgnM5F", "GameEnviromentSetter", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var GameEnviromentSetter = exports('GameEnviromentSetter', (_dec = ccclass('GameEnviromentSetter'), _dec2 = property(Node), _dec3 = property(Sprite), _dec4 = property(PopupBase), _dec5 = property(Label), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(GameEnviromentSetter, _Component);
        function GameEnviromentSetter() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "API", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "LOG", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "FAKEDATA", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "sckContainer", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "sprtProcessBar", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "popupError", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "lbError", _descriptor7, _assertThisInitialized(_this));
          _this.sceneName = SCENE_NAME.HOME;
          _this.retryCount = 0;
          return _this;
        }
        var _proto = GameEnviromentSetter.prototype;
        _proto.onLoad = function onLoad() {
          {
            this.LOG = true;
            // this.sceneName = GameConstant.SCENE_NAME.BATTLE_SHIP;//test battle ship
            if (this.FAKEDATA) {
              setFakeData();
            }
          }
          setEnvi({
            API: this.API,
            LOG: this.LOG
          });

          //set secrect key 

          // let keyLabels = this.sckContainer.getComponentsInChildren(Label);
          // const encryptedData = keyLabels.shift().string;
          // const key = keyLabels.map(lb => lb.string).join("");

          // const CryptoJS: any = window["CryptoJS"];
          // var bytes = CryptoJS.AES.decrypt(encryptedData, key);
          // var original = bytes.toString(CryptoJS.enc.Utf8);
          // setKeyAuthen(original);

          // const converKey = "uqZLF8HAR467TdHcHoWkIkCOy89xlPV9";
          // const decryptedKey = CryptoJS.AES.encrypt(converKey, "631DB").toString();
          this.init();
          this.initGameProcess();
        }

        //#region process 
        ;

        _proto.init = function init() {
          setAPIManagerURL(CurrentEnviroment.API);
        };
        _proto.initGameProcess = function initGameProcess() {
          var _this2 = this;
          Promise.all([this.step_ProcessData(), this.step_ProcessPreloadSceneAssets()]).then(function (results) {
            _this2.loadGame();
          })["catch"](function (error) {
            _this2.showError(error);
          });
        };
        _proto.retry = function retry() {
          if (++this.retryCount > 3) {
            this.lbError.string = "Please try again later!";
            return;
          }
          this.popupError.doHide();
          this.initGameProcess();
        };
        _proto.showError = function showError(errorMessage) {
          this.lbError.string = errorMessage;
          this.popupError.doShow();
        };
        _proto.step_ProcessData = function step_ProcessData() {
          var _this3 = this;
          return new Promise(function (resolve, reject) {
            _this3.step_initManagers().then(function (res) {
              resolve("success");
            })["catch"](function (error) {
              reject(error);
            });
          });
        };
        _proto.step_initManagers = function step_initManagers() {
          return new Promise(function (resolve, rejet) {
            AudioManager.instance = new AudioManager();
            UIManager.instance = new UIManager();
            EffectController.instance = new EffectController();
            resolve("success");
          });
        };
        _proto.step_ProcessPreloadSceneAssets = function step_ProcessPreloadSceneAssets() {
          return new Promise(function (resolve, reject) {
            {
              resolve("done load scene");
              return;
            }
          });
        };
        _proto.loadGame = function loadGame() {
          var _this5 = this;
          this.sprtProcessBar.fillRange = 1.0;
          if (CurrentEnviroment.LOG) console.log("doneLoadAssets");
          director.loadScene(this.sceneName, function () {
            if (CurrentEnviroment.LOG) console.log("Scene " + _this5.sceneName + " loaded successfully");
          });
        }

        //#region callbacks
        ;

        _proto.onTouch_Retry = function onTouch_Retry() {
          this.retry();
        }

        //#endregion
        //#endregion
        ;

        return GameEnviromentSetter;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "API", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return "";
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "LOG", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "FAKEDATA", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "sckContainer", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "sprtProcessBar", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "popupError", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "lbError", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/GameManager.ts", ['cc', './Constants.ts'], function (exports) {
  var cclegacy, game, Game, CurrentEnviroment;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      game = module.game;
      Game = module.Game;
    }, function (module) {
      CurrentEnviroment = module.CurrentEnviroment;
    }],
    execute: function () {
      cclegacy._RF.push({}, "399f2AVXt9B5ozV4m+hAt4r", "GameManager", undefined);
      var GameManager = exports('GameManager', /*#__PURE__*/function () {
        function GameManager() {
          //#endregion
          //#region init data
          this.userInfo = null;
          this.isNeedToReload = false;
          this.isShouldSync = true;
          this.initGameEvents();
        }

        //#region listeners
        var _proto = GameManager.prototype;
        _proto.initGameEvents = function initGameEvents() {
          game.on(Game.EVENT_HIDE, function () {
            if (CurrentEnviroment.LOG) console.log("GameManager: on game hided");
          });
        };
        _proto.setUserInfo = function setUserInfo(userInfo) {
          this.userInfo = userInfo;
          this.isNeedToReload = false;
          this.isShouldSync = true;
        }

        //#endregion
        ;

        return GameManager;
      }());
      GameManager.instance = null;
      GameManager.instance = new GameManager();
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/GameplayManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AudioManager2.ts', './BeatmapManager.ts', './TileManager.ts', './InputManager.ts', './FeedbackManager.ts', './TapValidator.ts', './ScoreManager.ts', './Tile.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _asyncToGenerator, _regeneratorRuntime, cclegacy, _decorator, Toggle, Component, MagicTilesAudioManager, BeatmapManager, TileManager, InputManager, FeedbackManager, TapValidator, ScoreManager, HitRating;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _asyncToGenerator = module.asyncToGenerator;
      _regeneratorRuntime = module.regeneratorRuntime;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Toggle = module.Toggle;
      Component = module.Component;
    }, function (module) {
      MagicTilesAudioManager = module.MagicTilesAudioManager;
    }, function (module) {
      BeatmapManager = module.BeatmapManager;
    }, function (module) {
      TileManager = module.TileManager;
    }, function (module) {
      InputManager = module.InputManager;
    }, function (module) {
      FeedbackManager = module.FeedbackManager;
    }, function (module) {
      TapValidator = module.TapValidator;
    }, function (module) {
      ScoreManager = module.ScoreManager;
    }, function (module) {
      HitRating = module.HitRating;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12;
      cclegacy._RF.push({}, "54bffb59LVEi6v9WbidyqIN", "GameplayManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      // Define possible game states
      var GameState = exports('GameState', /*#__PURE__*/function (GameState) {
        GameState[GameState["NONE"] = 0] = "NONE";
        GameState[GameState["LOADING"] = 1] = "LOADING";
        GameState[GameState["WAITING_FOR_START"] = 2] = "WAITING_FOR_START";
        GameState[GameState["PLAYING"] = 3] = "PLAYING";
        GameState[GameState["PAUSED"] = 4] = "PAUSED";
        GameState[GameState["COMPLETED"] = 5] = "COMPLETED";
        GameState[GameState["FAILED"] = 6] = "FAILED";
        return GameState;
      }({}));

      /**
       * GameplayManager for Magic Tiles 3
       * Coordinates gameplay systems and manages game flow
       */
      var GameplayManager = exports('GameplayManager', (_dec = ccclass('GameplayManager'), _dec2 = property(TileManager), _dec3 = property(InputManager), _dec4 = property(FeedbackManager), _dec5 = property(TapValidator), _dec6 = property(ScoreManager), _dec7 = property(Toggle), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(GameplayManager, _Component);
        function GameplayManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Current game state
          _this.gameState = GameState.NONE;
          _initializerDefineProperty(_this, "tileManager", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "inputManager", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "feedbackManager", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "tapValidator", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "scoreManager", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "toggleAutoPlay", _descriptor6, _assertThisInitialized(_this));
          // Game settings
          _initializerDefineProperty(_this, "countdownDuration", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "minSurvivalHP", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "maxSurvivalHP", _descriptor9, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "missHPPenalty", _descriptor10, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "badHitHPPenalty", _descriptor11, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "perfectHPRecovery", _descriptor12, _assertThisInitialized(_this));
          // Current data
          _this.survivalHP = 100;
          _this.currentBeatmapId = "";
          _this.elapsedTime = 0;
          _this.notesPassed = 0;
          _this.totalNotes = 0;
          _this.autoPlay = false;
          _this.isPaused = false;
          // Callbacks
          _this.onGameStateChangedCallback = null;
          _this.onSurvivalHPChangedCallback = null;
          _this.audioManager = null;
          _this.beatmapManager = null;
          return _this;
        }
        var _proto = GameplayManager.prototype;
        _proto.onLoad = function onLoad() {
          // Initialize references if not set in the inspector
          if (!this.audioManager) {
            this.audioManager = MagicTilesAudioManager.instance;
          }
          if (!this.beatmapManager) {
            this.beatmapManager = BeatmapManager.instance;
          }

          // Register callback for ratings to update HP
          if (this.tapValidator) {
            this.tapValidator.onRating(this.onRatingEvent.bind(this));
          }

          //test play sample song 
          // this.LoadBeatMap("DauCoLoiLam_ATVNCG_bestcut");
          // this.LoadBeatMap("Perfect_EdSheeran_demo");
        }

        /**
         * Start loading a beatmap
         * @param beatmapId ID of the beatmap to load
         */;
        _proto.LoadBeatMap = /*#__PURE__*/
        function () {
          var _LoadBeatMap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(beatmapId) {
            var beatmap, audioLoaded, beatmapUpdated;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  // Reset states 
                  this.resetGameState();

                  // Set current beatmap ID
                  this.currentBeatmapId = beatmapId;

                  // Change to loading state
                  this.setGameState(GameState.LOADING);
                  _context.prev = 3;
                  _context.next = 6;
                  return this.beatmapManager.loadBeatmapInfo(beatmapId);
                case 6:
                  beatmap = _context.sent;
                  if (beatmap) {
                    _context.next = 10;
                    break;
                  }
                  console.error("Failed to load beatmap: " + beatmapId);
                  return _context.abrupt("return", false);
                case 10:
                  _context.next = 12;
                  return this.beatmapManager.loadBeatmapAudioData();
                case 12:
                  audioLoaded = _context.sent;
                  if (audioLoaded) {
                    _context.next = 16;
                    break;
                  }
                  console.error("Failed to load beatmap audio");
                  return _context.abrupt("return", false);
                case 16:
                  //update notes if not exist
                  if (beatmap.notes == null || beatmap.notes.length == 0) {
                    beatmapUpdated = this.beatmapManager.updateNotes(beatmapId, audioLoaded.trackInfo.notes);
                    this.totalNotes = beatmapUpdated.notes.length;
                  } else {
                    this.totalNotes = beatmap.notes.length;
                  }
                  this.tileManager.initGame();
                  // Create beginning tile and wait for user tap
                  this.createBeginningTile();
                  return _context.abrupt("return", true);
                case 22:
                  _context.prev = 22;
                  _context.t0 = _context["catch"](3);
                  console.error("Error starting game:", _context.t0);
                  return _context.abrupt("return", false);
                case 26:
                case "end":
                  return _context.stop();
              }
            }, _callee, this, [[3, 22]]);
          }));
          function LoadBeatMap(_x) {
            return _LoadBeatMap.apply(this, arguments);
          }
          return LoadBeatMap;
        }()
        /**
         * Start actual gameplay after the beginning tile is tapped
         */;

        _proto.startPlaying = function startPlaying() {
          this.setAutoPlay(this.toggleAutoPlay.isChecked);

          // Reset managers
          this.tapValidator.resetCombo();
          this.scoreManager.resetScore();
          this.scoreManager.startTracking();

          // Enable input
          this.inputManager.setEnabled(true);

          // Start the tile manager
          this.tileManager.startGame();

          // Play the beatmap audio
          this.audioManager.playBeatmapAudio();

          // Set game state
          this.setGameState(GameState.PLAYING);

          // Start update loop
          this.schedule(this.gameUpdate, 0);
        }

        /**
         * Pause the game
         */;
        _proto.pauseGame = function pauseGame() {
          if (this.gameState !== GameState.PLAYING) return;

          // Pause audio
          this.audioManager.pauseBeatmapAudio();

          // Pause tile manager
          this.tileManager.pauseGame();

          // Disable input
          this.inputManager.setEnabled(false);

          // Pause score tracking
          this.scoreManager.pauseTracking();

          // Set paused flag and game state
          this.isPaused = true;
          this.setGameState(GameState.PAUSED);

          // Unschedule update
          this.unschedule(this.gameUpdate);
        }

        /**
         * Resume the game from pause
         */;
        _proto.resumeGame = function resumeGame() {
          if (this.gameState !== GameState.PAUSED) return;

          // Resume audio
          this.audioManager.resumeBeatmapAudio();

          // Resume tile manager
          this.tileManager.resumeGame();

          // Enable input
          this.inputManager.setEnabled(true);

          // Resume score tracking
          this.scoreManager.resumeTracking();

          // Reset paused flag and game state
          this.isPaused = false;
          this.setGameState(GameState.PLAYING);

          // Schedule update
          this.schedule(this.gameUpdate, 0);
        }

        /**
         * Update method called every frame during gameplay
         */;
        _proto.gameUpdate = function gameUpdate(dt) {
          // Update elapsed time
          this.elapsedTime += dt;

          // Sync game time with audio
          if (this.audioManager.isPlaying()) {
            var audioTime = this.audioManager.getCurrentTime();
            this.tileManager.setGameTime(audioTime);
          }

          // Check for auto-fail condition (HP too low)
          if (this.survivalHP <= 0) {
            this.failGame();
            return;
          }

          // Check for completion condition (reached the end of the song)
          if (this.notesPassed >= this.totalNotes && this.tileManager.getActiveTileCount() === 0) {
            this.completeGame();
            return;
          }
        }

        /**
         * Handle a rating event from the tap validator
         */;
        _proto.onRatingEvent = function onRatingEvent(lane, rating) {
          this.feedbackManager.showRatingFeedback(lane, rating);
          this.feedbackManager.updateCombo(this.tapValidator.getCombo());
          // Count the note
          this.notesPassed++;

          // Update HP based on rating
          switch (rating) {
            case HitRating.PERFECT:
              this.changeSurvivalHP(this.perfectHPRecovery);
              break;
            case HitRating.GREAT:
              // No HP change for GOOD hits
              break;
            case HitRating.COOL:
              this.changeSurvivalHP(-this.badHitHPPenalty);
              break;
            case HitRating.MISS:
              this.changeSurvivalHP(-this.missHPPenalty);
              break;
          }
        }

        /**
         * Change the survival HP and notify listeners
         */;
        _proto.changeSurvivalHP = function changeSurvivalHP(amount) {
          this.survivalHP = Math.max(0, Math.min(this.maxSurvivalHP, this.survivalHP + amount));

          // Notify listeners
          if (this.onSurvivalHPChangedCallback) {
            this.onSurvivalHPChangedCallback(this.survivalHP);
          }
        }

        /**
         * Complete the game (successfully finished)
         */;
        _proto.completeGame = function completeGame() {
          // Stop the gameplay
          this.stopGameplay();

          // Set game state
          this.setGameState(GameState.COMPLETED);

          // Show completion message
          this.feedbackManager.showMessage("LEVEL COMPLETE!");

          // Submit final score
          var finalScore = this.scoreManager.getFinalScore();
          var accuracy = this.tapValidator.getAccuracy();
          var maxCombo = this.tapValidator.getMaxCombo();
          console.log("Game completed! Score: " + finalScore + ", Accuracy: " + accuracy + "%, Max Combo: " + maxCombo);

          // Show score screen after a delay
          this.scheduleOnce(function () {
            // This would typically transition to a results screen
            console.log("Show results screen");
          }, 2);
        }

        /**
         * Fail the game (HP reached 0)
         */;
        _proto.failGame = function failGame() {
          // Stop the gameplay
          this.stopGameplay();

          // Set game state
          this.setGameState(GameState.FAILED);

          // Show failure message
          this.feedbackManager.showMessage("GAME OVER");

          // Camera shake effect
          this.feedbackManager.shakeCamera(0.3, 0.8);

          // Show retry screen after a delay
          this.scheduleOnce(function () {
            // This would typically transition to a retry/fail screen
            console.log("Show fail screen");
          }, 2);
        }

        /**
         * Stop all gameplay systems
         */;
        _proto.stopGameplay = function stopGameplay() {
          // Stop audio
          this.audioManager.stopBeatmapAudio();

          // Stop tile manager
          this.tileManager.stopGame();

          // Disable input
          this.inputManager.setEnabled(false);

          // Stop score tracking
          this.scoreManager.stopTracking();

          // Unschedule update
          this.unschedule(this.gameUpdate);
        }

        /**
         * Reset the game state to defaults
         */;
        _proto.resetGameState = function resetGameState() {
          this.gameState = GameState.NONE;
          this.survivalHP = this.maxSurvivalHP;
          this.elapsedTime = 0;
          this.notesPassed = 0;
          this.totalNotes = 0;
          this.isPaused = false;
        }

        /**
         * Set the game state and notify listeners
         */;
        _proto.setGameState = function setGameState(newState) {
          this.gameState = newState;

          // Notify listeners
          if (this.onGameStateChangedCallback) {
            this.onGameStateChangedCallback(newState);
          }
        }

        /**
         * Register a callback for game state changes
         */;
        _proto.onGameStateChanged = function onGameStateChanged(callback) {
          this.onGameStateChangedCallback = callback;
        }

        /**
         * Register a callback for survival HP changes
         */;
        _proto.onSurvivalHPChanged = function onSurvivalHPChanged(callback) {
          this.onSurvivalHPChangedCallback = callback;
        }

        /**
         * Get the current game state
         */;
        _proto.getGameState = function getGameState() {
          return this.gameState;
        }

        /**
         * Get the current survival HP
         */;
        _proto.getSurvivalHP = function getSurvivalHP() {
          return this.survivalHP;
        }

        /**
         * Get the progress through the song (0-1)
         */;
        _proto.getProgress = function getProgress() {
          if (this.totalNotes === 0) return 0;
          return this.notesPassed / this.totalNotes;
        }

        /**
         * Enable/disable auto-play mode
         */;
        _proto.setAutoPlay = function setAutoPlay(enable) {
          this.autoPlay = enable;
          this.tileManager.toggleAutoplay(enable);
        }

        /**
         * Check if auto-play is enabled
         */;
        _proto.isAutoPlayEnabled = function isAutoPlayEnabled() {
          return this.autoPlay;
        }

        /**
         * Toggle the game pause state
         */;
        _proto.togglePause = function togglePause() {
          if (this.isPaused) {
            this.resumeGame();
          } else {
            this.pauseGame();
          }
        }

        /**
         * Restart the current beatmap
         */;
        _proto.restartGame = function restartGame() {
          if (this.currentBeatmapId) {
            this.LoadBeatMap(this.currentBeatmapId);
          }
        }

        /**
         * Exit the current game and return to menu
         */;
        _proto.exitGame = function exitGame() {
          // Stop gameplay
          this.stopGameplay();

          // Reset state
          this.resetGameState();

          // This would typically transition to the menu scene
          console.log("Exit to menu");
        }

        /**
         * Create a beginning tile that the player must tap to start the game
         */;
        _proto.createBeginningTile = function createBeginningTile() {
          // Change to waiting state
          this.setGameState(GameState.WAITING_FOR_START);

          // Show message to tap to start
          this.feedbackManager.showMessage("Tap to Start", 0, 140);

          // Initialize the tileManager with a minimal setup to just show the beginning tile
          if (this.tileManager) {
            // Set up tileManager to show the beginning tile but not start the full song
            this.tileManager.setupBeginningTile();
          }

          // Enable input for just the beginning tile interaction
          this.inputManager.setEnabled(true);

          // Register callback for the beginning tile tap
          this.inputManager.onLaneTap(this.onBeginningTileTap.bind(this));
        }

        /**
         * Handler for when the beginning tile is tapped
         * @param laneIndex The lane that was tapped
         */;
        _proto.onBeginningTileTap = function onBeginningTileTap(laneIndex) {
          // Check if we're in the waiting for start state
          if (this.gameState !== GameState.WAITING_FOR_START) {
            return;
          }

          // Check if this lane has the beginning tile
          var beginningTileTapped = this.tileManager.checkBeginningTileTap(laneIndex);
          if (beginningTileTapped) {
            // Unregister the lane tap callback to avoid duplicate calls
            this.inputManager.removeOnLaneTap(this.onBeginningTileTap.bind(this));

            // Start the actual gameplay
            this.startPlaying();
          }
        };
        return GameplayManager;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "tileManager", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "inputManager", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "feedbackManager", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "tapValidator", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "scoreManager", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "toggleAutoPlay", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "countdownDuration", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 3;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "minSurvivalHP", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 40;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "maxSurvivalHP", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 100;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "missHPPenalty", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 10;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "badHitHPPenalty", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 5;
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "perfectHPRecovery", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 2;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/get-local-var.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './base.ts', './utils.ts', './index3.ts', './register.ts'], function (exports) {
  var _inheritsLoose, _createClass, cclegacy, Vec4, ShaderNode, prop, slot, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      prop = module.prop;
      slot = module.slot;
    }, null, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "30feaYkdKtOs5doShMcgDKA", "get-local-var", undefined);
      var GetLocalVar = exports('default', (_dec = register({
        menu: 'Input/Variable/GetLocalVar',
        title: 'GetLocalVar'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(GetLocalVar, _ShaderNode);
        function GetLocalVar() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            props: [prop('Name', 'local_var', 'dynamicEnum', {
              registerEnum: {
                type: 'RegisterLocalVarName',
                property: 'Name'
              }
            })],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = GetLocalVar.prototype;
        _proto.generateCode = function generateCode() {
          var precisionName = this.inputs[0].connectSlot.precisionName;
          return precisionName + " " + this.name + "= " + this.getInputValue(0) + ";";
        };
        _createClass(GetLocalVar, [{
          key: "name",
          get: function get() {
            var name = this.getPropWithName('Name');
            return name && name.value;
          },
          set: function set(v) {
            var name = this.getPropWithName('Name');
            name.value = v;
          }
        }]);
        return GetLocalVar;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/gradient-noise.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec2, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec2 = module.Vec2;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "5ccd4lVn2JLsKN+1DWNpIFz", "gradient-noise", undefined);
      var GradientNoise = exports('default', (_dec = register({
        menu: 'Procedural/Noise/GradientNoise',
        title: 'GradientNoise'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(GradientNoise, _ShaderNode);
        function GradientNoise() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.depChunks = ['noise'];
          _this.data = {
            inputs: [slot('uv', Vec2.ZERO, 'vec2', 'vector'), slot('scale', 0, 'float', 'vector')],
            outputs: [slot('Out', 0, 'float', 'vector')]
          };
          return _this;
        }
        var _proto = GradientNoise.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          if (!this.inputs[0].connectSlot) {
            input0 = 'v_uv.xy';
          }
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return output0 + " = GradientNoise(" + input0 + ", " + input1 + ");";
        };
        return GradientNoise;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/Group.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './enum.ts'], function (exports) {
  var _createClass, cclegacy, StretchDirection;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      StretchDirection = module.StretchDirection;
    }],
    execute: function () {
      cclegacy._RF.push({}, "745449vUL5G0oNZ/T6pUfiN", "Group", undefined);
      var Group = exports('Group', /*#__PURE__*/function () {
        function Group(adapter) {
          this._adapter = void 0;
          this._index = -1;
          this._models = [];
          this._size = {
            x: 0,
            y: 0
          };
          this._oldSize = {
            x: 0,
            y: 0
          };
          this._anchorPoint = {
            x: 0.5,
            y: 0.5
          };
          this._position = {
            x: 0,
            y: 0
          };
          this._oldPosition = {
            x: 0,
            y: 0
          };
          this._totalMinSize = {
            x: 0,
            y: 0
          };
          this._totalPreferredSize = {
            x: 0,
            y: 0
          };
          this._totalFlexibleSize = {
            x: 0,
            y: 0
          };
          this._isFixed = false;
          this._fixedIndex = -1;
          this._adapter = adapter;
          this.internal_reset();
        }
        var _proto = Group.prototype;
        _proto.findModelIndex = function findModelIndex(modelIndex) {
          return this.models.findIndex(function (item) {
            return item.index == modelIndex;
          });
        }
        /** @deprecated  */;
        _proto.internal_reset = function internal_reset() {
          this._models = [];
          this._size = {
            x: 0,
            y: 0
          };
          this._oldSize = {
            x: 0,
            y: 0
          };
          this._anchorPoint = {
            x: 0.5,
            y: 0.5
          };
          this._position = {
            x: 0,
            y: 0
          };
          this._oldPosition = {
            x: 0,
            y: 0
          };
          this._totalMinSize = {
            x: 0,
            y: 0
          };
          this._totalPreferredSize = {
            x: 0,
            y: 0
          };
          this._totalFlexibleSize = {
            x: 0,
            y: 0
          };
          this._isFixed = false;
          this._fixedIndex = -1;
          this._setAnchorPoint();
        }

        /** @deprecated  */;
        _proto.internal_setPosition = function internal_setPosition(position) {
          var mainAxis = this.adapter.mainAxis;
          this.oldPosition[mainAxis] = this.position[mainAxis];
          this.position[mainAxis] = position;
        }
        /** @deprecated  */;
        _proto.internal_setIndex = function internal_setIndex(index) {
          this._index = index;
        }
        /** @deprecated  */;
        _proto.internal_insert = function internal_insert(options, view, clear) {
          view.internal_reset();
          var caches = this.models;
          this.internal_reset();
          this._fixedIndex = options.fixedIndex;
          if (!clear) {
            for (var i = 0; i < caches.length; i++) {
              var model = caches[i];
              if (model.index < options.modelIndex) {
                var ok = this._insertHandler(model, view);
                if (!ok) {
                  options.modelIndex = model.index;
                  options.fixedIndex = this.isFixed ? this.index : options.fixedIndex;
                  return true;
                }
              } else {
                break;
              }
            }
          }
          for (var _i = options.modelIndex; _i < this.adapter.modelManager.length; _i++) {
            var _model = this.adapter.modelManager.get(_i);
            var _ok = this._insertHandler(_model, view);
            if (!_ok) {
              options.modelIndex = _model.index;
              options.fixedIndex = this.isFixed ? this.index : options.fixedIndex;
              return _model.index;
            }
          }
          return false;
        }
        /** @deprecated  */;
        _proto.internal_includes = function internal_includes(dataList) {
          var _this = this;
          var _loop = function _loop() {
              var data = dataList[i];
              index = _this.models.findIndex(function (item) {
                return item.data == data;
              });
              if (-1 != index) return {
                v: true
              };
            },
            index,
            _ret;
          for (var i = 0; i < dataList.length; i++) {
            _ret = _loop();
            if (_ret) return _ret.v;
          }
          return false;
        };
        _proto._insertHandler = function _insertHandler(model, view) {
          var wrap = view.internal_isWrap(model, this);
          if (wrap) {
            view.internal_reset();
            return false;
          }
          view.internal_push(model);
          if (model.element.fixed) {
            this._isFixed = true;
            this._fixedIndex = -1;
          }
          var mainAxis = this.adapter.mainAxis;
          var crossAxis = this.adapter.crossAxis;
          if (!model.element.ignoreLayout || model.element.ignoreLayout && model.element.placeholder) {
            this.size[mainAxis] = Math.max(this.size[mainAxis], model.size[mainAxis] * model.scale[mainAxis]);
          }
          this.size[crossAxis] = this.adapter.crossAxisSize;
          this.oldSize[mainAxis] = this.size[mainAxis];
          this.oldSize[crossAxis] = this.size[crossAxis];
          this.models.push(model);
          return true;
        };
        _proto._setAnchorPoint = function _setAnchorPoint() {
          switch (this.adapter.viewManager.stretchDirection) {
            case StretchDirection.Center:
              this.anchorPoint[this.adapter.mainAxis] = 0.5;
              break;
            case StretchDirection.Header:
              this.anchorPoint[this.adapter.mainAxis] = 1 - this.adapter.mainAxisAnchorPoint;
              break;
            default:
              this.anchorPoint[this.adapter.mainAxis] = this.adapter.mainAxisAnchorPoint;
              break;
          }
        };
        _createClass(Group, [{
          key: "adapter",
          get: function get() {
            return this._adapter;
          }
        }, {
          key: "index",
          get: function get() {
            return this._index;
          }
        }, {
          key: "models",
          get: function get() {
            return this._models;
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          }
        }, {
          key: "oldSize",
          get: function get() {
            return this._oldSize;
          }
        }, {
          key: "anchorPoint",
          get: function get() {
            return this._anchorPoint;
          }
        }, {
          key: "position",
          get: function get() {
            return this._position;
          }
        }, {
          key: "oldPosition",
          get: function get() {
            return this._oldPosition;
          }
        }, {
          key: "totalMinSize",
          get: function get() {
            return this._totalMinSize;
          }
        }, {
          key: "totalPreferredSize",
          get: function get() {
            return this._totalPreferredSize;
          }
        }, {
          key: "totalFlexibleSize",
          get: function get() {
            return this._totalFlexibleSize;
          }
        }, {
          key: "isFixed",
          get: function get() {
            return this._isFixed;
          }
        }, {
          key: "fixedIndex",
          get: function get() {
            return this._fixedIndex;
          }
        }]);
        return Group;
      }());
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/helper.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "9951cDVtORNYrBREEqRMzYS", "helper", undefined);
      var Helper = exports('Helper', /*#__PURE__*/function () {
        function Helper() {}
        Helper.smoothStep = function smoothStep(from, to, t) {
          t = this.clamp01(t);
          t = -2 * t * t * t + 3 * t * t;
          return to * t + from * (1 - t);
        };
        Helper.smoothDamp = function smoothDamp(current, target, currentVelocity, smoothTime, maxSpeed, deltaTime) {
          smoothTime = Math.max(0.0001, smoothTime);
          var num = 2 / smoothTime;
          var num2 = num * deltaTime;
          var num3 = 1 / (1 + num2 + 0.48 * num2 * num2 + 0.235 * num2 * num2 * num2);
          var value = current - target;
          var num4 = target;
          var num5 = maxSpeed * smoothTime;
          value = this.clamp(value, 0 - num5, num5);
          target = current - value;
          var num6 = (currentVelocity + num * value) * deltaTime;
          currentVelocity = (currentVelocity - num * num6) * num3;
          var num7 = target + (value + num6) * num3;
          if (num4 - current > 0 == num7 > num4) {
            num7 = num4;
            currentVelocity = (num7 - num4) / deltaTime;
          }
          return {
            velocity: currentVelocity,
            position: num7
          };
        };
        Helper.clamp01 = function clamp01(value) {
          return this.clamp(value, 0, 1);
        };
        Helper.clamp = function clamp(num, min, max) {
          if (min === void 0) {
            min = 0;
          }
          if (max === void 0) {
            max = 1;
          }
          return Math.min(Math.max(num, min), max);
        };
        Helper.sign = function sign(f) {
          return f >= 0 ? 1 : -1;
        };
        Helper.lerp = function lerp(a, b, t) {
          return a + (b - a) * this.clamp01(t);
        };
        Helper.approximately = function approximately(a, b) {
          return Math.abs(b - a) < Math.max(100E-6 * Math.max(Math.abs(a), Math.abs(b)), this.Epsilon * 8);
        };
        Helper.round = function round(value, n) {
          return Math.round(value * Math.pow(10, n)) / Math.pow(10, n);
        };
        Helper.pingpang = function pingpang(v) {
          var value = v;
          value = Math.abs(v);
          var integer = Math.trunc(value);
          if (integer % 2 == 0) {
            value = value - integer;
          } else {
            value = 1 - (value - integer);
          }
          return value;
        };
        Helper.isNumber = function isNumber(value) {
          return typeof value == "number" && !isNaN(value);
        };
        Helper.progress = function progress(start, end, current, t) {
          return start + (end - start) * t;
        };
        Helper.getGuid = function getGuid() {
          var d = new Date().getTime();
          if (window.performance && typeof window.performance.now === "function") {
            d += performance.now();
          }
          var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = (d + Math.random() * 16) % 16 | 0; // d
            d = Math.floor(d / 16);
            return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);
          });
          return uuid;
        };
        return Helper;
      }());
      Helper.Epsilon = 1.401298E-45;
      Helper.Infinity = 1 / 0;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/Holder.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './helper.ts', './ModelManager.ts'], function (exports) {
  var _createClass, cclegacy, _decorator, Node, UITransform, Helper, ModelManager;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      UITransform = module.UITransform;
    }, function (module) {
      Helper = module.Helper;
    }, function (module) {
      ModelManager = module.ModelManager;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "e143cqYQS9Lga09ceG48Qky", "Holder", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var Holder = exports('Holder', (_dec = ccclass('Holder'), _dec(_class = /*#__PURE__*/function () {
        function Holder(node, code, adapter) {
          this._node = void 0;
          this._transform = void 0;
          this._code = void 0;
          this._adapter = void 0;
          this._model = void 0;
          this._view = void 0;
          this._fixedIndex = -1;
          this._oldData = null;
          this._oldElement = null;
          this._isCallCreated = false;
          this._isLayout = false;
          this._node = node;
          this._code = code;
          this._adapter = adapter;
          this._transform = this.node.getComponent(UITransform);
        }
        /** @deprecated  */
        var _proto = Holder.prototype;
        _proto.internal_visible = function internal_visible(view, model, isNew) {
          var _this = this;
          this._view = view;
          this._model = model;
          this._oldElement = Object.assign({}, model.element);
          this._model.element.update = this._updateElement.bind(this);
          this._oldData = this.data;
          if (!isNew) return;
          this.node.active = true;
          if (!this._isCallCreated) {
            this._isCallCreated = true;
            this.onCreated();
          }
          if (this.element.fixed) {
            this._fixedIndex = this.view.group.models.findIndex(function (item) {
              return item.index == _this.model.index;
            });
          }
          this.transform.setContentSize(this.model.size.x, this.model.size.y);
          this.node.setScale(this.model.scale.x, this.model.scale.y);
          this._register();
          this.onVisible();
          this._model.update = this._updateHandler.bind(this);
        };
        _proto._updateElement = function _updateElement() {
          if (this._oldElement.layer != this.element.layer) {
            this.node.parent = this.adapter.scrollManager.getLayerNode(this.element.layer);
            this._oldElement.layer = this.element.layer;
          }
          if (this._oldElement.wrapAfterMode != this.element.wrapAfterMode || this._oldElement.wrapBeforeMode != this.element.wrapBeforeMode || this._oldElement.ignoreLayout != this.element.ignoreLayout || this.element.ignoreLayout && this._oldElement.placeholder != this.element.placeholder) {
            this.adapter.viewManager.internal_updateVisibleView(this.model.index);
            this._oldElement.wrapAfterMode = this.element.wrapAfterMode;
            this._oldElement.wrapBeforeMode = this.element.wrapBeforeMode;
            this._oldElement.ignoreLayout = this.element.ignoreLayout;
            this._oldElement.placeholder = this.element.placeholder;
          }
        };
        _proto._updateHandler = function _updateHandler() {
          this._model.update = function () {};
          this.onVisible();
          this._model.update = this._updateHandler.bind(this);
        }

        /** @deprecated  */;
        _proto.internal_disable = function internal_disable() {
          this.adapter.scrollManager.internal_disableTouchTarget(this.node);
          this.onDisable();
          this._unregister();
          this._model.update = function () {};
          this._model.element.update = function () {};
          this._view = null;
          this._model = null;
          this._fixedIndex = -1;
          this._isLayout = false;
          this._oldData = null;
          this.node.active = false;
        }
        /** @deprecated  */;
        _proto.internal_layout = function internal_layout() {
          var size = {
            x: this.model.size.x,
            y: this.model.size.y
          };
          if (this.adapter.layoutManager.isControlMainAxisSize) {
            size[this.adapter.mainAxis] = this.model.layoutSize[this.adapter.mainAxis];
          }
          if (this.adapter.layoutManager.isControlCrossAxisSize) {
            size[this.adapter.crossAxis] = this.model.layoutSize[this.adapter.crossAxis];
          }
          this._isLayout = true;
          this.transform.setContentSize(size.x, size.y);
          this._isLayout = false;
          this.node.setPosition(this.model.position.x, this.model.position.y);
        };
        _proto._register = function _register() {
          this.node.on(Node.EventType.SIZE_CHANGED, this._onSizeChanged, this);
          this.node.on(Node.EventType.TRANSFORM_CHANGED, this._onScaleChanged, this);
          this.node.on(Node.EventType.ANCHOR_CHANGED, this._onAnchorPointChanged, this);
          this._adapter.modelManager.on(ModelManager.Event.ON_UPDATE, this._updateHandler, this);
        };
        _proto._unregister = function _unregister() {
          this.node.off(Node.EventType.SIZE_CHANGED, this._onSizeChanged, this);
          this.node.off(Node.EventType.TRANSFORM_CHANGED, this._onScaleChanged, this);
          this.node.off(Node.EventType.ANCHOR_CHANGED, this._onAnchorPointChanged, this);
          this._adapter.modelManager.off(ModelManager.Event.ON_UPDATE, this._updateHandler, this);
        };
        _proto._onSizeChanged = function _onSizeChanged() {
          if (this._isLayout) return;
          var isMainAxisEqual = Helper.approximately(this.model.size[this.adapter.mainAxis], this.transform.contentSize[this.adapter.mainAxis]);
          var isCrossAxisEqual = Helper.approximately(this.model.size[this.adapter.crossAxis], this.transform.contentSize[this.adapter.crossAxis]);
          this.model.size.x = this.transform.width;
          this.model.size.y = this.transform.height;
          if (isMainAxisEqual && isCrossAxisEqual) {
            return;
          }
          this.view.internal_holderChanged(isMainAxisEqual);
        };
        _proto._onScaleChanged = function _onScaleChanged(type) {
          if (type != Node.TransformBit.SCALE) return;
          //  
          if (!this.adapter.layoutManager.controlScaleWidth && !this.adapter.layoutManager.controlScaleHeight) {
            return;
          }
          var isMainAxisEqual = Helper.approximately(this.model.scale[this.adapter.mainAxis], this.node.scale[this.adapter.mainAxis]);
          var isCrossAxisEqual = Helper.approximately(this.model.scale[this.adapter.crossAxis], this.node.scale[this.adapter.crossAxis]);
          this.model.scale.x = this.node.scale.x;
          this.model.scale.y = this.node.scale.y;
          if (isMainAxisEqual && isCrossAxisEqual) {
            return;
          }
          this.view.internal_holderChanged(isMainAxisEqual);
        };
        _proto._onAnchorPointChanged = function _onAnchorPointChanged() {
          var isMainAxisEqual = Helper.approximately(this.model.anchorPoint[this.adapter.mainAxis], this.transform.anchorPoint[this.adapter.mainAxis]);
          var isCrossAxisEqual = Helper.approximately(this.model.anchorPoint[this.adapter.crossAxis], this.transform.anchorPoint[this.adapter.crossAxis]);
          this.model.anchorPoint.x = this.transform.anchorPoint.x;
          this.model.anchorPoint.y = this.transform.anchorPoint.y;
          if (isMainAxisEqual && isCrossAxisEqual) {
            return;
          }
          this.view.internal_holderChanged(isMainAxisEqual);
        };
        _createClass(Holder, [{
          key: "node",
          get: function get() {
            return this._node;
          }
        }, {
          key: "transform",
          get: function get() {
            return this._transform;
          }
        }, {
          key: "code",
          get: function get() {
            return this._code;
          }
        }, {
          key: "adapter",
          get: function get() {
            return this._adapter;
          }
        }, {
          key: "model",
          get: function get() {
            return this._model;
          }
        }, {
          key: "view",
          get: function get() {
            return this._view;
          }
        }, {
          key: "data",
          get: function get() {
            return this._model && this._model.data;
          }
        }, {
          key: "fixedIndex",
          get: function get() {
            return this._fixedIndex;
          }
        }, {
          key: "oldData",
          get: function get() {
            return this._oldData;
          }
        }, {
          key: "element",
          get: function get() {
            return this._model && this._model.element;
          }
        }, {
          key: "index",
          get: function get() {
            return this._model && this._model.index;
          }
        }]);
        return Holder;
      }()) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/HomeController.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './PopupDefine.ts', './uiManager.ts', './SceneDefine.ts'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, director, Component, POPUP, UIManager, SCENE_NAME;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      director = module.director;
      Component = module.Component;
    }, function (module) {
      POPUP = module.POPUP;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      SCENE_NAME = module.SCENE_NAME;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "7be4edEMP9G4o2PKnJZVUkm", "HomeController", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var HomeController = exports('HomeController', (_dec = ccclass('HomeController'), _dec(_class = /*#__PURE__*/function (_Component) {
        _inheritsLoose(HomeController, _Component);
        function HomeController() {
          return _Component.apply(this, arguments) || this;
        }
        var _proto = HomeController.prototype;
        _proto.start = function start() {
          UIManager.instance.showDialog(POPUP.MESSAGE, [{
            title: "Hello",
            message: "This is a test message",
            buttonText: "OK",
            buttonCallback: function buttonCallback() {
              director.loadScene(SCENE_NAME.AUDITION);
            }
          }]);
        };
        _proto.update = function update(deltaTime) {}

        //#region callbacks
        ;

        _proto.onTouch_Test = function onTouch_Test() {}

        //#endregion
        ;

        return HomeController;
      }(Component)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/HotKey.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Enum, KeyCode, input, Input, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Enum = module.Enum;
      KeyCode = module.KeyCode;
      input = module.input;
      Input = module.Input;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "e01eb+jQTRNdbPwrEVkkCRc", "HotKey", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var Hotkey = exports('Hotkey', (_dec = ccclass('Hotkey'), _dec2 = property({
        type: [Enum(KeyCode)]
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(Hotkey, _Component);
        function Hotkey() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "keys", _descriptor, _assertThisInitialized(_this));
          _this.keyMap = new Map();
          return _this;
        }
        var _proto = Hotkey.prototype;
        _proto.onLoad = function onLoad() {
          var _this2 = this;
          this.keys.forEach(function (key) {
            return _this2.keyMap.set(key, false);
          });
        };
        _proto.getKeyString = function getKeyString() {
          try {
            var keyStr = KeyCode[this.keys[0]];
            if (keyStr.length <= 2) return keyStr;
            var splitedStr = keyStr.split('_');
            return splitedStr[splitedStr.length - 1];
          } catch (e) {
            return "";
          }
        };
        _proto.onEnable = function onEnable() {
          // Listen for key press and release events
          input.on(Input.EventType.KEY_DOWN, this.onKeyDown, this);
          input.on(Input.EventType.KEY_UP, this.onKeyUp, this);
        };
        _proto.onDisable = function onDisable() {
          // Remove event listeners when the component is destroyed
          input.off(Input.EventType.KEY_DOWN, this.onKeyDown, this);
          input.off(Input.EventType.KEY_UP, this.onKeyUp, this);
        };
        _proto.onKeyDown = function onKeyDown(event) {
          if (this.keyMap.has(event.keyCode)) {
            this.keyMap.set(event.keyCode, true);
            // Check if the key combination is pressed
            if (this.isKeyCombinationPressed()) {
              this.trigger();
            }
          }
        };
        _proto.onKeyUp = function onKeyUp(event) {
          if (this.keyMap.has(event.keyCode)) {
            this.keyMap.set(event.keyCode, false);
          }
        };
        _proto.isKeyCombinationPressed = function isKeyCombinationPressed() {
          // Check if both Ctrl and S are pressed
          var isTrigger = true;
          this.keyMap.forEach(function (value, key) {
            if (!value) {
              isTrigger = false;
            }
          });
          return isTrigger;
        };
        _proto.trigger = function trigger() {};
        return Hotkey;
      }(Component), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "keys", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/HUD_Options.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Bullet.ts', './Cannon.ts', './Cursor.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Node, ToggleContainer, EditBox, Toggle, sys, Vec3, Component, Bullet, Cannon, Cursor;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      ToggleContainer = module.ToggleContainer;
      EditBox = module.EditBox;
      Toggle = module.Toggle;
      sys = module.sys;
      Vec3 = module.Vec3;
      Component = module.Component;
    }, function (module) {
      Bullet = module.Bullet;
    }, function (module) {
      Cannon = module.Cannon;
    }, function (module) {
      Cursor = module.Cursor;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10;
      cclegacy._RF.push({}, "1b4097H5s5E1YZkd5DJRPR9", "HUD_Options", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * HUD 
       */
      var HUD_Options = exports('HUD_Options', (_dec = ccclass('HUD_Options'), _dec2 = property({
        type: Node
      }), _dec3 = property({
        type: Node
      }), _dec4 = property({
        type: ToggleContainer
      }), _dec5 = property({
        type: EditBox
      }), _dec6 = property({
        type: EditBox
      }), _dec7 = property({
        type: Toggle
      }), _dec8 = property({
        type: Toggle
      }), _dec9 = property({
        type: Toggle
      }), _dec10 = property({
        type: Cannon
      }), _dec11 = property({
        type: Cursor
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(HUD_Options, _Component);
        function HUD_Options() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "content", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "arrow", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "cannonModeToggleContainer", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "cannonAngleEditBox", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "cannonVelocityEditBox", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "cannonTrajectoryToggle", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "bulletExplodeToggle", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "cursorAdaptToggle", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "cannon", _descriptor9, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "cursor", _descriptor10, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = HUD_Options.prototype;
        /**
         * 
         */
        _proto.onLoad = function onLoad() {
          this.init();
          this.registerEvent();
        }

        /**
         * 
         */;
        _proto.onDestroy = function onDestroy() {
          this.unregisterEvent();
        }

        /**
         * 
         */;
        _proto.registerEvent = function registerEvent() {
          this.node.on(Node.EventType.TOUCH_END, this.onTouchEnd, this);
        }

        /**
         * 
         */;
        _proto.unregisterEvent = function unregisterEvent() {
          this.node.off(Node.EventType.TOUCH_END, this.onTouchEnd, this);
        }

        /**
         * 
         * @param event 
         */;
        _proto.onTouchEnd = function onTouchEnd(event) {
          this.changeState(!this.content.active);
        }

        /**
         * 
         */;
        _proto.init = function init() {
          // 
          if (sys.platform === sys.Platform.MOBILE_BROWSER) {
            this.node.setScale(new Vec3(2, 2, 1));
          } else {
            this.node.setScale(new Vec3(1, 1, 1));
          }
          // 
          this.changeState(true);
          // 
          var mode = Cannon.Mode[this.cannon.mode],
            toggles = this.cannonModeToggleContainer.toggleItems;
          for (var i = 0; i < toggles.length; i++) {
            if (toggles[i].node.name === mode) toggles[i].isChecked = true;
          }
          // 
          this.cannonAngleEditBox.string = this.cannon.fixedPitchAngle.toString();
          this.cannonAngleEditBox.placeholder = this.cannon.fixedPitchAngle.toString();
          // 
          this.cannonVelocityEditBox.string = this.cannon.fixedVelocity.toString();
          this.cannonVelocityEditBox.placeholder = this.cannon.fixedVelocity.toString();
          // 
          this.cannonTrajectoryToggle.isChecked = this.cannon.showTrajectory;
          // 
          this.bulletExplodeToggle.isChecked = Bullet.triggerExplode;
          // 
          this.cursorAdaptToggle.isChecked = this.cursor.adaptToSurface;
          // 
          this.changeState(false);
        }

        /**
         * 
         * @param show 
         */;
        _proto.changeState = function changeState(show) {
          this.content.active = show;
          this.arrow.angle = show ? 180 : 0;
        }

        /**
         * 
         * @param toggle 
         */;
        _proto.onCannonModeToggleChanged = function onCannonModeToggleChanged(toggle) {
          var value = this.cannonModeToggleContainer.activeToggles()[0].node.name;
          switch (value) {
            case 'FIXED_ALL':
              {
                this.cannon.mode = Cannon.Mode.FIXED_ALL;
                this.cannonAngleEditBox.node.parent.active = true;
                this.cannonVelocityEditBox.node.parent.active = true;
                break;
              }
            case 'FIXED_PITCH_ANGLE':
              {
                this.cannon.mode = Cannon.Mode.FIXED_PITCH_ANGLE;
                this.cannonAngleEditBox.node.parent.active = true;
                this.cannonVelocityEditBox.node.parent.active = false;
                break;
              }
            case 'FIXED_VELOCITY':
              {
                this.cannon.mode = Cannon.Mode.FIXED_VELOCITY;
                this.cannonAngleEditBox.node.parent.active = false;
                this.cannonVelocityEditBox.node.parent.active = true;
                break;
              }
            case 'UNFIXED':
              {
                this.cannon.mode = Cannon.Mode.UNFIXED;
                this.cannonAngleEditBox.node.parent.active = false;
                this.cannonVelocityEditBox.node.parent.active = false;
                break;
              }
          }
        }

        /**
         * 
         * @param editBox 
         */;
        _proto.onCannonAngleEditBoxChanged = function onCannonAngleEditBoxChanged(editBox) {
          var value = Number(this.cannonAngleEditBox.string);
          if (isNaN(value) || value > 0) {
            this.cannonAngleEditBox.string = this.cannon.fixedPitchAngle.toString();
            return;
          }
          this.cannon.fixedPitchAngle = value;
        }

        /**
         * 
         * @param editBox 
         */;
        _proto.onCannonVelocityEditBoxChanged = function onCannonVelocityEditBoxChanged(editBox) {
          var value = Number(this.cannonVelocityEditBox.string);
          if (isNaN(value) || value <= 0) {
            this.cannonVelocityEditBox.string = this.cannon.fixedVelocity.toString();
            return;
          }
          this.cannon.fixedVelocity = value;
        }

        /**
         * 
         * @param toggle 
         */;
        _proto.onCannonTrajectoryToggleChanged = function onCannonTrajectoryToggleChanged(toggle) {
          var value = this.cannonTrajectoryToggle.isChecked;
          this.cannon.showTrajectory = value;
        }

        /**
         * 
         * @param toggle 
         */;
        _proto.onBulletExplodeToggleChanged = function onBulletExplodeToggleChanged(toggle) {
          var value = this.bulletExplodeToggle.isChecked;
          Bullet.triggerExplode = value;
        }

        /**
         * 
         * @param toggle 
         */;
        _proto.onCursorAdaptToggleChanged = function onCursorAdaptToggleChanged(toggle) {
          var value = this.cursorAdaptToggle.isChecked;
          this.cursor.adaptToSurface = value;
        };
        return HUD_Options;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "content", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "arrow", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "cannonModeToggleContainer", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "cannonAngleEditBox", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "cannonVelocityEditBox", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "cannonTrajectoryToggle", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "bulletExplodeToggle", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "cursorAdaptToggle", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "cannon", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "cursor", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/HUD_Tips.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Label, sys, Vec3, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Label = module.Label;
      sys = module.sys;
      Vec3 = module.Vec3;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "8d90ax9dDlNL5GpGoJYpjmB", "HUD_Tips", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * HUD 
       */
      var HUD_Tips = exports('HUD_Tips', (_dec = ccclass('HUD_Tips'), _dec2 = property({
        type: Label
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(HUD_Tips, _Component);
        function HUD_Tips() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "label", _descriptor, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = HUD_Tips.prototype;
        /**
         * 
         */
        _proto.onLoad = function onLoad() {
          this.init();
        }

        /**
         * 
         */;
        _proto.init = function init() {
          if (sys.platform === sys.Platform.MOBILE_BROWSER) {
            this.node.setScale(new Vec3(1.5, 1.5, 1));
            this.label.string = '';
          } else {
            this.node.setScale(new Vec3(1, 1, 1));
            this.label.string = '';
          }
        };
        return HUD_Tips;
      }(Component), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "label", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/hyperbolic-cosine.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "d1158zUxl5K7KSvlL2F7+wS", "hyperbolic-cosine", undefined);
      var HyperbolicCosine = exports('default', (_dec = register({
        menu: 'Math/Trigonometry/HyperbolicCosine',
        title: 'HyperbolicCosine'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(HyperbolicCosine, _ShaderNode);
        function HyperbolicCosine() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = HyperbolicCosine.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = cosh(" + input0 + ");\n        ";
        };
        return HyperbolicCosine;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/hyperbolic-sine.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "d0e30ycExdAl4oLI765JfTS", "hyperbolic-sine", undefined);
      var HyperbolicSine = exports('default', (_dec = register({
        menu: 'Math/Trigonometry/HyperbolicSine',
        title: 'HyperbolicSine'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(HyperbolicSine, _ShaderNode);
        function HyperbolicSine() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = HyperbolicSine.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = sinh(" + input0 + ");\n        ";
        };
        return HyperbolicSine;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/hyperbolic.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "b180bsrU6dCOKdx5slTh5p9", "hyperbolic", undefined);
      var Hyperbolic = exports('default', (_dec = register({
        menu: 'Math/Trigonometry/Hyperbolic',
        title: 'Hyperbolic'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Hyperbolic, _ShaderNode);
        function Hyperbolic() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Hyperbolic.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = tanh(" + input0 + ");\n        ";
        };
        return Hyperbolic;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ImageLoader.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, SpriteFrame, math, randomRangeInt, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      SpriteFrame = module.SpriteFrame;
      math = module.math;
      randomRangeInt = module.randomRangeInt;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _class3;
      cclegacy._RF.push({}, "449f63urB5BrqfvzhGei/dM", "ImageLoader", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var ImageLoader = exports('ImageLoader', (_dec = ccclass('ImageLoader'), _dec2 = property([SpriteFrame]), _dec3 = property([SpriteFrame]), _dec4 = property(SpriteFrame), _dec5 = property(SpriteFrame), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(ImageLoader, _Component);
        function ImageLoader() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          //#endregion
          _initializerDefineProperty(_this, "preloadSpriteFrames", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "avatarSpriteframe", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "sfDiamonds", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "sfCoins", _descriptor4, _assertThisInitialized(_this));
          _this.spriteFrameMap = new Map();
          return _this;
        }
        var _proto = ImageLoader.prototype;
        _proto.onLoad = function onLoad() {
          ImageLoader.instance = this;
          this.initSpriteFrames();
        };
        _proto.initSpriteFrames = function initSpriteFrames() {
          var _this2 = this;
          this.preloadSpriteFrames.forEach(function (spriteFrame) {
            _this2.spriteFrameMap.set(spriteFrame.name, spriteFrame);
          });
        };
        _proto.getSpriteFrame = function getSpriteFrame(name) {
          if (this.spriteFrameMap.has(name)) {
            return this.spriteFrameMap.get(name);
          }
          console.error("Unknown sprite" + name);
          return null;
        };
        _proto.getAvatar = function getAvatar(id) {
          var number = (Number(id) % 1000).toString();
          var getNumberWithNumberAgo = function getNumberWithNumberAgo(input) {
            try {
              var _number;
              return parseInt((_number = number[number.length - input]) != null ? _number : "0");
            } catch (_unused) {
              return 0;
            }
          };
          try {
            // const number = (Number("0x" + id) % 1000).toString();
            var lastChar = getNumberWithNumberAgo(1);
            var lastChar2 = getNumberWithNumberAgo(2);
            var index = math.clamp(lastChar + lastChar2, 0, this.avatarSpriteframe.length - 1);
            return this.avatarSpriteframe[index];
          } catch (e) {
            return null;
          }
        };
        _proto.getRandomCapyImage = function getRandomCapyImage() {
          return this.avatarSpriteframe[randomRangeInt(0, this.avatarSpriteframe.length)];
        };
        return ImageLoader;
      }(Component), _class3.instance = null, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "preloadSpriteFrames", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "avatarSpriteframe", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "sfDiamonds", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "sfCoins", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/index.ts", ['cc', './polar-coordinates.ts', './rotate-coordinates.ts', './tilling-and-offset.ts', './boolean.ts', './float.ts', './slider.ts', './vector2.ts', './vector3.ts', './vector4.ts', './absolute.ts', './exponential.ts', './length.ts', './log.ts', './modulo.ts', './negate.ts', './normalize.ts', './posterize.ts', './reciprocal-square.ts', './reciprocal.ts', './add.ts', './divide.ts', './multiply.ts', './power.ts', './square.ts', './substract.ts', './ddx.ts', './ddxy.ts', './ddy.ts', './inverse-lerp.ts', './lerp.ts', './smoothstep.ts', './clamp.ts', './fraction.ts', './max.ts', './min.ts', './one-minus.ts', './random-range.ts', './remap.ts', './saturate.ts', './ceil.ts', './floor.ts', './round.ts', './sign.ts', './step.ts', './truncate.ts', './arccosine.ts', './arcsine.ts', './arctangent.ts', './arctangent2.ts', './cosine.ts', './degrees-to-radians.ts', './hyperbolic-cosine.ts', './hyperbolic-sine.ts', './hyperbolic.ts', './radians-to-degrees.ts', './sine.ts', './tangent.ts', './cross-product.ts', './distance.ts', './dot-product.ts', './fresnel.ts', './projection.ts', './reflection.ts', './rejection.ts', './sphere-mask.ts', './noise-sine-wave.ts', './sawtooth-wave.ts', './square-wave.ts', './triangle-wave.ts', './gradient-noise.ts', './simple-noise.ts', './ellipse.ts', './rectangle.ts', './round-rectangle.ts', './index4.ts', './combine.ts', './split.ts', './input-node.ts', './property-node.ts', './all.ts', './and.ts', './any.ts', './branch.ts', './comparison.ts', './is-nan.ts', './not.ts', './or.ts', './MasterNode.ts', './SurfaceMasterNode.ts', './UnlitMasterNode.ts', './SubGraphNode.ts', './SubGraphOutputNode.ts', './PreviewNode.ts', './color.ts', './time.ts', './normal-vector.ts', './position.ts', './uv.ts', './vertex-color.ts', './view-direction.ts', './cubemap-asset.ts', './sample-cubemap.ts', './sample-texture2d.ts', './texture-asset.ts', './texture2d-asset.ts', './get-local-var.ts', './register-local-var.ts'], function () {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],
    execute: function () {
      cclegacy._RF.push({}, "00450ydLIRBS6bzTCNNRjmm", "index", undefined);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/index2.ts", ['cc', './CenterManager.ts', './LayoutManager.ts', './ModelManager.ts', './PageViewManager.ts', './ReleaseManager.ts', './ScrollManager.ts', './ViewManager.ts', './Group.ts', './Holder.ts', './Manager.ts', './ScrollAdapter.ts', './View.ts', './Indicator.ts', './Scrollbar.ts', './debug.ts', './enum.ts', './interface.ts', './helper.ts'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      exports('CenterManager', module.CenterManager);
    }, function (module) {
      exports('LayoutManager', module.LayoutManager);
    }, function (module) {
      exports('ModelManager', module.ModelManager);
    }, function (module) {
      exports('PageViewManager', module.PageViewManager);
    }, function (module) {
      var _setter = {};
      _setter.ReleaseEvent = module.ReleaseEvent;
      _setter.ReleaseManager = module.ReleaseManager;
      exports(_setter);
    }, function (module) {
      var _setter = {};
      _setter.ADAPTER = module.ADAPTER;
      _setter.ScrollManager = module.ScrollManager;
      exports(_setter);
    }, function (module) {
      exports('ViewManager', module.ViewManager);
    }, function (module) {
      exports('Group', module.Group);
    }, function (module) {
      exports('Holder', module.Holder);
    }, function (module) {
      exports('Manager', module.Manager);
    }, function (module) {
      exports('ScrollAdapter', module.ScrollAdapter);
    }, function (module) {
      exports('View', module.View);
    }, function (module) {
      exports('Indicator', module.Indicator);
    }, function (module) {
      exports('Scrollbar', module.Scrollbar);
    }, function (module) {
      var _setter = {};
      _setter.ADAPTER_DEBUG_CONTENT = module.ADAPTER_DEBUG_CONTENT;
      _setter.ADAPTER_DEBUG_VIEW = module.ADAPTER_DEBUG_VIEW;
      _setter.DEBUG_DRAW_BORDER_COLOR = module.DEBUG_DRAW_BORDER_COLOR;
      _setter.DEBUG_DRAW_FILL_COLOR = module.DEBUG_DRAW_FILL_COLOR;
      _setter.DEBUG_DRAW_LIND_WIDTH = module.DEBUG_DRAW_LIND_WIDTH;
      _setter.DEBUG_DRAW_LINE_COLOR = module.DEBUG_DRAW_LINE_COLOR;
      exports(_setter);
    }, function (module) {
      var _setter = {};
      _setter.AlwaysScroll = module.AlwaysScroll;
      _setter.ArrangeAxis = module.ArrangeAxis;
      _setter.ChildAlignment = module.ChildAlignment;
      _setter.HolderEvent = module.HolderEvent;
      _setter.IndicatorMode = module.IndicatorMode;
      _setter.Layer = module.Layer;
      _setter.MagneticDirection = module.MagneticDirection;
      _setter.MovementType = module.MovementType;
      _setter.NestedDirection = module.NestedDirection;
      _setter.Orientation = module.Orientation;
      _setter.ReleaseState = module.ReleaseState;
      _setter.ScrollDirection = module.ScrollDirection;
      _setter.ScrollbarDirection = module.ScrollbarDirection;
      _setter.StretchDirection = module.StretchDirection;
      _setter.TouchMode = module.TouchMode;
      _setter.Transition = module.Transition;
      _setter.ViewEvent = module.ViewEvent;
      _setter.WrapMode = module.WrapMode;
      exports(_setter);
    }, null, function (module) {
      exports('Helper', module.Helper);
    }],
    execute: function () {
      cclegacy._RF.push({}, "0a2997sehVGrL8shCrZiUoV", "index", undefined);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/index3.ts", ['cc', './register.ts'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      var _setter = {};
      _setter.register = module.register;
      _setter.shaderNodeClassMap = module.shaderNodeClassMap;
      _setter.shaderNodeMap = module.shaderNodeMap;
      _setter.shaderPropertyMap = module.shaderPropertyMap;
      exports(_setter);
    }],
    execute: function () {
      cclegacy._RF.push({}, "ca808INO7FLGrJCNKRU+Sjn", "index", undefined);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/index4.ts", ['cc'], function () {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      // import { ShaderNode } from '../base';
      cclegacy._RF.push({}, "ce045mF1/xFUKqKc7YUTgo5", "index", undefined);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/Indicator.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ScrollAdapter.ts', './enum.ts', './PageViewManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, SpriteFrame, Color, Node, Sprite, UITransform, Button, EventHandler, Layout, Component, Size, ScrollAdapter, IndicatorMode, PageViewManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      SpriteFrame = module.SpriteFrame;
      Color = module.Color;
      Node = module.Node;
      Sprite = module.Sprite;
      UITransform = module.UITransform;
      Button = module.Button;
      EventHandler = module.EventHandler;
      Layout = module.Layout;
      Component = module.Component;
      Size = module.Size;
    }, function (module) {
      ScrollAdapter = module.ScrollAdapter;
    }, function (module) {
      IndicatorMode = module.IndicatorMode;
    }, function (module) {
      PageViewManager = module.PageViewManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;
      cclegacy._RF.push({}, "518d6bEinVOEZVOae09QC8Z", "Indicator", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      /**
       * Indicator
       *  Indicator
       */
      var Indicator = exports('Indicator', (_dec = ccclass('Indicator'), _dec2 = property(ScrollAdapter), _dec3 = property({
        type: SpriteFrame
      }), _dec4 = property({
        type: IndicatorMode
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(Indicator, _Component);
        function Indicator() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "adapter", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "spriteFrame", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "indicatorMode", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "cellSize", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "spacing", _descriptor5, _assertThisInitialized(_this));
          _this._indicators = [];
          _this._layout = null;
          _this._color = new Color();
          return _this;
        }
        var _proto = Indicator.prototype;
        _proto.__preload = function __preload() {
          if (this.adapter) {
            this.adapter.pageViewManager.on(PageViewManager.Event.ON_PAGE_LENGTH_CHANGED, this._onPageLengthChanged, this);
            this.adapter.pageViewManager.on(PageViewManager.Event.ON_SCROLL_PAGE_END, this._onScrollPageEnd, this);
          }
        };
        _proto._onScrollPageEnd = function _onScrollPageEnd() {
          this.changedState();
        };
        _proto._onPageLengthChanged = function _onPageLengthChanged() {
          if (!this.adapter) return;
          var indicators = this._indicators;
          var length = this.adapter.viewManager.groupLength;
          if (length === indicators.length) {
            return;
          }
          var i = 0;
          if (length > indicators.length) {
            for (i = 0; i < length; ++i) {
              if (!indicators[i]) {
                indicators[i] = this._createIndicator(i);
              }
            }
          } else {
            var count = indicators.length - length;
            for (i = count; i > 0; --i) {
              var transform = indicators[i - 1];
              this.node.removeChild(transform.node);
              indicators.splice(i - 1, 1);
            }
          }
          if (this.layout && this.layout.enabledInHierarchy) {
            this.layout.updateLayout();
          }
          this.changedState();
        };
        _proto._createIndicator = function _createIndicator(index) {
          var node = new Node();
          node.layer = this.node.layer;
          var sprite = node.addComponent(Sprite);
          sprite.spriteFrame = this.spriteFrame;
          sprite.sizeMode = Sprite.SizeMode.CUSTOM;
          node.parent = this.node;
          var transform = node.getComponent(UITransform);
          transform.setContentSize(this.cellSize);
          if (this.indicatorMode == IndicatorMode.Button) {
            var button = node.getComponent(Button) || node.addComponent(Button);
            var event = new EventHandler();
            event.component = "Indicator";
            event.handler = "_click";
            event.target = this.node;
            event.customEventData = index;
            button.clickEvents.push(event);
          }
          return transform;
        };
        _proto._click = function _click(event, data) {
          this.adapter.pageViewManager.scrollToPage(this.adapter.pageViewManager.pageTurningSpeed, data);
        };
        _proto.changedState = function changedState() {
          var indicators = this._indicators;
          if (indicators.length === 0 || !this.adapter) return;
          var idx = this.adapter.pageViewManager.currentIndex;
          if (idx >= indicators.length) return;
          for (var i = 0; i < indicators.length; ++i) {
            var transform = indicators[i];
            var comp = transform.getComponent(Sprite);
            this._color.set(comp.color);
            this._color.a = 255 / 2;
            comp.color = this._color;
          }
          if (indicators[idx]) {
            var _comp = indicators[idx].getComponent(Sprite);
            this._color.set(_comp.color);
            this._color.a = 255;
            _comp.color = this._color;
          }
        };
        _createClass(Indicator, [{
          key: "layout",
          get: function get() {
            if (this._layout == null) {
              this._layout = this.getComponent(Layout) || this.addComponent(Layout);
              if (this.adapter.isHorizontal) {
                this._layout.type = Layout.Type.HORIZONTAL;
                this._layout.spacingX = this.spacing;
              } else {
                this._layout.type = Layout.Type.VERTICAL;
                this._layout.spacingY = this.spacing;
              }
              this._layout.resizeMode = Layout.ResizeMode.CONTAINER;
            }
            return this._layout;
          }
        }]);
        return Indicator;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "adapter", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "spriteFrame", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "indicatorMode", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return IndicatorMode.Normal;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "cellSize", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Size(10, 10);
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "spacing", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 10;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/input-node.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './base.ts', './type.ts'], function (exports) {
  var _inheritsLoose, cclegacy, ShaderNode, ConcretePrecisionType;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }],
    execute: function () {
      cclegacy._RF.push({}, "fcee9eMBvJBt5SDLbWEpbbO", "input-node", undefined);
      var InputNode = exports('default', /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(InputNode, _ShaderNode);
        function InputNode() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          return _this;
        }
        return InputNode;
      }(ShaderNode));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/InputManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './TileManager.ts', './TapValidator.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createForOfIteratorHelperLoose, cclegacy, _decorator, Node, Camera, UITransform, Sprite, Color, UIOpacity, Vec3, input, Input, KeyCode, Component, TileManager, TapValidator;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createForOfIteratorHelperLoose = module.createForOfIteratorHelperLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Camera = module.Camera;
      UITransform = module.UITransform;
      Sprite = module.Sprite;
      Color = module.Color;
      UIOpacity = module.UIOpacity;
      Vec3 = module.Vec3;
      input = module.input;
      Input = module.Input;
      KeyCode = module.KeyCode;
      Component = module.Component;
    }, function (module) {
      TileManager = module.TileManager;
    }, function (module) {
      TapValidator = module.TapValidator;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7;
      cclegacy._RF.push({}, "19aa5JfAPNMBLEL5AtzqFm7", "InputManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      // Interface for tracking touch data

      /**
       * InputManager for Magic Tiles 3
       * Handles touch/tap detection and validation
       */
      var InputManager = exports('InputManager', (_dec = ccclass('InputManager'), _dec2 = property([Node]), _dec3 = property(Node), _dec4 = property(Node), _dec5 = property(TileManager), _dec6 = property(TapValidator), _dec7 = property(Camera), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(InputManager, _Component);
        function InputManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Visual feedback nodes for taps
          _initializerDefineProperty(_this, "tapFeedbackNodes", _descriptor, _assertThisInitialized(_this));
          // Hit line node for visualization
          _initializerDefineProperty(_this, "hitLineNode", _descriptor2, _assertThisInitialized(_this));
          // Reference to the lane container
          _initializerDefineProperty(_this, "laneContainer", _descriptor3, _assertThisInitialized(_this));
          // Reference to the tile manager
          _initializerDefineProperty(_this, "tileManager", _descriptor4, _assertThisInitialized(_this));
          // Reference to the tap validator
          _initializerDefineProperty(_this, "tapValidator", _descriptor5, _assertThisInitialized(_this));
          // Reference to the game camera
          _initializerDefineProperty(_this, "camera", _descriptor6, _assertThisInitialized(_this));
          // Visual settings
          _initializerDefineProperty(_this, "tapFeedbackDuration", _descriptor7, _assertThisInitialized(_this));
          // Input processing state
          _this.isEnabled = true;
          // Lane information
          _this.laneWidth = 0;
          _this.laneCount = 4;
          _this.laneStartX = 0;
          // Touch tracking
          _this.activeTouches = new Map();
          // Callback for lane tap events
          _this._laneTapCallback = null;
          // Track which key corresponds to which lane for key up handling
          _this.activeKeyLanes = new Map();
          return _this;
        }
        var _proto = InputManager.prototype;
        _proto.onLoad = function onLoad() {
          // Initialize tap feedback nodes
          this.initTapFeedback();

          // Register event listeners
          this.registerEvents();
        };
        _proto.start = function start() {
          // Initialize lane information
          this.initLaneInfo();
        }

        /**
         * Initialize lane information
         */;
        _proto.initLaneInfo = function initLaneInfo() {
          if (!this.laneContainer) {
            console.error("Lane container is not assigned to InputManager");
            return;
          }
          var transform = this.laneContainer.getComponent(UITransform);
          if (!transform) {
            console.error("Lane container doesn't have a UITransform component");
            return;
          }

          // Calculate lane width
          this.laneCount = 4; // Magic Tiles typically has 4 lanes
          this.laneWidth = transform.width / this.laneCount;
          this.laneStartX = 0.0;
        }

        /**
         * Initialize tap feedback visual elements
         */;
        _proto.initTapFeedback = function initTapFeedback() {
          // Create tap feedback nodes if not provided
          if (this.tapFeedbackNodes.length < this.laneCount) {
            console.warn("Need " + this.laneCount + " tap feedback nodes, but only " + this.tapFeedbackNodes.length + " were provided.");

            // Create missing feedback nodes
            for (var i = this.tapFeedbackNodes.length; i < this.laneCount; i++) {
              var feedbackNode = new Node("TapFeedback_" + i);
              feedbackNode.parent = this.node;

              // Add visual components
              var sprite = feedbackNode.addComponent(Sprite);
              sprite.color = new Color(255, 255, 255, 120);

              // Add opacity component for fade effect
              var opacity = feedbackNode.addComponent(UIOpacity);
              opacity.opacity = 0;

              // Add to feedback nodes
              this.tapFeedbackNodes.push(feedbackNode);
            }
          }

          // Position tap feedback nodes
          for (var _i = 0; _i < this.laneCount; _i++) {
            var _feedbackNode = this.tapFeedbackNodes[_i];
            var transform = _feedbackNode.getComponent(UITransform) || _feedbackNode.addComponent(UITransform);

            // Size the feedback to fill the lane
            transform.width = this.laneWidth * 0.9; // Slightly smaller than lane
            transform.height = 100; // Height of the feedback indicator

            // Position at the hit line position (should match where tiles are hit)
            var xPos = this.laneStartX + (_i + 0.5) * this.laneWidth;
            var yPos = this.hitLineNode ? this.hitLineNode.position.y : 0;
            _feedbackNode.position = new Vec3(xPos, yPos, 0);
          }
        }

        /**
         * Register touch and mouse event listeners
         */;
        _proto.registerEvents = function registerEvents() {
          // Register touch events
          input.on(Input.EventType.TOUCH_START, this.onTouchStart, this);
          input.on(Input.EventType.TOUCH_MOVE, this.onTouchMove, this);
          input.on(Input.EventType.TOUCH_END, this.onTouchEnd, this);
          input.on(Input.EventType.TOUCH_CANCEL, this.onTouchCancel, this);

          // Register mouse events for desktop
          // input.on(Input.EventType.MOUSE_DOWN, this.onMouseDown, this);
          // input.on(Input.EventType.MOUSE_MOVE, this.onMouseMove, this);
          // input.on(Input.EventType.MOUSE_UP, this.onMouseUp, this);

          // Register keyboard events
          input.on(Input.EventType.KEY_DOWN, this.onKeyDown, this);
          input.on(Input.EventType.KEY_UP, this.onKeyUp, this);
        }

        /**
         * Unregister event listeners when component is destroyed
         */;
        _proto.onDestroy = function onDestroy() {
          // Unregister touch events
          input.off(Input.EventType.TOUCH_START, this.onTouchStart, this);
          input.off(Input.EventType.TOUCH_MOVE, this.onTouchMove, this);
          input.off(Input.EventType.TOUCH_END, this.onTouchEnd, this);
          input.off(Input.EventType.TOUCH_CANCEL, this.onTouchCancel, this);

          // Unregister mouse events
          // input.off(Input.EventType.MOUSE_DOWN, this.onMouseDown, this);
          // input.off(Input.EventType.MOUSE_MOVE, this.onMouseMove, this);
          // input.off(Input.EventType.MOUSE_UP, this.onMouseUp, this);

          // Unregister keyboard events
          input.off(Input.EventType.KEY_DOWN, this.onKeyDown, this);
          input.off(Input.EventType.KEY_UP, this.onKeyUp, this);
        }

        /**
         * Handle touch start event
         */;
        _proto.onTouchStart = function onTouchStart(event) {
          if (!this.isEnabled) return;
          var touches = event.getTouches();
          for (var _iterator = _createForOfIteratorHelperLoose(touches), _step; !(_step = _iterator()).done;) {
            var touch = _step.value;
            var touchLocation = touch.getLocation();
            var worldPos = this.convertToWorldSpace(touchLocation.x, touchLocation.y);

            // Determine which lane was touched
            var _lane = this.getLaneFromPosition(worldPos.x);
            if (_lane >= 0) {
              // Create touch info
              var touchInfo = {
                id: touch.getID(),
                lane: _lane,
                startTime: Date.now() / 1000,
                position: worldPos,
                active: true,
                node: this.tapFeedbackNodes[_lane]
              };

              // Store touch info
              this.activeTouches.set(touch.getID(), touchInfo);

              // Show tap feedback
              this.showTapFeedback(_lane);

              // Call the lane tap callback if registered
              if (this._laneTapCallback) {
                this._laneTapCallback(_lane);
              }

              // Notify the tile manager and tap validator about the touch
              var gameTime = this.tileManager.getGameTime();
              var rating = this.tileManager.handleLaneTouch(_lane, true);

              // Validate the tap
              this.tapValidator.validateTap(_lane, gameTime, rating);
            }
          }
        }

        /**
         * Handle touch move event
         */;
        _proto.onTouchMove = function onTouchMove(event) {
          if (!this.isEnabled) return;
          var touches = event.getTouches();
          for (var _iterator2 = _createForOfIteratorHelperLoose(touches), _step2; !(_step2 = _iterator2()).done;) {
            var touch = _step2.value;
            var touchID = touch.getID();
            if (this.activeTouches.has(touchID)) {
              var touchInfo = this.activeTouches.get(touchID);
              var touchLocation = touch.getLocation();
              var worldPos = this.convertToWorldSpace(touchLocation.x, touchLocation.y);

              // Update touch position
              touchInfo.position = worldPos;

              // Check if the touch moved to a different lane
              var newLane = this.getLaneFromPosition(worldPos.x);
              if (newLane >= 0 && newLane !== touchInfo.lane) {
                // End touch in current lane
                this.tileManager.handleLaneTouch(touchInfo.lane, false);

                // Hide feedback in old lane
                this.hideTapFeedback(touchInfo.lane);

                // Update lane
                touchInfo.lane = newLane;
                touchInfo.node = this.tapFeedbackNodes[newLane];

                // Show feedback in new lane
                this.showTapFeedback(newLane);

                // Start touch in new lane
                var gameTime = this.tileManager.getGameTime();
                var rating = this.tileManager.handleLaneTouch(newLane, true);

                // Validate the tap
                this.tapValidator.validateTap(newLane, gameTime, rating);
              }
            }
          }
        }

        /**
         * Handle touch end event
         */;
        _proto.onTouchEnd = function onTouchEnd(event) {
          if (!this.isEnabled) return;
          var touches = event.getTouches();
          for (var _iterator3 = _createForOfIteratorHelperLoose(touches), _step3; !(_step3 = _iterator3()).done;) {
            var touch = _step3.value;
            var touchID = touch.getID();
            if (this.activeTouches.has(touchID)) {
              var touchInfo = this.activeTouches.get(touchID);

              // Notify the tile manager about the touch end
              var gameTime = this.tileManager.getGameTime();
              var rating = this.tileManager.handleLaneTouch(touchInfo.lane, false);

              // Hide tap feedback
              this.hideTapFeedback(touchInfo.lane);

              // Remove from active touches
              this.activeTouches["delete"](touchID);
            }
          }
        }

        /**
         * Handle touch cancel event
         */;
        _proto.onTouchCancel = function onTouchCancel(event) {
          // Handle the same as touch end
          this.onTouchEnd(event);
        }

        /**
         * Handle mouse down event (for desktop)
         */;
        _proto.onMouseDown = function onMouseDown(event) {
          if (!this.isEnabled) return;
          var mouseLocation = event.getLocation();
          var worldPos = this.convertToWorldSpace(mouseLocation.x, mouseLocation.y);

          // Determine which lane was clicked
          var lane = this.getLaneFromPosition(worldPos.x);
          if (lane >= 0) {
            // Create touch info for mouse
            var touchInfo = {
              id: 0,
              // Use 0 for mouse
              lane: lane,
              startTime: Date.now() / 1000,
              position: worldPos,
              active: true,
              node: this.tapFeedbackNodes[lane]
            };

            // Store touch info
            this.activeTouches.set(0, touchInfo);

            // Show tap feedback
            this.showTapFeedback(lane);

            // Notify the tile manager and tap validator about the touch
            var gameTime = this.tileManager.getGameTime();
            var rating = this.tileManager.handleLaneTouch(lane, true);

            // Validate the tap
            this.tapValidator.validateTap(lane, gameTime, rating);
          }
        }

        /**
         * Handle mouse move event (for desktop)
         */;
        _proto.onMouseMove = function onMouseMove(event) {
          if (!this.isEnabled || !this.activeTouches.has(0)) return;
          var touchInfo = this.activeTouches.get(0);
          var mouseLocation = event.getLocation();
          var worldPos = this.convertToWorldSpace(mouseLocation.x, mouseLocation.y);

          // Update touch position
          touchInfo.position = worldPos;

          // Check if the mouse moved to a different lane
          var newLane = this.getLaneFromPosition(worldPos.x);
          if (newLane >= 0 && newLane !== touchInfo.lane) {
            // End touch in current lane
            this.tileManager.handleLaneTouch(touchInfo.lane, false);

            // Hide feedback in old lane
            this.hideTapFeedback(touchInfo.lane);

            // Update lane
            touchInfo.lane = newLane;
            touchInfo.node = this.tapFeedbackNodes[newLane];

            // Show feedback in new lane
            this.showTapFeedback(newLane);

            // Start touch in new lane
            var gameTime = this.tileManager.getGameTime();
            var rating = this.tileManager.handleLaneTouch(newLane, true);

            // Validate the tap
            this.tapValidator.validateTap(newLane, gameTime, rating);
          }
        }

        /**
         * Handle mouse up event (for desktop)
         */;
        _proto.onMouseUp = function onMouseUp(event) {
          if (!this.isEnabled || !this.activeTouches.has(0)) return;
          var touchInfo = this.activeTouches.get(0);

          // Notify the tile manager about the touch end
          var gameTime = this.tileManager.getGameTime();
          var rating = this.tileManager.handleLaneTouch(touchInfo.lane, false);

          // Hide tap feedback
          this.hideTapFeedback(touchInfo.lane);

          // Remove from active touches
          this.activeTouches["delete"](0);
        }

        /**
         * Show visual feedback for a tap in a lane
         */;
        _proto.showTapFeedback = function showTapFeedback(lane) {
          var _this2 = this;
          if (lane < 0 || lane >= this.tapFeedbackNodes.length) return;
          var feedbackNode = this.tapFeedbackNodes[lane];
          var opacity = feedbackNode.getComponent(UIOpacity);

          // Reset opacity
          if (opacity) {
            opacity.opacity = 255;

            // Schedule fade out
            this.scheduleOnce(function () {
              _this2.hideTapFeedback(lane);
            }, this.tapFeedbackDuration);
          }
        }

        /**
         * Hide visual feedback for a tap in a lane
         */;
        _proto.hideTapFeedback = function hideTapFeedback(lane) {
          if (lane < 0 || lane >= this.tapFeedbackNodes.length) return;
          var feedbackNode = this.tapFeedbackNodes[lane];
          var opacity = feedbackNode.getComponent(UIOpacity);

          // Fade out
          if (opacity) {
            opacity.opacity = 0;
          }
        }

        /**
         * Convert screen coordinates to world space
         */;
        _proto.convertToWorldSpace = function convertToWorldSpace(x, y) {
          var camera = this.camera;
          if (!camera) {
            // Fallback to manual conversion if no camera is found
            var transform = this.node.getComponent(UITransform);
            if (!transform) return new Vec3(x, y, 0);
            var width = transform.width;
            var height = transform.height;

            // Convert to centered coordinates
            var worldX = x - width / 2;
            var worldY = y - height / 2;
            return new Vec3(worldX, worldY, 0);
          }

          // Create a Vec3 with the screen position
          var screenPos = new Vec3(x, y, 0);

          // Convert screen position to world position
          return camera.screenToWorld(screenPos);
        }

        /**s
         * Get the lane index from a world position
         */;
        _proto.getLaneFromPosition = function getLaneFromPosition(x) {
          // Calculate which lane the x position falls into
          var relativeX = x - this.laneStartX;
          if (relativeX < 0 || relativeX >= this.laneWidth * this.laneCount) {
            return -1; // Outside the valid lane area
          }

          return Math.floor(relativeX / this.laneWidth);
        }

        /**
         * Enable or disable input processing
         */;
        _proto.setEnabled = function setEnabled(enabled) {
          this.isEnabled = enabled;

          // Clear active touches when disabled
          if (!enabled) {
            this.activeTouches.clear();
            for (var i = 0; i < this.tapFeedbackNodes.length; i++) {
              this.hideTapFeedback(i);
            }
          }
        }

        /**
         * Check if input processing is enabled
         */;
        _proto.isInputEnabled = function isInputEnabled() {
          return this.isEnabled;
        }

        /**
         * Get the active touch for a lane (if any)
         */;
        _proto.getActiveTouchInLane = function getActiveTouchInLane(lane) {
          for (var _iterator4 = _createForOfIteratorHelperLoose(this.activeTouches), _step4; !(_step4 = _iterator4()).done;) {
            var _step4$value = _step4.value,
              _ = _step4$value[0],
              touchInfo = _step4$value[1];
            if (touchInfo.lane === lane) {
              return touchInfo;
            }
          }
          return null;
        }

        /**
         * Get the number of active touches
         */;
        _proto.getActiveTouchCount = function getActiveTouchCount() {
          return this.activeTouches.size;
        }

        /**
         * Register a callback for lane tap events
         * @param callback Function to call when a lane is tapped
         */;
        _proto.onLaneTap = function onLaneTap(callback) {
          // Store the callback
          this._laneTapCallback = callback;
        }

        /**
         * Remove a callback for lane tap events
         * @param callback Function to remove
         */;
        _proto.removeOnLaneTap = function removeOnLaneTap(callback) {
          // Remove the callback if it matches
          if (this._laneTapCallback === callback) {
            this._laneTapCallback = null;
          }
        }

        /**
         * Handle keyboard input
         * Maps keys to lanes:
         * - a: lane 0
         * - s: lane 1
         * - d: lane 2
         * - f: lane 3
         */;
        _proto.onKeyDown = function onKeyDown(event) {
          if (!this.isEnabled) return;
          var lane = -1;

          // Map keys to lanes
          switch (event.keyCode) {
            case KeyCode.KEY_A:
              // 'a' key
              lane = 0;
              break;
            case KeyCode.KEY_S:
              // 's' key
              lane = 1;
              break;
            case KeyCode.KEY_D:
              // 'd' key
              lane = 2;
              break;
            case KeyCode.KEY_F:
              // 'f' key
              lane = 3;
              break;
          }

          // If valid lane was pressed
          if (lane >= 0 && lane < this.laneCount) {
            // Store which key is active for which lane
            this.activeKeyLanes.set(event.keyCode, lane);

            // Show tap feedback
            this.showTapFeedback(lane);

            // Call the lane tap callback if registered
            if (this._laneTapCallback) {
              this._laneTapCallback(lane);
            }

            // Notify the tile manager and tap validator about the key press
            var gameTime = this.tileManager.getGameTime();
            var rating = this.tileManager.handleLaneTouch(lane, true);

            // Validate the tap
            this.tapValidator.validateTap(lane, gameTime, rating);
          }
        }

        /**
         * Handle key up events
         */;
        _proto.onKeyUp = function onKeyUp(event) {
          if (!this.isEnabled) return;

          // Check if this key was being tracked
          if (this.activeKeyLanes.has(event.keyCode)) {
            var _lane2 = this.activeKeyLanes.get(event.keyCode);

            // Notify the tile manager about the key release
            var gameTime = this.tileManager.getGameTime();
            var rating = this.tileManager.handleLaneTouch(_lane2, false);

            // Hide tap feedback
            this.hideTapFeedback(_lane2);

            // Remove from active keyss 
            this.activeKeyLanes["delete"](event.keyCode);
          }
        };
        return InputManager;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "tapFeedbackNodes", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "hitLineNode", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "laneContainer", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "tileManager", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "tapValidator", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "camera", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "tapFeedbackDuration", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.2;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/InteractableItem.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Node, NodeEventType, UITransform, rect, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      NodeEventType = module.NodeEventType;
      UITransform = module.UITransform;
      rect = module.rect;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "05db20FCuhNgIZ/Of1+Usnv", "InteractableItem", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var InteractableItem = exports('InteractableItem', (_dec = ccclass('InteractableItem'), _dec2 = property(Node), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(InteractableItem, _Component);
        function InteractableItem() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "nodeTouch", _descriptor, _assertThisInitialized(_this));
          //#region interaction
          _this.onSelected = null;
          _this.onStart = null;
          _this.onDrag = null;
          _this.onHover = null;
          _this.onEndInteracted = null;
          _this.isInteracting = false;
          _this.passThroughNode = null;
          _this.dragCount = 0;
          _this.interactNode = null;
          _this.transform = null;
          return _this;
        }
        var _proto = InteractableItem.prototype;
        _proto.setInteractable = function setInteractable(isInteractable, eventThroughNode) {
          var _this$nodeTouch;
          if (eventThroughNode === void 0) {
            eventThroughNode = null;
          }
          this.passThroughNode = eventThroughNode;
          var interactedNode = (_this$nodeTouch = this.nodeTouch) != null ? _this$nodeTouch : this.node;
          if (isInteractable) {
            interactedNode.on(NodeEventType.TOUCH_END, this.onTouchEnd, this);
            interactedNode.on(NodeEventType.TOUCH_START, this.onTouchStart, this);
            interactedNode.on(NodeEventType.TOUCH_MOVE, this.onTouchMove, this);
            interactedNode.on(NodeEventType.MOUSE_ENTER, this.onMouseHover, this);
            interactedNode.on(NodeEventType.MOUSE_LEAVE, this.onMouseLeave, this);
          } else {
            interactedNode.off(NodeEventType.TOUCH_END, this.onTouchEnd, this);
            interactedNode.off(NodeEventType.TOUCH_START, this.onTouchStart, this);
            interactedNode.off(NodeEventType.TOUCH_MOVE, this.onTouchMove, this);
            interactedNode.off(NodeEventType.MOUSE_ENTER, this.onMouseHover, this);
            interactedNode.off(NodeEventType.MOUSE_LEAVE, this.onMouseLeave, this);
          }
        };
        _proto.getTransform = function getTransform() {
          if (this.transform == null) {
            var _this$nodeTouch2;
            this.interactNode = (_this$nodeTouch2 = this.nodeTouch) != null ? _this$nodeTouch2 : this.node;
            this.transform = this.interactNode.getComponent(UITransform);
          }
          return this.transform;
        };
        _proto.isContainsPosition = function isContainsPosition(pos) {
          var nodeSize = this.getTransform().contentSize;
          var nodeRect = rect(this.interactNode.position.x - nodeSize.width / 2, this.interactNode.position.y - nodeSize.height / 2, nodeSize.width, nodeSize.height);
          return nodeRect.contains(pos);
        };
        _proto.onTouchEnd = function onTouchEnd(event) {
          var _this$onEndInteracted;
          if (this.dragCount <= 4) {
            var _this$onSelected;
            (_this$onSelected = this.onSelected) == null || _this$onSelected.call(this, this);
          }
          this.dragCount = 0;
          this.isInteracting = false;
          this.checkPassThroughNode(NodeEventType.TOUCH_END, event);
          (_this$onEndInteracted = this.onEndInteracted) == null || _this$onEndInteracted.call(this, this);
        };
        _proto.onTouchStart = function onTouchStart(event) {
          var _this$onStart;
          this.dragCount = 0;
          this.isInteracting = true;
          this.checkPassThroughNode(NodeEventType.TOUCH_START, event);
          (_this$onStart = this.onStart) == null || _this$onStart.call(this, this);
        };
        _proto.onTouchMove = function onTouchMove(event) {
          this.dragCount++;
          this.checkPassThroughNode(NodeEventType.TOUCH_MOVE, event);
          if (this.dragCount >= 4) {
            var _this$onDrag;
            (_this$onDrag = this.onDrag) == null || _this$onDrag.call(this, this);
          }
        };
        _proto.onMouseHover = function onMouseHover(event) {
          var _this$onHover;
          this.checkPassThroughNode(NodeEventType.MOUSE_ENTER, event);
          (_this$onHover = this.onHover) == null || _this$onHover.call(this, this);
        };
        _proto.onMouseLeave = function onMouseLeave(event) {
          var _this$onEndInteracted2;
          this.checkPassThroughNode(NodeEventType.MOUSE_ENTER, event);
          this.isInteracting = false;
          (_this$onEndInteracted2 = this.onEndInteracted) == null || _this$onEndInteracted2.call(this, this);
        };
        _proto.checkPassThroughNode = function checkPassThroughNode(eventType, event) {
          if (!this.passThroughNode) return;
          this.passThroughNode.emit(eventType, event);
        }

        //#endregion
        ;

        return InteractableItem;
      }(Component), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "nodeTouch", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/interface.ts", ['cc'], function () {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "40680UcTm9G/ZhjtPkyAjKr", "interface", undefined);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/inverse-lerp.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "c589fRsjwlOb5Fzx0G64yl/", "inverse-lerp", undefined);
      var InverseLerp = exports('default', (_dec = register({
        menu: 'Math/Interpolation/InverseLerp',
        title: 'InverseLerp'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(InverseLerp, _ShaderNode);
        function InverseLerp() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector'), slot('T', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = InverseLerp.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var input2 = this.getInputValue(2);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = (" + input2 + " - " + input0 + ") / (" + input1 + " - " + input0 + ");\n        ";
        };
        return InverseLerp;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/is-nan.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "c8ed6hsGT1HOKJ9Qr9y8+aM", "is-nan", undefined);
      var IsNan = exports('default', (_dec = register({
        menu: 'Logic/IsNan',
        title: 'IsNan'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(IsNan, _ShaderNode);
        function IsNan() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.fixedConcretePrecision = 1;
          _this.data = {
            inputs: [slot('In', 0, 'float', 'vector')],
            outputs: [slot('Out', false, 'boolean', 'boolean')]
          };
          return _this;
        }
        var _proto = IsNan.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var i0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = isnan(" + i0 + ");\n        ";
        };
        return IsNan;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/LayoutManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Manager.ts', './enum.ts', './helper.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Manager, ChildAlignment, Orientation, Helper;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
    }, function (module) {
      Manager = module.Manager;
    }, function (module) {
      ChildAlignment = module.ChildAlignment;
      Orientation = module.Orientation;
    }, function (module) {
      Helper = module.Helper;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _class3;
      cclegacy._RF.push({}, "9a8caWSYQZLqr6N7OEAXSa7", "LayoutManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var Event = /*#__PURE__*/function (Event) {
        Event[Event["ON_LAYOUT_COMPLATED"] = 0] = "ON_LAYOUT_COMPLATED";
        Event[Event["ON_CHANGED_LAYOUT_STATE"] = 1] = "ON_CHANGED_LAYOUT_STATE";
        return Event;
      }(Event || {});
      var LayoutManager = exports('LayoutManager', (_dec = ccclass('LayoutManager'), _dec2 = property({
        type: ChildAlignment
      }), _dec3 = property({
        type: ChildAlignment,
        tooltip: ""
      }), _dec4 = property({
        tooltip: ""
      }), _dec5 = property({
        tooltip: ""
      }), _dec6 = property({
        tooltip: ""
      }), _dec7 = property({
        group: {
          id: "0",
          name: "forceExpand"
        },
        tooltip: ""
      }), _dec8 = property({
        group: {
          id: "0",
          name: "forceExpand"
        },
        tooltip: ""
      }), _dec9 = property({
        group: {
          id: "0",
          name: "controlSize"
        },
        tooltip: " false\n true IElement.minSizeIElement.preferredSizeIElement.flexibleSizeIElement.minSizeIElement.preferredSizeIElement.flexibleSize"
      }), _dec10 = property({
        group: {
          id: "0",
          name: "controlSize"
        },
        tooltip: " false\n true IElement.minSizeIElement.preferredSizeIElement.flexibleSizeIElement.minSizeIElement.preferredSizeIElement.flexibleSize"
      }), _dec11 = property({
        group: {
          id: "0",
          name: "controlScale"
        },
        tooltip: " x "
      }), _dec12 = property({
        group: {
          id: "0",
          name: "controlScale"
        },
        tooltip: " y "
      }), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Manager) {
        _inheritsLoose(LayoutManager, _Manager);
        function LayoutManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Manager.call.apply(_Manager, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "_childAlignment", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "_spacing", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "_reverseArrangement", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "delayLayout", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "_forceExpandWidth", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "_forceExpandHeight", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "_controlSizeWidth", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "_controlSizeHeight", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "_controlScaleWidth", _descriptor9, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "_controlScaleHeight", _descriptor10, _assertThisInitialized(_this));
          _this._isDirty = false;
          _this._layoutQueue = [];
          return _this;
        }
        var _proto = LayoutManager.prototype;
        _proto.onInit = function onInit() {};
        _proto.layout = function layout(group) {
          if (!group) return;
          if (this.delayLayout) {
            this.unLayout(group.index);
            this._layoutQueue.push(group);
            this._isDirty = true;
          } else {
            this._layoutHandler(group);
            this.emit(Event.ON_LAYOUT_COMPLATED, [group.index]);
          }
        };
        _proto.unLayout = function unLayout(index) {
          var index = this._layoutQueue.findIndex(function (item) {
            return item.index == index;
          });
          if (-1 != index) {
            this._layoutQueue.splice(index, 1);
          }
        };
        _proto._layoutHandler = function _layoutHandler(group) {
          this._calcAlongAxis(group, Orientation.Horizontal, this.adapter.isHorizontal);
          this._setChildrenAlongAxis(group, Orientation.Horizontal, this.adapter.isHorizontal);
          this._calcAlongAxis(group, Orientation.Vertical, this.adapter.isHorizontal);
          this._setChildrenAlongAxis(group, Orientation.Vertical, this.adapter.isHorizontal);
        };
        _proto._calcAlongAxis = function _calcAlongAxis(group, axis, isVertical) {
          var combinedPadding = axis == Orientation.Horizontal ? this.horizontal : this.vertical;
          var controlSize = this._getControlSize(axis);
          var controlScale = this._getControlScale(axis);
          var forceExpand = this._getForceExpandSize(axis);
          var totalMin = combinedPadding;
          var totalPreferred = combinedPadding;
          var totalFlexible = 0;
          var alongOtherAxis = isVertical != (axis == Orientation.Vertical);
          var layoutList = this._getLayoutList(group.models);
          for (var i = 0; i < layoutList.length; i++) {
            var model = layoutList[i];
            var _this$_getChildSizes = this._getChildSizes(model, axis, controlSize, forceExpand),
              min = _this$_getChildSizes.min,
              preferred = _this$_getChildSizes.preferred,
              flexible = _this$_getChildSizes.flexible;
            if (controlScale) {
              var scaleFactor = model.scale[this._getAxis(axis)];
              min *= scaleFactor;
              preferred *= scaleFactor;
              flexible *= scaleFactor;
            }
            if (alongOtherAxis) {
              totalMin = Math.max(min + combinedPadding, totalMin);
              totalPreferred = Math.max(preferred + combinedPadding, totalPreferred);
              totalFlexible = Math.max(flexible, totalFlexible);
            } else {
              totalMin += min + this.spacing;
              totalPreferred += preferred + this.spacing;
              totalFlexible += flexible;
            }
          }
          if (!alongOtherAxis && layoutList.length > 0) {
            totalMin -= this.spacing;
            totalPreferred -= this.spacing;
          }
          totalPreferred = Math.max(totalMin, totalPreferred);
          this._setLayoutInputForAxis(group, totalMin, totalPreferred, totalFlexible, axis);
        };
        _proto._getControlSize = function _getControlSize(axis) {
          return axis == Orientation.Horizontal ? this.controlSizeWidth : this.controlSizeHeight;
        };
        _proto._getControlScale = function _getControlScale(axis) {
          return axis == Orientation.Horizontal ? this.controlScaleWidth : this.controlScaleHeight;
        };
        _proto._getForceExpandSize = function _getForceExpandSize(axis) {
          return axis == Orientation.Horizontal ? this.forceExpandWidth : this.forceExpandHeight;
        };
        _proto._setChildrenAlongAxis = function _setChildrenAlongAxis(group, axis, isVertical) {
          var size = group.size[this._getAxis(axis)];
          var controlSize = this._getControlSize(axis);
          var controlScale = this._getControlScale(axis);
          var forceExpand = this._getForceExpandSize(axis);
          var alignmentOnAxis = this._getAlignmentOnAxis(axis);
          var layoutList = this._getLayoutList(group.models);
          var alongOtherAxis = isVertical != (axis == Orientation.Vertical);
          var startIndex = this.reverseArrangement ? layoutList.length - 1 : 0;
          var endIndex = this.reverseArrangement ? 0 : layoutList.length;
          var increment = this.reverseArrangement ? -1 : 1;
          var key = this._getAxis(axis);
          if (alongOtherAxis) {
            var innerSize = size - (axis == Orientation.Horizontal ? this.horizontal : this.vertical);
            for (var i = startIndex; this.reverseArrangement ? i >= endIndex : i < endIndex; i += increment) {
              var _model = layoutList[i];
              var _this$_getChildSizes2 = this._getChildSizes(_model, axis, controlSize, forceExpand),
                min = _this$_getChildSizes2.min,
                preferred = _this$_getChildSizes2.preferred,
                flexible = _this$_getChildSizes2.flexible;
              var scaleFactor = controlScale ? _model.scale[key] : 1;
              var requiredSpace = Helper.clamp(innerSize, min, flexible > 0 ? size : preferred);
              var startOffset = this._getStartOffset(group, axis, requiredSpace * scaleFactor);
              if (controlSize) {
                this._setChildAlongAxisWithScale(group, _model, axis, startOffset, scaleFactor, requiredSpace);
              } else {
                var offsetInCell = (requiredSpace - _model.size[key]) * alignmentOnAxis;
                offsetInCell *= scaleFactor;
                this._setChildAlongAxisWithScale(group, _model, axis, startOffset + offsetInCell, scaleFactor);
              }
            }
          } else {
            var pos = axis == Orientation.Horizontal ? this.left : this.top;
            var itemFlexibleMultiplier = 0;
            var surplusSpace = size - this._getTotalPreferredSize(group, axis);
            if (surplusSpace > 0) {
              if (this._getTotalFlexibleSize(group, axis) == 0) {
                pos = this._getStartOffset(group, axis, this._getTotalPreferredSize(group, axis) - (axis == Orientation.Horizontal ? this.horizontal : this.vertical));
              } else if (this._getTotalFlexibleSize(group, axis) > 0) {
                itemFlexibleMultiplier = surplusSpace / this._getTotalFlexibleSize(group, axis);
              }
            }
            var minMaxLerp = 0;
            if (this._getTotalMinSize(group, axis) != this._getTotalPreferredSize(group, axis)) {
              minMaxLerp = Helper.clamp01((size - this._getTotalMinSize(group, axis)) / (this._getTotalPreferredSize(group, axis) - this._getTotalMinSize(group, axis)));
            }
            for (var i = startIndex; this.reverseArrangement ? i >= endIndex : i < endIndex; i += increment) {
              var model = layoutList[i];
              var _this$_getChildSizes3 = this._getChildSizes(model, axis, controlSize, forceExpand),
                min = _this$_getChildSizes3.min,
                preferred = _this$_getChildSizes3.preferred,
                flexible = _this$_getChildSizes3.flexible;
              var _scaleFactor = controlScale ? model.scale[key] : 1;
              var childSize = Helper.lerp(min, preferred, minMaxLerp);
              childSize += flexible * itemFlexibleMultiplier;
              if (controlSize) {
                this._setChildAlongAxisWithScale(group, model, axis, pos, _scaleFactor, childSize);
              } else {
                var offsetInCell = (childSize - model.size[key]) * alignmentOnAxis;
                this._setChildAlongAxisWithScale(group, model, axis, pos + offsetInCell, _scaleFactor);
              }
              pos += childSize * _scaleFactor + this.spacing;
            }
          }
        };
        _proto._setChildAlongAxisWithScale = function _setChildAlongAxisWithScale(group, model, axis, pos, scaleFactor, size) {
          if (model == null) return;
          var key = this._getAxis(axis);
          var layoutSize = 0;
          if (!isNaN(size)) {
            model.layoutSize[key] = size;
            layoutSize = size;
          } else {
            layoutSize = model.size[key];
          }
          var position = {
            x: model.position.x,
            y: model.position.y
          };
          var value = 0;
          if (axis == Orientation.Horizontal) {
            value = pos + layoutSize * model.anchorPoint[key] * scaleFactor;
            value -= group.size[key] * group.anchorPoint[key];
            value += group.position[key];
          } else {
            value = -pos - layoutSize * (1 - model.anchorPoint[key]) * scaleFactor;
            value += group.size[key] * (1 - group.anchorPoint[key]);
            value += group.position[key];
          }
          position[key] = value;
          model.position = position;
        };
        _proto._getStartOffset = function _getStartOffset(group, axis, requiredSpaceWithoutPadding) {
          var requiredSpace = requiredSpaceWithoutPadding + (axis == Orientation.Horizontal ? this.horizontal : this.vertical);
          var availableSpace = group.size[this._getAxis(axis)];
          var surplusSpace = availableSpace - requiredSpace;
          var alignmentOnAxis = this._getAlignmentOnAxis(axis);
          return (axis == Orientation.Horizontal ? this.left : this.top) + surplusSpace * alignmentOnAxis;
        };
        _proto._setLayoutInputForAxis = function _setLayoutInputForAxis(group, totalMin, totalPreferred, totalFlexible, axis) {
          var key = this._getAxis(axis);
          group.totalMinSize[key] = totalMin;
          group.totalPreferredSize[key] = totalPreferred;
          group.totalFlexibleSize[key] = totalFlexible;
        };
        _proto._getAxis = function _getAxis(axis) {
          return axis == Orientation.Horizontal ? "x" : "y";
        };
        _proto._getMinSize = function _getMinSize(element, axis) {
          return element.minSize[this._getAxis(axis)];
        };
        _proto._getPreferredSize = function _getPreferredSize(element, axis) {
          var key = this._getAxis(axis);
          return Math.max(element.minSize[key], element.preferredSize[key]);
        };
        _proto._getFlexibleSize = function _getFlexibleSize(element, axis) {
          return element.flexibleSize[this._getAxis(axis)];
        };
        _proto._getTotalMinSize = function _getTotalMinSize(group, axis) {
          return group.totalMinSize[this._getAxis(axis)];
        };
        _proto._getTotalPreferredSize = function _getTotalPreferredSize(group, axis) {
          return group.totalPreferredSize[this._getAxis(axis)];
        };
        _proto._getTotalFlexibleSize = function _getTotalFlexibleSize(group, axis) {
          return group.totalFlexibleSize[this._getAxis(axis)];
        };
        _proto._getChildSizes = function _getChildSizes(model, axis, controlSize, childForceExpand) {
          var min, preferred, flexible;
          if (!controlSize) {
            min = model.size[this._getAxis(axis)];
            preferred = min;
            flexible = 0;
          } else {
            min = this._getMinSize(model.element, axis);
            preferred = this._getPreferredSize(model.element, axis);
            flexible = this._getFlexibleSize(model.element, axis);
          }
          if (childForceExpand) {
            flexible = Math.max(flexible, 1);
          }
          return {
            min: min,
            preferred: preferred,
            flexible: flexible
          };
        };
        _proto._getAlignmentOnAxis = function _getAlignmentOnAxis(axis) {
          if (axis == Orientation.Horizontal) {
            return this.adapter.layoutManager.childAlignment % 3 * 0.5;
          } else {
            return Math.floor(this.adapter.layoutManager.childAlignment / 3) * 0.5;
          }
        };
        _proto._getLayoutList = function _getLayoutList(models) {
          var list = [];
          for (var i = 0; i < models.length; i++) {
            var model = models[i];
            if (model.element.ignoreLayout) continue;
            list.push(model);
          }
          return list;
        }
        /** @deprecated  */;
        _proto.internal_lateUpdate = function internal_lateUpdate(deltaTime) {
          if (this._isDirty) {
            this._isDirty = false;
            var complatedIndexs = [];
            while (this._layoutQueue.length > 0) {
              var item = this._layoutQueue.shift();
              this._layoutHandler(item);
              complatedIndexs.push(item.index);
            }
            if (complatedIndexs.length > 0) {
              this.emit(Event.ON_LAYOUT_COMPLATED, complatedIndexs);
            }
          }
        };
        _createClass(LayoutManager, [{
          key: "childAlignment",
          get: function get() {
            return this._childAlignment;
          },
          set: function set(value) {
            if (value == this._childAlignment) return;
            this._childAlignment = value;
            this.emit(Event.ON_CHANGED_LAYOUT_STATE);
          }
        }, {
          key: "spacing",
          get: function get() {
            return this._spacing;
          },
          set: function set(value) {
            if (value == this._spacing) return;
            this._spacing = value;
            this.emit(Event.ON_CHANGED_LAYOUT_STATE);
          }
        }, {
          key: "reverseArrangement",
          get: function get() {
            return this._reverseArrangement;
          },
          set: function set(value) {
            if (value == this._reverseArrangement) return;
            this._reverseArrangement = value;
            this.emit(Event.ON_CHANGED_LAYOUT_STATE);
          }
        }, {
          key: "forceExpandWidth",
          get: function get() {
            return this._forceExpandWidth;
          },
          set: function set(value) {
            if (value == this._forceExpandWidth) return;
            this._forceExpandWidth = value;
            this.emit(Event.ON_CHANGED_LAYOUT_STATE);
          }
        }, {
          key: "forceExpandHeight",
          get: function get() {
            return this._forceExpandHeight;
          },
          set: function set(value) {
            if (value == this._forceExpandHeight) return;
            this._forceExpandHeight = value;
            this.emit(Event.ON_CHANGED_LAYOUT_STATE);
          }
        }, {
          key: "controlSizeWidth",
          get: function get() {
            return this._controlSizeWidth;
          },
          set: function set(value) {
            if (value == this._controlSizeWidth) return;
            this._controlSizeWidth = value;
            this.emit(Event.ON_CHANGED_LAYOUT_STATE);
          }
        }, {
          key: "controlSizeHeight",
          get: function get() {
            return this._controlSizeHeight;
          },
          set: function set(value) {
            if (value == this._controlSizeHeight) return;
            this._controlSizeHeight = value;
            this.emit(Event.ON_CHANGED_LAYOUT_STATE);
          }
        }, {
          key: "controlScaleWidth",
          get: function get() {
            return this._controlScaleWidth;
          },
          set: function set(value) {
            if (value == this._controlScaleWidth) return;
            this._controlScaleWidth = value;
            this.emit(Event.ON_CHANGED_LAYOUT_STATE);
          }
        }, {
          key: "controlScaleHeight",
          get: function get() {
            return this._controlScaleHeight;
          },
          set: function set(value) {
            if (value == this._controlScaleHeight) return;
            this._controlScaleHeight = value;
            this.emit(Event.ON_CHANGED_LAYOUT_STATE);
          }
        }, {
          key: "top",
          get: function get() {
            if (this.adapter.isVertical) return 0;
            return this.adapter.viewManager.top;
          }
        }, {
          key: "bottom",
          get: function get() {
            if (this.adapter.isVertical) return 0;
            return this.adapter.viewManager.bottom;
          }
        }, {
          key: "left",
          get: function get() {
            if (this.adapter.isHorizontal) return 0;
            return this.adapter.viewManager.left;
          }
        }, {
          key: "right",
          get: function get() {
            if (this.adapter.isHorizontal) return 0;
            return this.adapter.viewManager.right;
          }
        }, {
          key: "horizontal",
          get: function get() {
            return this.left + this.right;
          }
        }, {
          key: "vertical",
          get: function get() {
            return this.top + this.bottom;
          }
        }, {
          key: "isControlMainAxisSize",
          get: function get() {
            return this.adapter.isHorizontal && this.controlSizeWidth || this.adapter.isVertical && this.controlSizeHeight;
          }
        }, {
          key: "isControlCrossAxisSize",
          get: function get() {
            return this.adapter.isHorizontal && this.controlSizeHeight || this.adapter.isVertical && this.controlSizeWidth;
          }
        }, {
          key: "isControlCrossAxisScale",
          get: function get() {
            return this.adapter.isHorizontal && this.controlScaleHeight || this.adapter.isVertical && this.controlScaleWidth;
          }
        }]);
        return LayoutManager;
      }(Manager), _class3.Event = Event, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "_childAlignment", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ChildAlignment.UpperLeft;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "childAlignment", [_dec3], Object.getOwnPropertyDescriptor(_class2.prototype, "childAlignment"), _class2.prototype), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_spacing", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "spacing", [_dec4], Object.getOwnPropertyDescriptor(_class2.prototype, "spacing"), _class2.prototype), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_reverseArrangement", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "reverseArrangement", [_dec5], Object.getOwnPropertyDescriptor(_class2.prototype, "reverseArrangement"), _class2.prototype), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "delayLayout", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_forceExpandWidth", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "forceExpandWidth", [_dec7], Object.getOwnPropertyDescriptor(_class2.prototype, "forceExpandWidth"), _class2.prototype), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "_forceExpandHeight", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "forceExpandHeight", [_dec8], Object.getOwnPropertyDescriptor(_class2.prototype, "forceExpandHeight"), _class2.prototype), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "_controlSizeWidth", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "controlSizeWidth", [_dec9], Object.getOwnPropertyDescriptor(_class2.prototype, "controlSizeWidth"), _class2.prototype), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "_controlSizeHeight", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "controlSizeHeight", [_dec10], Object.getOwnPropertyDescriptor(_class2.prototype, "controlSizeHeight"), _class2.prototype), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "_controlScaleWidth", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "controlScaleWidth", [_dec11], Object.getOwnPropertyDescriptor(_class2.prototype, "controlScaleWidth"), _class2.prototype), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "_controlScaleHeight", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "controlScaleHeight", [_dec12], Object.getOwnPropertyDescriptor(_class2.prototype, "controlScaleHeight"), _class2.prototype)), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/length.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "d16658ODu5NPKUU74aU5bA5", "length", undefined);
      var Length = exports('default', (_dec = register({
        menu: 'Math/Advanced/Length',
        title: 'Length'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Length, _ShaderNode);
        function Length() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Length.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = length(" + input0 + ");\n        ";
        };
        return Length;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/lerp.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "0583aaFcfFDfr3SugrLLX4t", "lerp", undefined);
      var Lerp = exports('default', (_dec = register({
        menu: 'Math/Interpolation/Lerp',
        title: 'Lerp'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Lerp, _ShaderNode);
        function Lerp() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Max;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector'), slot('T', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Lerp.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var input2 = this.getInputValue(2);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = mix(" + input0 + ", " + input1 + ", " + input2 + ");\n        ";
        };
        return Lerp;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/localConfig.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './csvManager.ts', './resourceUtil.ts'], function (exports) {
  var _createClass, cclegacy, _decorator, resources, CSVManager, resourceUtil;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      resources = module.resources;
    }, function (module) {
      CSVManager = module.CSVManager;
    }, function (module) {
      resourceUtil = module.resourceUtil;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "aca4damK49DYqlWPDNwTrSS", "localConfig", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var LocalConfig = exports('LocalConfig', (_dec = ccclass("LocalConfig"), _dec(_class = (_class2 = /*#__PURE__*/function () {
        function LocalConfig() {
          this._csvManager = new CSVManager();
          this._callback = new Function();
          this._currentLoad = 0;
          this._cntLoad = 0;
        }
        var _proto = LocalConfig.prototype;
        _proto.loadConfig = function loadConfig(cb) {
          this._callback = cb;
          this._loadCSV();
        };
        _proto._loadCSV = function _loadCSV() {
          var _this = this;
          resources.loadDir("datas", function (err, assets) {
            if (err) {
              return;
            }
            var arrCsvFiles = assets.filter(function (item) {
              return item._native !== ".md";
            });
            _this._cntLoad = arrCsvFiles.length;
            if (arrCsvFiles.length) {
              arrCsvFiles.forEach(function (item, index, array) {
                resourceUtil.getTextData(item.name, function (content) {
                  _this._csvManager.addTable(item.name, content);
                  _this._tryToCallbackOnFinished();
                });
              });
            } else {
              _this._tryToCallbackOnFinished();
            }
          });
        };
        _proto.queryOne = function queryOne(tableName, key, value) {
          return this._csvManager.queryOne(tableName, key, value);
        };
        _proto.queryByID = function queryByID(tableName, ID) {
          return this._csvManager.queryByID(tableName, ID);
        };
        _proto.getTable = function getTable(tableName) {
          return this._csvManager.getTable(tableName);
        };
        _proto.getTableArr = function getTableArr(tableName) {
          return this._csvManager.getTableArr(tableName);
        };
        _proto.queryAll = function queryAll(tableName, key, value) {
          return this._csvManager.queryAll(tableName, key, value);
        };
        _proto.queryIn = function queryIn(tableName, key, values) {
          return this._csvManager.queryIn(tableName, key, values);
        };
        _proto.queryByCondition = function queryByCondition(tableName, condition) {
          return this._csvManager.queryByCondition(tableName, condition);
        };
        _proto._tryToCallbackOnFinished = function _tryToCallbackOnFinished() {
          if (this._callback) {
            this._currentLoad++;
            if (this._currentLoad >= this._cntLoad) {
              this._callback();
            }
          }
        };
        _createClass(LocalConfig, null, [{
          key: "instance",
          get: function get() {
            if (this._instance) {
              return this._instance;
            }
            this._instance = new LocalConfig();
            return this._instance;
          }
        }]);
        return LocalConfig;
      }(), _class2._instance = void 0, _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/lodash.ts", ['cc'], function (exports) {
  var cclegacy, _decorator;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "6743cVJ1/1Ha68y/dyVx1hh", "lodash", undefined);
      var ccclass = _decorator.ccclass;
      var lodash = exports('lodash', (_dec = ccclass("lodash"), _dec(_class = (_class2 = /*#__PURE__*/function () {
        function lodash() {}
        /* class member could be defined like this */
        // dummy = '';
        /**
         * @param  {any} collection 
         * @param {Function} predicate 
         */
        lodash.find = function find(collection, predicate) {
          var result;
          if (!Array.isArray(collection)) {
            collection = lodash._toArray(collection);
          }
          result = collection.filter(predicate);
          if (result.length) {
            return result[0];
          }
          return undefined;
        }

        /**
         * @param  {any} collection 
         * @param {Function} iteratee 
         */;
        lodash.forEach = function forEach(collection, iteratee) {
          if (!Array.isArray(collection)) {
            var array = lodash._toArrayKey(collection);
            array.forEach(function (value, index, arr) {
              var key1 = value['key'];
              var value1 = value['value'];
              iteratee(value1, key1, collection);
            });
          } else {
            collection.forEach(iteratee);
          }
        }

        /**
         * @param {any} sObj 
         * @returns 
         */;
        lodash.cloneDeep = function cloneDeep(sObj) {
          if (sObj === null || typeof sObj !== "object") {
            return sObj;
          }
          var s = {};
          if (sObj.constructor === Array) {
            s = [];
          }
          for (var i in sObj) {
            if (sObj.hasOwnProperty(i)) {
              s[i] = lodash.cloneDeep(sObj[i]);
            }
          }
          return s;
        }

        /**
         * @param {Array|Object} collection  .
         * @param {Function} predicate  
         * @returns {Array} 
         */;
        lodash.map = function map(collection, iteratee) {
          if (!Array.isArray(collection)) {
            collection = lodash._toArray(collection);
          }
          var arr = [];
          collection.forEach(function (value, index, array) {
            arr.push(iteratee(value, index, array));
          });
          return arr;
        }

        /**
         * 
         * @param srcObj 
         * @returns 
         */;
        lodash._toArrayKey = function _toArrayKey(srcObj) {
          var resultArr = [];

          // to array
          for (var key in srcObj) {
            if (!srcObj.hasOwnProperty(key)) {
              continue;
            }
            resultArr.push({
              key: key,
              value: srcObj[key]
            });
          }
          return resultArr;
        };
        lodash._toArray = function _toArray(srcObj) {
          var resultArr = [];

          // to array
          for (var key in srcObj) {
            if (!srcObj.hasOwnProperty(key)) {
              continue;
            }
            resultArr.push(srcObj[key]);
          }
          return resultArr;
        }

        /**
         * @param {Array|Object} collection  .
         * @param {Function} predicate  
         * @returns 
         */;
        lodash.filter = function filter(collection, iteratees) {
          if (!Array.isArray(collection)) {
            collection = lodash._toArray(collection);
          }
          return collection.filter(iteratees);
        }

        /**
         * @param {any}x 
         * @param {any}y 
         * @returns {boolean} 
         */;
        lodash.isEqual = function isEqual(x, y) {
          var in1 = x instanceof Object;
          var in2 = y instanceof Object;
          if (!in1 || !in2) {
            return x === y;
          }
          if (Object.keys(x).length !== Object.keys(y).length) {
            return false;
          }
          for (var p in x) {
            var a = x[p] instanceof Object;
            var b = y[p] instanceof Object;
            if (a && b) {
              return lodash.isEqual(x[p], y[p]);
            } else if (x[p] !== y[p]) {
              return false;
            }
          }
          return true;
        }

        /**
         * @param {Array} array 
         * @param {Array} value 
         * @param  {Function} comparator 
         * @returns 
         */;
        lodash.pullAllWith = function pullAllWith(array, value, comparator) {
          value.forEach(function (item) {
            var res = array.filter(function (n) {
              return comparator(n, item);
            });
            res.forEach(function (item) {
              var index = array.indexOf(item);
              if (array.indexOf(item) !== -1) {
                array.splice(index, 1);
              }
            });
          });
          return array;
        }

        /**
         * @returns 
         */;
        lodash.now = function now() {
          return Date.now();
        }

        /**
         * @param {Array} array 
         * @returns 
         */;
        lodash.pullAll = function pullAll(array, value) {
          value.forEach(function (item) {
            var index = array.indexOf(item);
            if (array.indexOf(item) !== -1) {
              array.splice(index, 1);
            }
          });
          return array;
        }

        /**
         * @param {Array|Object} collection  
         * @param {Function} predicate  
         */;
        lodash.forEachRight = function forEachRight(collection, iteratee) {
          if (!Array.isArray(collection)) {
            collection = lodash._toArray(collection);
          }

          //@ts-ignore
          for (var i = collection.length - 1; i >= 0; i--) {
            //@ts-ignore
            var ret = iteratee(collection[i]);
            if (!ret) break;
          }
        }

        /**
         * @param {string} str 
         * @param {string}target  
         * @param {number}position 
         * @returns 
         */;
        lodash.startsWith = function startsWith(str, target, position) {
          str = str.substr(position);
          return str.startsWith(target);
        }

        /**
         * @param {string} str 
         * @param {string}target  
         * @param {number}position 
         * @returns 
         */;
        lodash.endsWith = function endsWith(str, target, position) {
          str = str.substr(position);
          return str.endsWith(target);
        }

        /**
         * @param {Array} array  
         * @param {Function} predicate  
         * @returns 
         */;
        lodash.remove = function remove(array, predicate) {
          var result = [];
          var indexes = [];
          array.forEach(function (item, index) {
            if (predicate(item)) {
              result.push(item);
              indexes.push(index);
            }
          });
          lodash._basePullAt(array, indexes);
          return result;
        };
        lodash._basePullAt = function _basePullAt(array, indexes) {
          var length = array ? indexes.length : 0;
          var lastIndex = length - 1;
          var previous;
          while (length--) {
            var index = indexes[length];
            if (length === lastIndex || index !== previous) {
              previous = index;
              Array.prototype.splice.call(array, index, 1);
            }
          }
          return array;
        }

        /**
         * @param {Array} array  
         * @param {Function} predicate  
         * @param {number} fromIndex 
         * @returns 
         */;
        lodash.findIndex = function findIndex(array, predicate, fromIndex) {
          array = array.slice(fromIndex);
          var i;
          if (typeof predicate === "function") {
            for (i = 0; i < array.length; i++) {
              if (predicate(array[i])) {
                return i;
              }
            }
          } else if (Array.isArray(predicate)) {
            for (i = 0; i < array.length; i++) {
              var key = predicate[0];
              var vaule = true;
              //@ts-ignore
              if (predicate.length > 1) {
                vaule = predicate[1];
              }
              if (array[i][key] === vaule) {
                return i;
              }
            }
          } else {
            for (i = 0; i < array.length; i++) {
              if (array[i] === predicate) {
                return i;
              }
            }
          }
          return -1;
        }

        /**
         * @returns 
         */;
        lodash.concat = function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var array = arguments[0];
          var index = 1;
          while (index < length) {
            array = array.concat(arguments[index]);
            index++;
          }
          return array;
        }

        /**
         * @param {any }value 
         * @returns 
         */;
        lodash.isNumber = function isNumber(value) {
          return typeof value === 'number';
        }

        /**
         * @param {Array}array 
         * @param {any}value 
         * @param {number} fromIndex 
         * @returns 
         */;
        lodash.indexOf = function indexOf(array, value, fromIndex) {
          array = array.slice(fromIndex);
          return array.indexOf(value);
        }

        /**
         * @param {any} array 
         * @param {string} separator 
         * @returns 
         */;
        lodash.join = function join(array, separator) {
          if (array === null) return '';
          var result = '';
          array.forEach(function (item) {
            result += item + separator;
          });
          return result.substr(0, result.length - 1);
        }

        /**
         * @param {string} str 
         * @param {RegExp|string} separator 
         * @param {number} limit 
         * @returns 
         */;
        lodash.split = function split(str, separator, limit) {
          return str.split(separator, limit);
        }

        /**
         * @param {Array}array 
         * @returns 
         */;
        lodash.max = function max(array) {
          if (array && array.length) {
            var result;
            for (var i = 0; i < array.length; i++) {
              if (i === 0) {
                result = array[0];
              } else if (result < array[i]) {
                result = array[i];
              }
            }
            return result;
          }
          return undefined;
        }

        /**
         * @param {Array}array : 
         * @param {number}n 
         * @returns 
         */;
        lodash.drop = function drop(array, n) {
          var length = array === null ? 0 : array.length;
          if (!length) {
            return [];
          }
          return array.slice(n);
        }

        /**
         * @param {Array} arr 
         * @returns 
         */;
        lodash.flattenDeep = function flattenDeep(arr) {
          return arr.reduce(function (prev, cur) {
            return prev.concat(Array.isArray(cur) ? lodash.flattenDeep(cur) : cur);
          }, []);
        }

        /**
         * @param {Array} array 
         * @returns 
         */;
        lodash.uniq = function uniq(array) {
          var result = [];
          array.forEach(function (item) {
            if (result.indexOf(item) === -1) {
              result.push(item);
            }
          });
          return result;
        }

        /**
         * @param {any}value 
         * @returns 
         */;
        lodash.isNaN = function isNaN(value) {
          // An `NaN` primitive is the only value that is not equal to itself.
          // Perform the `toStringTag` check first to avoid errors with some
          // ActiveX objects in IE.
          return lodash.isNumber(value) && value !== +value;
        }

        /**
         * @param {Array}array 
         * @param {number}size 
         * @returns 
         */;
        lodash.chunk = function chunk(array, size) {
          var length = array === null ? 0 : array.length;
          if (!length || size < 1) {
            return [];
          }
          var result = [];
          while (array.length > size) {
            result.push(array.slice(0, size));
            array = array.slice(size);
          }
          result.push(array);
          return result;
        }

        /**
         * @param {any} value 
         * @returns 
         */;
        lodash.toFinite = function toFinite(value) {
          var INFINITY = 1 / 0;
          var MAX_INTEGER = 1.7976931348623157e+308;
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = Number(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }

        /**
         * @param {any}value  
         * @returns {boolean}
         */;
        lodash.isObject = function isObject(value) {
          var type = typeof value;
          return value !== null && (type === 'object' || type === 'function');
        };
        /**
         * 
         * @param value 
         * @returns 
         */
        lodash.isLength = function isLength(value) {
          return typeof value === 'number' && value > -1 && value % 1 === 0 && value <= lodash.MAX_SAFE_INTEGER;
        };
        lodash._isArrayLike = function _isArrayLike(value) {
          return value !== null && lodash.isLength(value.length) /*&& !isFunction(value)*/;
        }

        /**
         * @param {Array} array  
         * @param {Function} predicate  
         * @returns {Object} 
         */;
        lodash.maxBy = function maxBy(array, predicate) {
          if (array && array.length) {
            var result;
            var objResult;
            for (var i = 0; i < array.length; i++) {
              if (i === 0) {
                result = predicate(array[0]);
                objResult = array[0];
              } else if (result < array[i]) {
                result = array[i];
                objResult = array[i];
              }
            }
            return objResult;
          }
          return undefined;
        }

        /**
         * @param {Array} array  
         * @param {Function} predicate  
         * @returns {Object} 
         */;
        lodash.minBy = function minBy(array, predicate) {
          if (array && array.length) {
            var result;
            var objResult;
            for (var i = 0; i < array.length; i++) {
              if (i === 0) {
                result = predicate(array[0]);
                objResult = array[0];
              } else if (result > array[i]) {
                result = predicate(array[i]);
                objResult = array[i];
              }
            }
            return objResult;
          }
          return undefined;
        }
        /**
         * @param {Array|Object} collection  
         * @param {Function} predicate  
         * @returns {Object} 
         */;
        lodash.sumBy = function sumBy(collection, predicate) {
          var sum = 0;
          for (var _key in collection) {
            //@ts-ignore
            sum += predicate(collection[_key]);
          }
          return sum;
        }

        /**
         * @param {Array|Object} collection  
         * @param {Function} predicate  
         * @returns {Object} 
         */;
        lodash.countBy = function countBy(collection, predicate) {
          var objRet = {};
          for (var _key2 in collection) {
            var value = predicate(_key2);
            if (objRet.hasOwnProperty(value)) {
              objRet[value] += 1;
            } else {
              objRet[value] = 1;
            }
          }
          return objRet;
        };
        return lodash;
      }(), _class2.MAX_SAFE_INTEGER = 9007199254740991, _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/log.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "40ca6yOjaJE8J+qRdu62/Jd", "log", undefined);
      var Log = exports('default', (_dec = register({
        menu: 'Math/Advanced/Log',
        title: 'Log'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Log, _ShaderNode);
        function Log() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Log.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = log(" + input0 + ");\n        ";
        };
        return Log;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/main", ['./CSVLoader.ts', './ClientEvent.ts', './ComponentPool.ts', './ImageLoader.ts', './MidiReader.ts', './ObjectPoolData.ts', './UIAvatar.ts', './UICashAnimation.ts', './UITimer.ts', './AnimationPanel.ts', './ButtonAutoSound.ts', './HotKey.ts', './ButtonHotKey.ts', './EscHotkey.ts', './ToggleHotKey.ts', './UIHotkeyLabel.ts', './InteractableItem.ts', './PageViewBase.ts', './PageViewBaseItem.ts', './PageViewBasePage.ts', './PersistentNode.ts', './PopupBase.ts', './ScrollViewBase.ts', './ScrollViewBaseItem.ts', './ScrollViewBaseLine.ts', './ToggleAutoSound.ts', './UIAutoVersion.ts', './UICoins.ts', './UICountdownNumber.ts', './UIFastToggle.ts', './UIItemUser.ts', './UIName.ts', './UINumberByImages.ts', './UINumberLabel.ts', './UINumberLabelComponent.ts', './UIScaler.ts', './UIScreenScaler.ts', './UISlider.ts', './UISliderRectSize.ts', './UIToggleGroups.ts', './UIViewDrawer.ts', './UserInteractHandler.ts', './VisiblePanel.ts', './Utils2.ts', './Group.ts', './Holder.ts', './Manager.ts', './ScrollAdapter.ts', './View.ts', './Indicator.ts', './Scrollbar.ts', './debug.ts', './enum.ts', './interface.ts', './helper.ts', './index2.ts', './CenterManager.ts', './LayoutManager.ts', './ModelManager.ts', './PageViewManager.ts', './ReleaseManager.ts', './ScrollManager.ts', './ViewManager.ts', './assetRemoteUtil.ts', './audioManager.ts', './csvManager.ts', './easing.ts', './localConfig.ts', './lodash.ts', './poolManager.ts', './resourceUtil.ts', './storageManager.ts', './uiManager.ts', './Constants.ts', './Defines.ts', './PopupDefine.ts', './SceneDefine.ts', './SocketEventDefines.ts', './DynamicSkeletonAnimation.ts', './APIFakeData.ts', './APIManager.ts', './GameManager.ts', './UserManager.ts', './UserModel.ts', './SongData.ts', './AuditionNoteVisual.ts', './AuditionAudioManager.ts', './AuditionBeatSystem.ts', './AuditionBeatmap.ts', './AuditionCharacterAnimation.ts', './AuditionCharacterAnimationData.ts', './AuditionGameplayController.ts', './AuditionInputHandler.ts', './AuditionNote.ts', './AuditionNotePool.ts', './AuditionScoringSystem.ts', './AuditionGameplayUI.ts', './AuditionMainMenuController.ts', './AuditionRandomBackground.ts', './AuditionResultsController.ts', './AuditionSongItemComponent.ts', './AuditionSongSelectionController.ts', './AuditionUIManager.ts', './AnimationGraph.ts', './AnimationGraphGroup.ts', './AnimatorController.ts', './EffectController.ts', './EffectAnimation.ts', './EffectBase.ts', './EffectMovingObject.ts', './EffectMultiMovingObject.ts', './EffectParticle.ts', './EffectPoints.ts', './EffectText.ts', './EffectTime.ts', './FacialEmotionController.ts', './FacialEmotionDemo.ts', './GameEnviromentSetter.ts', './HomeController.ts', './AudioManager2.ts', './BeatmapManager.ts', './DataManagement.ts', './FeedbackManager.ts', './GameplayManager.ts', './InputManager.ts', './MTDefines.ts', './MTDragAndDropTool.ts', './MTUIManager.ts', './MTItemSong.ts', './PopupMTSongSelection.ts', './ScoreManager.ts', './SongSelectionManager.ts', './TapValidator.ts', './Tile.ts', './TileManager.ts', './PitchNoteSequence.ts', './PitchCharacterAnimator.ts', './PitchConstants.ts', './PitchDetectionSystem.ts', './PitchGameplayController.ts', './PitchTimer.ts', './PitchUIManager.ts', './PopupLoading.ts', './PopupMessage.ts', './Bullet.ts', './CameraController.ts', './Cannon.ts', './Cursor.ts', './EffectManger.ts', './ProjectileController.ts', './ProjectileMath.ts', './TrajectoryDrawer.ts', './ClickToLoadUrl.ts', './HUD_Options.ts', './HUD_Tips.ts', './MathUtil.ts', './VectorUtil.ts', './index3.ts', './register.ts', './base.ts', './context.ts', './boolean.ts', './float.ts', './slider.ts', './vector2.ts', './vector3.ts', './vector4.ts', './absolute.ts', './exponential.ts', './length.ts', './log.ts', './modulo.ts', './negate.ts', './normalize.ts', './posterize.ts', './reciprocal-square.ts', './reciprocal.ts', './add.ts', './divide.ts', './multiply.ts', './power.ts', './square.ts', './substract.ts', './ddx.ts', './ddxy.ts', './ddy.ts', './inverse-lerp.ts', './lerp.ts', './smoothstep.ts', './clamp.ts', './fraction.ts', './max.ts', './min.ts', './one-minus.ts', './random-range.ts', './remap.ts', './saturate.ts', './ceil.ts', './floor.ts', './round.ts', './sign.ts', './step.ts', './truncate.ts', './arccosine.ts', './arcsine.ts', './arctangent.ts', './arctangent2.ts', './cosine.ts', './degrees-to-radians.ts', './hyperbolic-cosine.ts', './hyperbolic-sine.ts', './hyperbolic.ts', './radians-to-degrees.ts', './sine.ts', './tangent.ts', './cross-product.ts', './distance.ts', './dot-product.ts', './fresnel.ts', './projection.ts', './reflection.ts', './rejection.ts', './sphere-mask.ts', './noise-sine-wave.ts', './sawtooth-wave.ts', './square-wave.ts', './triangle-wave.ts', './gradient-noise.ts', './simple-noise.ts', './ellipse.ts', './rectangle.ts', './round-rectangle.ts', './polar-coordinates.ts', './rotate-coordinates.ts', './tilling-and-offset.ts', './index.ts', './combine.ts', './split.ts', './index4.ts', './color.ts', './time.ts', './normal-vector.ts', './position.ts', './uv.ts', './vertex-color.ts', './view-direction.ts', './input-node.ts', './property-node.ts', './cubemap-asset.ts', './sample-cubemap.ts', './sample-texture2d.ts', './texture-asset.ts', './texture2d-asset.ts', './get-local-var.ts', './register-local-var.ts', './all.ts', './and.ts', './any.ts', './branch.ts', './comparison.ts', './is-nan.ts', './not.ts', './or.ts', './MasterNode.ts', './SurfaceMasterNode.ts', './UnlitMasterNode.ts', './SubGraphNode.ts', './SubGraphOutputNode.ts', './PreviewNode.ts', './property.ts', './shadergraph.ts', './slot.ts', './type.ts', './utils.ts'], function () {
  return {
    setters: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],
    execute: function () {}
  };
});

System.register("chunks:///_virtual/Manager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _createClass, cclegacy, _decorator;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "2be49b5ffhLSZVXKWyATSqt", "Manager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var Manager = exports('Manager', (_dec = ccclass('Manager'), _dec(_class = /*#__PURE__*/function () {
        function Manager() {
          this._inited = false;
          this._eventMap = new Map();
          this._adapter = null;
        }
        var _proto = Manager.prototype;
        /** @deprecated  */
        _proto.internal_create = function internal_create(adapter) {
          this._adapter = adapter;
        }
        /** @deprecated  */;
        _proto.internal_init = function internal_init() {
          if (this._inited) return;
          this._inited = true;
          this.onInit();
        };
        _proto.on = function on(event, callback, target, once) {
          if (once === void 0) {
            once = false;
          }
          if (!this._eventMap.has(event)) {
            this._eventMap.set(event, []);
          }
          var list = this._eventMap.get(event);
          if (list != null && list.find(function (info) {
            return info.target == target && info.callback == callback;
          })) {
            return;
          }
          list.push({
            callback: callback,
            target: target,
            once: once
          });
        };
        _proto.off = function off(event, callback, target) {
          if (!this._eventMap.has(event)) {
            return;
          }
          var list = this._eventMap.get(event);
          var index = list == null ? void 0 : list.findIndex(function (info) {
            return info.callback == callback && info.target == target;
          });
          if (index == -1) return;
          list.splice(index, 1);
        };
        _proto.emit = function emit(event) {
          if (!this._eventMap.has(event)) {
            return;
          }
          var list = this._eventMap.get(event);
          for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            params[_key - 1] = arguments[_key];
          }
          for (var i = 0; i < list.length; i++) {
            var _info$callback;
            var info = list[i];
            (_info$callback = info.callback).call.apply(_info$callback, [info.target].concat(params));
            if (info.once) {
              list.splice(i, 1);
              i--;
            }
          }
        };
        _createClass(Manager, [{
          key: "adapter",
          get: function get() {
            return this._adapter;
          }
        }]);
        return Manager;
      }()) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/MasterNode.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './base.ts', './type.ts', './utils.ts', './property.ts', './context.ts'], function (exports) {
  var _inheritsLoose, _createClass, _asyncToGenerator, _regeneratorRuntime, cclegacy, assetManager, Material, ShaderNode, NormalSpace, PositionSpace, ViewDirSpace, ConcretePrecisionType, path, fs, ensureEnumDefines, ShaderPropertyType, shaderContext;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
      _createClass = module.createClass;
      _asyncToGenerator = module.asyncToGenerator;
      _regeneratorRuntime = module.regeneratorRuntime;
    }, function (module) {
      cclegacy = module.cclegacy;
      assetManager = module.assetManager;
      Material = module.Material;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      NormalSpace = module.NormalSpace;
      PositionSpace = module.PositionSpace;
      ViewDirSpace = module.ViewDirSpace;
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      path = module.path;
      fs = module.fs;
      ensureEnumDefines = module.ensureEnumDefines;
    }, function (module) {
      ShaderPropertyType = module.ShaderPropertyType;
    }, function (module) {
      shaderContext = module.shaderContext;
    }],
    execute: function () {
      cclegacy._RF.push({}, "1eab7ptCA1KiK+C6tmMVON/", "MasterNode", undefined);
      var MasterSlotType = exports('MasterSlotType', /*#__PURE__*/function (MasterSlotType) {
        MasterSlotType[MasterSlotType["Vertex"] = 0] = "Vertex";
        MasterSlotType[MasterSlotType["Fragment"] = 1] = "Fragment";
        return MasterSlotType;
      }({}));
      function findConnectNodes(slot, nodes) {
        if (!slot.connectSlot) return;
        var connectNode = slot.connectNode;
        if (connectNode) {
          if (nodes.includes(connectNode)) {
            return;
          }
          connectNode.inputs.forEach(function (slot) {
            findConnectNodes(slot, nodes);
          });
          nodes.push(connectNode);
        }
      }
      var MasterNode = exports('default', /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(MasterNode, _ShaderNode);
        function MasterNode() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.isMasterNode = true;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.properties = [];
          _this.data = {
            inputs: []
          };
          return _this;
        }
        var _proto = MasterNode.prototype;
        _proto.getConnectNodes = function getConnectNodes(slots) {
          var nodes = [];
          slots.forEach(function (slot) {
            findConnectNodes(slot, nodes);
          });
          nodes.sort(function (a, b) {
            return b.priority - a.priority;
          });
          return nodes;
        };
        _proto.generatePropertiesCode = function generatePropertiesCode() {
          var uniform = '\n';
          var mtl = '\n';
          var uniformSampler = '';
          var properties = shaderContext.properties;
          properties.sort(function (a, b) {
            return b.concretePrecision - a.concretePrecision;
          });
          var blockUniformCount = 0;
          properties.forEach(function (p) {
            var precision = '';
            var mtlValue = '';
            var value = p.value;
            var isColor = p.type === ShaderPropertyType.Color;
            var x = value.x;
            var y = value.y;
            var z = value.z;
            var w = value.w;
            if (p.type === ShaderPropertyType.Texture2D) {
              precision = 'sampler2D';
              mtlValue = 'white';
            } else if (p.type === ShaderPropertyType.TextureCube) {
              precision = 'samplerCube';
              mtlValue = 'white';
            } else {
              var concretePrecision = p.concretePrecision;
              if (concretePrecision === 1) {
                precision = 'float';
                mtlValue = "" + value;
              } else if (concretePrecision === 2) {
                precision = 'vec2';
                mtlValue = "[" + x + ", " + y + "]";
              } else if (concretePrecision === 3) {
                precision = 'vec4';
                mtlValue = "[" + x + ", " + y + ", " + z + ", 0]";
              } else if (concretePrecision === 4) {
                precision = 'vec4';
                mtlValue = "[" + x + ", " + y + ", " + z + ",  " + w + "]";
              }
            }
            var editorStr = isColor ? ", editor: { type: color }" : '';
            if (!p.isTexture()) {
              uniform += "    " + precision + " " + p.name + ";\n";
              blockUniformCount++;
            } else {
              uniformSampler += "  uniform " + precision + " " + p.name + ";\n";
            }
            mtl += "        " + p.name + ": { value: " + mtlValue + " " + editorStr + "}\n";
          });
          if (blockUniformCount === 0) {
            uniform += '    vec4 empty_value;\n';
          }
          return {
            uniform: uniform,
            uniformSampler: uniformSampler,
            mtl: mtl
          };
        };
        _proto.replaceChunks = function replaceChunks(code) {
          var depChunks = ['common'];
          var allNodes = shaderContext.allNodes;
          allNodes.forEach(function (node) {
            for (var k = 0; k < node.depChunks.length; k++) {
              if (!depChunks.includes(node.depChunks[k])) {
                depChunks.push(node.depChunks[k]);
              }
            }
          });
          var chunkIncludes = '\n';
          var chunks = '\n';
          depChunks.forEach(function (chunkName) {
            var chunkPath = path.join(shaderContext.shaderTemplatesDir, "chunks/" + chunkName + ".chunk");
            var chunk = fs.readFileSync(chunkPath, 'utf-8');
            if (!chunk) {
              console.error("Can not find chunk with path [" + chunkPath + "]");
              return;
            }
            chunks += chunk + '\n';
            chunkIncludes += "  #include <shader_graph_" + chunkName + ">\n";
          });
          code = code.replace('{{chunks}}', chunks);
          code = code.replace('{{vs_chunks}}', chunkIncludes);
          code = code.replace('{{fs_chunks}}', chunkIncludes);
          return code;
        };
        _proto.generateDefines = function generateDefines(code) {
          var defines = [];
          var allNodes = shaderContext.allNodes;
          allNodes.forEach(function (node) {
            node.defines.forEach(function (def) {
              if (!defines.includes(def)) {
                defines.push(def);
              }
            });
          });
          var define = '';
          defines.forEach(function (df) {
            define += df + "\n";
          });
          define = ensureEnumDefines(NormalSpace, define);
          define = ensureEnumDefines(PositionSpace, define);
          define = ensureEnumDefines(ViewDirSpace, define);

          // add spaces
          var lines = define.split('\n');
          lines = lines.map(function (l) {
            return '  ' + l;
          });
          define = lines.join('\n');
          return code.replace(/{{defines}}/g, define);
        };
        _proto.generateSlotsCode = function generateSlotsCode(slots) {
          var code = ['\n'];
          var nodes = this.getConnectNodes(slots);
          nodes.forEach(function (node) {
            node.calcConcretePrecision();
            node.generateCode().split('\n').forEach(function (c) {
              if (c) {
                c += " // " + node.constructor.name;
                code.push('    ' + c);
              }
            });
          });
          return code.join('\n');
        };
        _proto.generateCodeChunk = function generateCodeChunk(code) {
          var _this2 = this;
          var codeChunkSlots = [];
          this.inputs.forEach(function (input) {
            var data = input.data;
            if (!codeChunkSlots[data.codeChunk]) {
              codeChunkSlots[data.codeChunk] = [];
            }
            codeChunkSlots[data.codeChunk].push(input);
          });
          codeChunkSlots.forEach(function (slots, chunkIdx) {
            var codeChunk = _this2.generateSlotsCode(slots);
            code = code.replace("{{code_chunk_" + chunkIdx + "}}", codeChunk);

            // console.log(`{{code_chunk_${chunkIdx}}} : \n ` + codeChunk);
          });

          return code;
        };
        _proto.generateCode = function generateCode() {
          var code = fs.readFileSync(this.templatePath, 'utf-8');
          code = this.generateCodeChunk(code);
          code = this.generateDefines(code);
          code = this.replaceChunks(code);
          if (!shaderContext.properties || shaderContext.properties.length === 0) {
            code = code.replace(/properties: &props/g, '');
            code = code.replace(/properties: \*props/g, '');
          }
          var props = this.generatePropertiesCode();
          code = code.replace('{{properties}}', props.uniform);
          code = code.replace('{{properties_sampler}}', props.uniformSampler);
          code = code.replace('{{properties_mtl}}', props.mtl);

          //  slot  template 
          var slotsToUseTemplateDefault = ['Vertex Position', 'Vertex Normal', 'Vertex Tangent', 'Position'];
          this.inputs.forEach(function (slot) {
            var tempName = "slot_" + slot.displayName.replace(/ /g, '_');
            var value;
            if (slotsToUseTemplateDefault.includes(slot.displayName) || slot.displayName === 'Normal') {
              if (slot.connectSlot) {
                value = slot.slotValue;
              }
            } else {
              value = slot.slotValue;
            }
            var reg = new RegExp("{{" + tempName + " *= *(.*)}}", 'g');
            if (value === undefined) {
              var res = reg.exec(code);
              if (res) {
                value = res[1];
              }
            }
            code = code.replace(reg, value);
          });

          // vertexSlotNames.forEach(name => {
          //     const tempName = `slot_${name.replace(/ /g, '_')}`;
          //     let value = '';
          //     const reg = new RegExp(`{{${tempName} *= *(.*)}}`, 'g');
          //     const res = reg.exec(code);
          //     if (res) {
          //         value = res[1];
          //     }
          //     code = code.replace(reg, value);
          // });

          return code;
        };
        _proto.createMaterial = /*#__PURE__*/function () {
          var _createMaterial = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(buildEffect) {
            var code, material, name, effect, result;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  code = this.generateCode();
                  material = new Material();
                  name = 'shader-graph-preview.effect';
                  _context2.next = 5;
                  return buildEffect(name, code);
                case 5:
                  effect = _context2.sent;
                  result = new cc.EffectAsset();
                  Object.assign(result, effect);
                  result.onLoaded();
                  material.initialize({
                    effectAsset: effect
                  });
                  _context2.next = 12;
                  return Promise.all(shaderContext.properties.map( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(p) {
                    var uuid;
                    return _regeneratorRuntime().wrap(function _callee$(_context) {
                      while (1) switch (_context.prev = _context.next) {
                        case 0:
                          if (!(p.type === ShaderPropertyType.Texture2D || p.type === ShaderPropertyType.TextureCube)) {
                            _context.next = 3;
                            break;
                          }
                          uuid = p.value.uuid;
                          return _context.abrupt("return", new Promise(function (resolve) {
                            assetManager.loadAny(uuid, function (err, asset) {
                              if (err) {
                                console.error(err);
                                return resolve(null);
                              }
                              material.setProperty(p.name, asset);
                              resolve(null);
                            });
                          }));
                        case 3:
                        case "end":
                          return _context.stop();
                      }
                    }, _callee);
                  }))));
                case 12:
                  return _context2.abrupt("return", material);
                case 13:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this);
          }));
          function createMaterial(_x) {
            return _createMaterial.apply(this, arguments);
          }
          return createMaterial;
        }();
        _createClass(MasterNode, [{
          key: "templatePath",
          get:
          // vsSlotIndices: string[] = [];
          // fsSlotIndices: string[] = [];

          function get() {
            return '';
          }
        }]);
        return MasterNode;
      }(ShaderNode));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/MathUtil.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _createClass, cclegacy, game;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      game = module.game;
    }],
    execute: function () {
      cclegacy._RF.push({}, "ac60c1uuSNLz566NcMsAduq", "MathUtil", undefined);

      /**  */
      var rad2Deg = 180 / Math.PI;

      /**  */
      var deg2Rad = Math.PI / 180;

      /**
       * 
       * @author  (ifaswind)
       * @version 20220322
       * @requires cocos-creator-3.x
       */
      var MathUtil = exports('MathUtil', /*#__PURE__*/function () {
        function MathUtil() {}
        /**
         * 
         * @param radians 
         */
        MathUtil.radiansToDegrees = function radiansToDegrees(radians) {
          return radians * rad2Deg;
        }

        /**
         * 
         * @param degree 
         */;
        MathUtil.degreesToRadians = function degreesToRadians(degree) {
          return degree * deg2Rad;
        }

        /**
         * 
         * @param value 
         * @param min 
         * @param max 
         */;
        MathUtil.clamp = function clamp(value, min, max) {
          if (value < min) {
            return min;
          } else if (value > max) {
            return max;
          }
          return value;
        }

        /**
         * 
         * @param value 
         */;
        MathUtil.clamp01 = function clamp01(value) {
          return MathUtil.clamp(value, 0, 1);
        }

        /**
         * 
         * @param from 
         * @param to 
         * @param t 
         */;
        MathUtil.lerp = function lerp(from, to, t) {
          return from + (to - from) * MathUtil.clamp01(t);
        }

        /**
         * 0  1
         * @param a 
         * @param t 
         */;
        MathUtil.step = function step(a, t) {
          return t < a ? 0 : 1;
        }

        /**
         * 
         * @param from 
         * @param to 
         * @param t 
         */;
        MathUtil.smoothStep = function smoothStep(from, to, t) {
          t = MathUtil.clamp01(t);
          t = -2.0 * t * t * t + 3.0 * t * t;
          return to * t + from * (1.0 - t);
        }

        /**
         * 
         * @param current 
         * @param target 
         * @param currentVelocity 
         * @param smoothTime 
         * @param maxSpeed 
         * @param deltaTime 
         */;
        MathUtil.smoothDamp = function smoothDamp(current, target, currentVelocity, smoothTime, maxSpeed, deltaTime) {
          maxSpeed = maxSpeed != undefined ? maxSpeed : Number.POSITIVE_INFINITY;
          deltaTime = deltaTime != undefined ? deltaTime : game.deltaTime;
          smoothTime = Math.max(0.0001, smoothTime);
          var num1 = 2 / smoothTime;
          var num2 = num1 * deltaTime;
          var num3 = 1 / (1 + num2 + 0.47999998927116394 * num2 * num2 + 0.23499999940395355 * num2 * num2 * num2);
          var num4 = current - target;
          var num5 = target;
          var max = maxSpeed * smoothTime;
          var num6 = MathUtil.clamp(num4, -max, max);
          target = current - num6;
          var num7 = (currentVelocity + num1 * num6) * deltaTime;
          var velocity = (currentVelocity - num1 * num7) * num3;
          var num8 = target + (num6 + num7) * num3;
          if (num5 - current > 0 === num8 > num5) {
            num8 = num5;
            velocity = (num8 - num5) / deltaTime;
          }
          return {
            value: num8,
            velocity: velocity
          };
        };
        _createClass(MathUtil, null, [{
          key: "rad2Deg",
          get:
          /**
           * 
           */
          function get() {
            return rad2Deg;
          }

          /**
           * 
           */
        }, {
          key: "deg2Rad",
          get: function get() {
            return deg2Rad;
          }
        }]);
        return MathUtil;
      }());
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/max.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "6e8a0vJMJZHLaTkO3zIBxfl", "max", undefined);
      var Max = exports('default', (_dec = register({
        menu: 'Math/Range/Max',
        title: 'Max'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Max, _ShaderNode);
        function Max() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Max.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = max(" + input0 + ", " + input1 + ");\n        ";
        };
        return Max;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/MidiReader.ts", ['cc'], function (exports) {
  var cclegacy, resources, Asset;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      resources = module.resources;
      Asset = module.Asset;
    }],
    execute: function () {
      exports({
        loadMidi: loadMidi,
        loadMidiFromURL: loadMidiFromURL
      });
      cclegacy._RF.push({}, "1b61cY0MSxGRrqa3QwVp8IO", "MidiReader", undefined);

      // Declare the Tone global variable for TypeScript

      function loadMidi(resourcesPath, trackIndex) {
        if (trackIndex === void 0) {
          trackIndex = 1;
        }
        return new Promise(function (resolve, reject) {
          resources.load(resourcesPath, function (err, asset) {
            if (err) {
              console.error("Error loading asset:", err);
              reject(err);
              return;
            }
            if (!(asset instanceof Asset)) {
              var error = new Error("Invalid asset type loaded");
              console.error(error.message, asset);
              reject(error);
              return;
            }

            // Get the URL of the Asset
            var url = asset.nativeUrl;

            // Load the binary data using XMLHttpRequest
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.responseType = 'arraybuffer'; // Important!

            xhr.onload = function () {
              if (xhr.status === 200) {
                var arrayBuffer = xhr.response;
                var byteArray = new Uint8Array(arrayBuffer);
                try {
                  var midi = new Midi(byteArray.buffer);
                  console.log("MIDI file loaded successfully:", midi);

                  // Extract the specific track if requested and it exists
                  if (trackIndex >= 0 && midi.tracks && midi.tracks.length > trackIndex) {
                    resolve(midi.tracks[trackIndex]);
                  } else {
                    resolve(midi);
                  }
                } catch (e) {
                  console.error("Error parsing MIDI data:", e);
                  reject(e);
                }
              } else {
                var _error = new Error("Error loading binary data: " + xhr.statusText);
                console.error(_error.message);
                reject(_error);
              }
            };
            xhr.onerror = function (e) {
              reject(new Error("Network error during MIDI file loading"));
            };
            xhr.send();
          });
        });
      }
      function loadMidiFromURL(url, trackIndex) {
        if (trackIndex === void 0) {
          trackIndex = 1;
        }
        return new Promise(function (resolve, reject) {
          // Create a new XMLHttpRequest
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.responseType = 'arraybuffer';
          xhr.onload = function () {
            if (xhr.status === 200) {
              var arrayBuffer = xhr.response;
              var byteArray = new Uint8Array(arrayBuffer);
              try {
                // Use the global Midi parser if available
                if (typeof window !== 'undefined' && window['Midi']) {
                  var midi = new window['Midi'](byteArray.buffer);
                  console.log("MIDI file loaded successfully:", midi);

                  // Take the first track
                  var track = midi.tracks && midi.tracks.length > trackIndex ? midi.tracks[trackIndex] : null;
                  resolve(track || midi);
                } else {
                  // Fallback if Midi parser is not available
                  reject(new Error("Midi parser not available"));
                }
              } catch (e) {
                console.error("Error parsing MIDI data:", e);
                reject(e);
              }
            } else {
              reject(new Error("Error loading binary data: " + xhr.statusText));
            }
          };
          xhr.onerror = function () {
            reject(new Error("Network error during MIDI file loading"));
          };
          xhr.send();
        });
      }
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/min.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "65629wgX7ZFlosarXfPMufw", "min", undefined);
      var Min = exports('default', (_dec = register({
        menu: 'Math/Range/Min',
        title: 'Min'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Min, _ShaderNode);
        function Min() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Min.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = min(" + input0 + ", " + input1 + ");\n        ";
        };
        return Min;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ModelManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Manager.ts', './enum.ts', './helper.ts'], function (exports) {
  var _inheritsLoose, _createClass, _asyncToGenerator, _regeneratorRuntime, cclegacy, _decorator, Node, UITransform, Manager, WrapMode, Layer, Helper;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
      _createClass = module.createClass;
      _asyncToGenerator = module.asyncToGenerator;
      _regeneratorRuntime = module.regeneratorRuntime;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      UITransform = module.UITransform;
    }, function (module) {
      Manager = module.Manager;
    }, function (module) {
      WrapMode = module.WrapMode;
      Layer = module.Layer;
    }, function (module) {
      Helper = module.Helper;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "36ea76OAA9IiJKehmGOQ6xW", "ModelManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var Event = /*#__PURE__*/function (Event) {
        Event[Event["ON_CLEAR"] = 0] = "ON_CLEAR";
        Event[Event["ON_INSERT"] = 1] = "ON_INSERT";
        Event[Event["ON_REMOVE"] = 2] = "ON_REMOVE";
        Event[Event["ON_MOVE"] = 3] = "ON_MOVE";
        Event[Event["ON_UPDATE"] = 4] = "ON_UPDATE";
        Event[Event["ON_CHANGE_BEFORE"] = 5] = "ON_CHANGE_BEFORE";
        return Event;
      }(Event || {});
      var ModelManager = exports('ModelManager', (_dec = ccclass('ModelManager'), _dec(_class = (_class2 = /*#__PURE__*/function (_Manager) {
        _inheritsLoose(ModelManager, _Manager);
        function ModelManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Manager.call.apply(_Manager, [this].concat(args)) || this;
          _this._modelList = [];
          _this._length = 0;
          return _this;
        }
        var _proto = ModelManager.prototype;
        _proto.onInit = function onInit() {};
        _proto.insert = /*#__PURE__*/function () {
          var _insert = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data, insertIndex) {
            var list;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  if (insertIndex === void 0) {
                    insertIndex = this.length;
                  }
                  list = this._toArray(data);
                  insertIndex = Helper.clamp(insertIndex, 0, this.length);
                  this.emit(Event.ON_CHANGE_BEFORE);
                  this._insertHandler(list, insertIndex);
                  this._length = this._modelList.length;
                  // console.log("", this._modelList)
                  if (list.length > 0) {
                    this.emit(Event.ON_INSERT, insertIndex);
                  }
                case 7:
                case "end":
                  return _context.stop();
              }
            }, _callee, this);
          }));
          function insert(_x, _x2) {
            return _insert.apply(this, arguments);
          }
          return insert;
        }();
        _proto._insertHandler = function _insertHandler(list, insertIndex) {
          var _this2 = this;
          var index = insertIndex;
          this._length = this._modelList.length;
          var cacheList = [];
          var newModel = function newModel(data, index) {
            model = _this2._getNewModel(data);
            model.index = index;
            _this2._modelList.push(model);
            return model;
          };
          var action = function action(data) {
            var model = _this2.get(index);
            if (model) {
              cacheList.push(_this2._copyModel(model, {}));
              model.data = data;
              model.index = index;
              _this2._initModel(model);
            } else {
              var curr = newModel(data, index);
              _this2._initModel(curr);
            }
            index++;
          };
          for (var i = 0, len = list.length; i < len; i++) {
            action(list[i]);
          }
          for (var _i = 0; _i < cacheList.length; _i++) {
            var cache = cacheList[_i];
            var idx = index + _i;
            if (this.get(idx)) {
              var model = this.get(idx);
              cacheList.push(this._copyModel(model, {}));
              this._copyModel(cache, model);
            } else {
              var curr = newModel(cache.data, idx);
              this._copyModel(cache, curr);
            }
          }
        };
        _proto.remove = function remove(index, count) {
          if (count === void 0) {
            count = 1;
          }
          if (count == 0) return;
          if (index < 0 || index >= this.length) return;
          var removeIndex = this.length;
          this.emit(Event.ON_CHANGE_BEFORE);
          for (var i = index; i < this.length; i++) {
            var model = this.get(i);
            var next = this.get(i + count);
            if (next) {
              this._copyModel(next, model);
              model.index = i;
            } else {
              removeIndex = i;
              break;
            }
          }
          this._modelList.splice(removeIndex, this.length);
          this._length = this._modelList.length;
          // console.log(this._modelList)
          this.emit(Event.ON_REMOVE, index);
        };
        _proto.move = function move(startIndex, count, newIndex) {
          var _this3 = this;
          if (startIndex < 0 || count <= 0) return;
          this.emit(Event.ON_CHANGE_BEFORE);
          var temp = this._modelList.map(function (item) {
            return _this3._copyModel(item, {});
          });
          var moveList = temp.splice(startIndex, count);
          temp.splice.apply(temp, [newIndex, 0].concat(moveList));
          for (var i = 0; i < temp.length; i++) {
            this._copyModel(temp[i], this._modelList[i]);
          }
          var index = Math.min(startIndex, newIndex);
          this.emit(Event.ON_MOVE, index);
          // console.log("", this._modelList)
        }
        /**
         * 
         */;
        _proto.update = function update() {
          this.emit(Event.ON_UPDATE);
        };
        _proto.clear = function clear() {
          this._modelList.length = 0;
          this._length = 0;
          this.emit(Event.ON_CLEAR);
        };
        _proto.has = function has(index) {
          return !!this._modelList[index];
        };
        _proto.get = function get(index) {
          if (isNaN(index)) return null;
          return this._modelList[index];
        };
        _proto.slice = function slice(start, end) {
          if (this.length == 0) return [];
          return this._modelList.slice(start, end);
        };
        _proto._toArray = function _toArray(data) {
          if (!data) return [];
          if (data instanceof Array) {
            return data;
          } else {
            return [data];
          }
        };
        _proto._getNewModel = function _getNewModel(data) {
          var model = {
            data: data,
            index: -1,
            code: null,
            size: {
              x: 0,
              y: 0
            },
            layoutSize: {
              x: 0,
              y: 0
            },
            scale: {
              x: 0,
              y: 0
            },
            position: {
              x: 0,
              y: 0
            },
            anchorPoint: {
              x: 0,
              y: 0
            },
            element: {
              wrapBeforeMode: WrapMode.Wrap,
              wrapAfterMode: WrapMode.Nowrap,
              ignoreLayout: false,
              placeholder: false,
              minSize: {
                x: 0,
                y: 0
              },
              preferredSize: {
                x: 0,
                y: 0
              },
              flexibleSize: {
                x: 0,
                y: 0
              },
              layer: Layer.Lowest,
              fixed: false,
              fixedOffset: 0,
              fixedSpacing: null,
              update: function update() {}
            },
            isValid: true,
            update: function update() {}
          };
          return model;
        };
        _proto._initModel = function _initModel(model) {
          var prefab = this.adapter.getPrefab(model.data);
          if (!prefab) {
            throw Error("");
          }
          if (prefab instanceof Node) {
            var transform = prefab.getComponent(UITransform);
            model.code = prefab.uuid;
            model.size = {
              x: transform.width,
              y: transform.height
            };
            model.scale = {
              x: transform.node.scale.x,
              y: transform.node.scale.y
            };
            model.anchorPoint = {
              x: transform.anchorPoint.x,
              y: transform.anchorPoint.y
            };
          } else {
            var _transform = prefab.data.getComponent(UITransform);
            model.code = prefab.data._prefab.fileId;
            model.size = {
              x: _transform.width,
              y: _transform.height
            };
            model.scale = {
              x: _transform.node.scale.x,
              y: _transform.node.scale.y
            };
            model.anchorPoint = {
              x: _transform.anchorPoint.x,
              y: _transform.anchorPoint.y
            };
          }
          model.layoutSize = {
            x: 0,
            y: 0
          };
          model.position = {
            x: 0,
            y: 0
          };
          model.element = {
            wrapBeforeMode: WrapMode.Wrap,
            wrapAfterMode: WrapMode.Nowrap,
            ignoreLayout: false,
            placeholder: false,
            minSize: {
              x: 0,
              y: 0
            },
            preferredSize: {
              x: 0,
              y: 0
            },
            flexibleSize: {
              x: 0,
              y: 0
            },
            layer: Layer.Lowest,
            fixed: false,
            fixedOffset: 0,
            fixedSpacing: null,
            update: function update() {}
          };
          this.adapter.initElement(model.element, model.data);
        };
        _proto._copyModel = function _copyModel(source, target) {
          source.element.update = function () {};
          var deep = function deep(obj, cacheObj) {
            for (var key in obj) {
              var value = obj[key];
              if (key == "data") {
                cacheObj[key] = value;
                continue;
              }
              if (key == "index") continue;
              if (value != null && typeof value == "object") {
                cacheObj[key] = {};
                deep(value, cacheObj[key]);
              } else {
                cacheObj[key] = value;
              }
            }
          };
          deep(source, target);
          return target;
        };
        _createClass(ModelManager, [{
          key: "length",
          get: function get() {
            return this._length;
          }
        }, {
          key: "modelList",
          get: function get() {
            return this._modelList;
          }
        }]);
        return ModelManager;
      }(Manager), _class2.Event = Event, _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/modulo.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "20807G1bipGRriFOGyGJxbW", "modulo", undefined);
      var Modulo = exports('default', (_dec = register({
        menu: 'Math/Advanced/Modulo',
        title: 'Modulo'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Modulo, _ShaderNode);
        function Modulo() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Modulo.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = mod(" + input0 + ", " + input1 + ");\n        ";
        };
        return Modulo;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/MTDefines.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "12489oNGpZFfYaPjF1Ir4kw", "MTDefines", undefined); // Define the format of a single note in the beatmap
      // Define the types of notes
      var NoteType = exports('NoteType', /*#__PURE__*/function (NoteType) {
        NoteType[NoteType["TAP"] = 0] = "TAP";
        NoteType[NoteType["HOLD"] = 1] = "HOLD";
        NoteType[NoteType["SLIDE"] = 2] = "SLIDE";
        return NoteType;
      }({}));

      // Define the beatmap metadata

      // Define the full beatmap structure
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/MTDragAndDropTool.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AudioManager2.ts', './GameplayManager.ts', './BeatmapManager.ts', './MidiReader.ts', './resourceUtil.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, _asyncToGenerator, _regeneratorRuntime, cclegacy, _decorator, Node, Label, sys, director, AudioClip, Component, MagicTilesAudioManager, GameState, GameplayManager, BeatmapManager, loadMidiFromURL, resourceUtil;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
      _asyncToGenerator = module.asyncToGenerator;
      _regeneratorRuntime = module.regeneratorRuntime;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Label = module.Label;
      sys = module.sys;
      director = module.director;
      AudioClip = module.AudioClip;
      Component = module.Component;
    }, function (module) {
      MagicTilesAudioManager = module.MagicTilesAudioManager;
    }, function (module) {
      GameState = module.GameState;
      GameplayManager = module.GameplayManager;
    }, function (module) {
      BeatmapManager = module.BeatmapManager;
    }, function (module) {
      loadMidiFromURL = module.loadMidiFromURL;
    }, function (module) {
      resourceUtil = module.resourceUtil;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _class3;
      cclegacy._RF.push({}, "04c89d3uFxCxYqeuP2zDazt", "MTDragAndDropTool", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Drag and Drop Tool for Magic Tiles 3
       * Allows users to drag and drop MIDI and audio files to quickly start a game
       */
      var MTDragAndDropTool = exports('MTDragAndDropTool', (_dec = ccclass("MTDragAndDropTool"), _dec2 = property(Node), _dec3 = property(Label), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(MTDragAndDropTool, _Component);
        function MTDragAndDropTool() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "notificationNode", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "notificationLabel", _descriptor2, _assertThisInitialized(_this));
          // Temporary storage for drag-dropped files
          _this._midiFile = null;
          _this._audioFile = null;
          _this._tempBeatmapId = null;
          _this._tempAssets = null;
          // Overlay element for drag visual feedback
          _this._dropOverlay = null;
          return _this;
        }
        var _proto = MTDragAndDropTool.prototype;
        _proto.onLoad = function onLoad() {
          // Set the singleton instance
          MTDragAndDropTool._instance = this;
          this.createDragOverlay();
          this.initialize();
        };
        _proto.onDestroy = function onDestroy() {
          // Clean up the overlay if it exists
          if (this._dropOverlay && this._dropOverlay.parentNode) {
            this._dropOverlay.parentNode.removeChild(this._dropOverlay);
          }

          // Release the singleton instance if it's this component
          if (MTDragAndDropTool._instance === this) {
            MTDragAndDropTool._instance = null;
          }
        }

        /**
         * Create a visual overlay for drag feedback
         */;
        _proto.createDragOverlay = function createDragOverlay() {
          if (!sys.isBrowser) return;

          // Create the overlay element
          var overlay = document.createElement('div');
          overlay.style.position = 'fixed';
          overlay.style.top = '0';
          overlay.style.left = '0';
          overlay.style.width = '100%';
          overlay.style.height = '100%';
          overlay.style.backgroundColor = 'rgba(0, 100, 255, 0.3)';
          overlay.style.display = 'none';
          overlay.style.zIndex = '9999';
          overlay.style.justifyContent = 'center';
          overlay.style.alignItems = 'center';
          overlay.style.fontSize = '24px';
          overlay.style.color = 'white';
          overlay.style.textShadow = '0 0 5px black';
          overlay.innerHTML = '<div style="background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px;">Drop MIDI and Audio files here<br><small>(Need both files to start)</small></div>';
          document.body.appendChild(overlay);
          this._dropOverlay = overlay;
        }

        /**
         * Initialize drag and drop event listeners
         */;
        _proto.initialize = function initialize() {
          var _this2 = this;
          // Ensure we're in a browser environment
          if (!sys.isBrowser) {
            console.warn("MTDragAndDropTool: Drag and drop is only supported in browser environments");
            return;
          }

          // Add event listeners to the document body
          var body = document.body;
          body.addEventListener('dragover', function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (_this2._dropOverlay) {
              _this2._dropOverlay.style.display = 'flex';
            }
          });
          body.addEventListener('dragleave', function (e) {
            e.preventDefault();
            e.stopPropagation();
            // Check if we're actually leaving the document body
            var rect = body.getBoundingClientRect();
            if (e.clientX <= rect.left || e.clientX >= rect.right || e.clientY <= rect.top || e.clientY >= rect.bottom) {
              if (_this2._dropOverlay) {
                _this2._dropOverlay.style.display = 'none';
              }
            }
          });
          body.addEventListener('drop', function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (_this2._dropOverlay) {
              _this2._dropOverlay.style.display = 'none';
            }
            _this2.handleFileDrop(e.dataTransfer.files);
          });
          console.log("MTDragAndDropTool: Initialized drag and drop handlers");
        }

        /**
         * Handle dropped files
         * @param files The files from the drop event
         */;
        _proto.handleFileDrop = function handleFileDrop(files) {
          var _this3 = this;
          if (!files || files.length === 0) return;
          var midiFound = false;
          for (var i = 0; i < files.length; i++) {
            var file = files[i];

            // Check file type - now only looking for MIDI files
            if (file.name.toLowerCase().endsWith('.mid') || file.name.toLowerCase().endsWith('.midi')) {
              this._midiFile = file;
              midiFound = true;
              console.log("MTDragAndDropTool: MIDI file dropped:", file.name);
              break; // Stop after finding the first MIDI file
            }
          }

          // Provide feedback about what files we have
          if (midiFound) {
            this.notifyNextStep("MIDI file received! Processing...");
            // Schedule processing on the next frame to not block
            this.scheduleOnce(function () {
              _this3.processFiles();
            }, 0);
          } else {
            this.notifyNextStep("Please drop a MIDI file (.mid/.midi).");
          }
        }

        /**
         * Process the dropped files to create a temporary beatmap
         */;
        _proto.processFiles = /*#__PURE__*/
        function () {
          var _processFiles = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            var midiFileName, audioResourcePath, audioClip, midiURL, midiData, tempMetadata, tempBeatmap, notes, beatmapManager, audioManager, beatmapAudioData;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  this.notifyNextStep("Processing files...");

                  // Generate a temporary ID for this beatmap
                  this._tempBeatmapId = "temp_" + Date.now();

                  // Get the base name of the MIDI file (without extension)
                  midiFileName = this._midiFile.name.replace(/\.(mid|midi)$/i, ""); // Construct audio resource path using the MIDI file name
                  audioResourcePath = "magic_tiles/audios/" + midiFileName;
                  console.log("Attempting to load audio from resources: " + audioResourcePath);

                  // Load audio from resources
                  _context.prev = 6;
                  _context.next = 9;
                  return this.loadAudioFromResources(audioResourcePath);
                case 9:
                  audioClip = _context.sent;
                  console.log("Successfully loaded audio from resources:", audioClip.name);
                  _context.next = 19;
                  break;
                case 13:
                  _context.prev = 13;
                  _context.t0 = _context["catch"](6);
                  console.error("Failed to load audio resource at " + audioResourcePath + ":", _context.t0);
                  this.notifyNextStep("Could not find matching audio file in resources. Please ensure audio file \"" + midiFileName + ".mp3\" exists in magic_tiles/audios folder.");
                  this.resetFiles();
                  return _context.abrupt("return");
                case 19:
                  // Load the MIDI file
                  midiURL = URL.createObjectURL(this._midiFile);
                  _context.next = 22;
                  return loadMidiFromURL(midiURL);
                case 22:
                  midiData = _context.sent;
                  // Create a temporary beatmap metadata with direct references
                  tempMetadata = {
                    id: this._tempBeatmapId,
                    title: midiFileName,
                    // Use MIDI filename without extension
                    artist: "Unknown Artist",
                    bpm: midiData.tempo || 120,
                    difficulty: 3,
                    difficultyName: "Medium",
                    level: 5,
                    preview: {
                      start: 0,
                      end: 30
                    },
                    // Use the actual assets rather than paths that don't exist
                    audioPath: null,
                    // We'll override this in our implementation
                    midiPath: null,
                    // We'll override this in our implementation
                    backgroundImage: "magic_tiles/images/default_background",
                    coverImage: "magic_tiles/images/default_cover"
                  }; // Create a temporary JSON data for the beatmap
                  tempBeatmap = {
                    metadata: tempMetadata,
                    notes: [] // Will be generated from MIDI
                  }; // Process MIDI data to generate notes for the beatmap
                  if (!(midiData && midiData.notes)) {
                    _context.next = 32;
                    break;
                  }
                  notes = [];
                  notes = BeatmapManager.instance.convertNotes(midiData.notes, notes);
                  tempBeatmap.notes = notes;
                  console.log("Processed " + tempBeatmap.notes.length + " notes from MIDI data");
                  _context.next = 36;
                  break;
                case 32:
                  console.warn("No valid MIDI tracks found in the file");
                  this.notifyNextStep("MIDI file doesn't contain valid note data. Please try another file.");
                  this.resetFiles();
                  return _context.abrupt("return");
                case 36:
                  // Add the beatmap to the BeatmapManager
                  beatmapManager = BeatmapManager.instance; // Set the current beatmap for the audio manager
                  audioManager = MagicTilesAudioManager.instance; // Debug the audio clip to check its properties
                  console.log("AudioClip details:", {
                    name: audioClip.name,
                    duration: audioClip.getDuration(),
                    isValid: audioClip.loaded,
                    type: typeof audioClip._nativeAsset
                  });

                  // Create a BeatmapAudioData object with our loaded assets
                  beatmapAudioData = {
                    clip: audioClip,
                    trackInfo: midiData,
                    totalDuration: audioClip.getDuration() || 180,
                    // Default to 3 minutes if duration is not available
                    currentTime: 0,
                    isPlaying: false,
                    isPaused: false
                  }; // Set the current beatmap in the audio manager
                  audioManager.setCurrentBeatmap(beatmapAudioData);
                  beatmapManager.addTempBeatmap(this._tempBeatmapId, tempBeatmap);

                  // Start the game
                  this.startGame();
                  _context.next = 50;
                  break;
                case 45:
                  _context.prev = 45;
                  _context.t1 = _context["catch"](0);
                  console.error("MTDragAndDropTool: Error processing files:", _context.t1);
                  this.notifyNextStep("Error processing files: " + _context.t1.message);
                  this.resetFiles();
                case 50:
                case "end":
                  return _context.stop();
              }
            }, _callee, this, [[0, 45], [6, 13]]);
          }));
          function processFiles() {
            return _processFiles.apply(this, arguments);
          }
          return processFiles;
        }()
        /**
         * Start a new game with the temporary beatmap
         */;

        _proto.startGame = function startGame() {
          // Find the GameplayManager
          var gameplayManager = this.findGameplayManager();
          if (!gameplayManager) {
            console.error("MTDragAndDropTool: GameplayManager not found");
            this.notifyNextStep("Cannot start game. Please try loading files from the game menu.");
            return;
          }
          this.notifyNextStep("Starting game...");

          // Start the game with the temporary beatmap
          gameplayManager.resetGameState();
          gameplayManager.setGameState(GameState.LOADING);
          gameplayManager.tileManager.initGame();
          gameplayManager.createBeginningTile();

          // Reset files after starting
          this.resetFiles();
        }

        /**
         * Helper method to find the GameplayManager component
         */;
        _proto.findGameplayManager = function findGameplayManager() {
          return director.getScene().getComponentInChildren(GameplayManager);
        }

        /**
         * Load an audio file from resources
         */;
        _proto.loadAudioFromResources = function loadAudioFromResources(path) {
          return new Promise(function (resolve, reject) {
            // Use the utility function to load from resources
            resourceUtil.loadRes(path, AudioClip, function (err, audioClip) {
              if (err) {
                console.error("Failed to load audio from resources:", err);
                reject(err);
                return;
              }

              // Check if we have a valid AudioClip
              if (!audioClip || !(audioClip instanceof AudioClip)) {
                console.error("Invalid AudioClip received:", audioClip);
                reject("Invalid AudioClip received");
              } else {
                console.log("Successfully loaded AudioClip from resources:", audioClip);
                resolve(audioClip);
              }
            });
          });
        }

        /**
         * Reset the stored files
         */;
        _proto.resetFiles = function resetFiles() {
          // Release object URLs if they exist
          if (this._midiFile) URL.revokeObjectURL(URL.createObjectURL(this._midiFile));
          this._midiFile = null;
          this._tempBeatmapId = null;
          this._tempAssets = null;
        }

        /**
         * Show a notification about the next step
         */;
        _proto.notifyNextStep = function notifyNextStep(message) {
          var _this4 = this;
          console.log("MTDragAndDropTool: " + message);

          // If we have a notification node with label, use it
          if (this.notificationNode && this.notificationLabel) {
            this.notificationNode.active = true;
            this.notificationLabel.string = message;

            // Hide after a few seconds
            this.scheduleOnce(function () {
              _this4.notificationNode.active = false;
            }, 3);
          } else {
            // Fallback notification - use a custom overlay instead of alert
            this.showTemporaryNotification(message);
          }
        }

        /**
         * Show a temporary HTML notification when the Cocos UI isn't available
         */;
        _proto.showTemporaryNotification = function showTemporaryNotification(message) {
          if (!sys.isBrowser) return;

          // Create a simple notification element
          var notification = document.createElement('div');
          notification.style.position = 'fixed';
          notification.style.bottom = '20px';
          notification.style.left = '50%';
          notification.style.transform = 'translateX(-50%)';
          notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
          notification.style.color = 'white';
          notification.style.padding = '10px 20px';
          notification.style.borderRadius = '5px';
          notification.style.zIndex = '10000';
          notification.innerText = message;
          document.body.appendChild(notification);

          // Remove after 3 seconds
          setTimeout(function () {
            if (notification.parentNode) {
              notification.parentNode.removeChild(notification);
            }
          }, 3000);
        };
        _createClass(MTDragAndDropTool, null, [{
          key: "instance",
          get:
          // Singleton pattern
          function get() {
            return this._instance;
          }
        }]);
        return MTDragAndDropTool;
      }(Component), _class3._instance = null, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "notificationNode", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "notificationLabel", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/MTItemSong.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Label, Button, Sprite, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Label = module.Label;
      Button = module.Button;
      Sprite = module.Sprite;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;
      cclegacy._RF.push({}, "dd74eu3S4NEpap53qs6fEO1", "MTItemSong", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var MTItemSong = exports('MTItemSong', (_dec = ccclass('MTItemSong'), _dec2 = property(Label), _dec3 = property(Label), _dec4 = property(Label), _dec5 = property(Button), _dec6 = property(Sprite), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(MTItemSong, _Component);
        function MTItemSong() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "songNameLabel", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "artistLabel", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "difficultyLabel", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "selectButton", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "coverSprite", _descriptor5, _assertThisInitialized(_this));
          _this.songData = null;
          _this.selectionCallback = null;
          return _this;
        }
        var _proto = MTItemSong.prototype;
        _proto.start = function start() {
          // Set up button event
          if (this.selectButton) {
            this.selectButton.node.on('click', this.onSongSelected, this);
          }
        }

        /**
         * Set the song data for this item
         * @param songData The metadata of the song to display
         * @param callback The callback to invoke when this song is selected
         */;
        _proto.setSongData = function setSongData(songData, callback) {
          this.songData = songData;
          this.selectionCallback = callback;

          // Update UI elements
          if (this.songNameLabel) {
            this.songNameLabel.string = songData.title || 'Unknown Title';
          }
          if (this.artistLabel) {
            this.artistLabel.string = songData.artist || 'Unknown Artist';
          }
          if (this.difficultyLabel) {
            this.difficultyLabel.string = "Difficulty: " + (songData.difficultyName || 'Medium');
          }

          // Load cover image if available
          if (this.coverSprite && songData.coverImage) ;
        }

        /**
         * Handler for when the song is selected
         */;
        _proto.onSongSelected = function onSongSelected() {
          if (this.selectionCallback && this.songData) {
            this.selectionCallback(this.songData.id);
          }
        };
        _proto.update = function update(deltaTime) {};
        return MTItemSong;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "songNameLabel", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "artistLabel", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "difficultyLabel", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "selectButton", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "coverSprite", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/MTUIManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './AudioManager2.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Node, Label, ProgressBar, Sprite, view, sys, Vec3, UITransform, Widget, tween, instantiate, Button, EventHandler, Component, MagicTilesAudioManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Label = module.Label;
      ProgressBar = module.ProgressBar;
      Sprite = module.Sprite;
      view = module.view;
      sys = module.sys;
      Vec3 = module.Vec3;
      UITransform = module.UITransform;
      Widget = module.Widget;
      tween = module.tween;
      instantiate = module.instantiate;
      Button = module.Button;
      EventHandler = module.EventHandler;
      Component = module.Component;
    }, function (module) {
      MagicTilesAudioManager = module.MagicTilesAudioManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _descriptor20, _descriptor21, _descriptor22, _descriptor23, _descriptor24, _descriptor25, _class3;
      cclegacy._RF.push({}, "974fdPppslMoKLXs565FEx6", "MTUIManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * UI states representing different screens in the game
       */
      var UIState = exports('UIState', /*#__PURE__*/function (UIState) {
        UIState[UIState["NONE"] = 0] = "NONE";
        UIState[UIState["MAIN_MENU"] = 1] = "MAIN_MENU";
        UIState[UIState["SONG_SELECT"] = 2] = "SONG_SELECT";
        UIState[UIState["GAMEPLAY"] = 3] = "GAMEPLAY";
        UIState[UIState["PAUSE_MENU"] = 4] = "PAUSE_MENU";
        UIState[UIState["RESULTS"] = 5] = "RESULTS";
        UIState[UIState["SETTINGS"] = 6] = "SETTINGS";
        UIState[UIState["TUTORIAL"] = 7] = "TUTORIAL";
        UIState[UIState["SHOP"] = 8] = "SHOP";
        return UIState;
      }({}));

      /**
       * UIManager for Magic Tiles 3
       * Handles all UI elements, menus, transitions, and responsive layout
       */
      var MTUIManager = exports('MTUIManager', (_dec = ccclass('MTUIManager'), _dec2 = property(Node), _dec3 = property(Node), _dec4 = property(Node), _dec5 = property(Node), _dec6 = property(Node), _dec7 = property(Node), _dec8 = property(Node), _dec9 = property(Node), _dec10 = property(Node), _dec11 = property(Label), _dec12 = property(Label), _dec13 = property(Label), _dec14 = property(ProgressBar), _dec15 = property(Sprite), _dec16 = property(Label), _dec17 = property(Label), _dec18 = property(Label), _dec19 = property(Label), _dec20 = property(Label), _dec21 = property(Label), _dec22 = property(Label), _dec23 = property(Label), _dec24 = property(Label), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(MTUIManager, _Component);
        function MTUIManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // UI Screens (top-level containers)
          _initializerDefineProperty(_this, "mainMenuScreen", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songSelectScreen", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "gameplayScreen", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "pauseMenuScreen", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "resultsScreen", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "settingsScreen", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "tutorialScreen", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "shopScreen", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "loadingScreen", _descriptor9, _assertThisInitialized(_this));
          // HUD Elements
          _initializerDefineProperty(_this, "scoreLabel", _descriptor10, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songTimeLabel", _descriptor11, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "comboLabel", _descriptor12, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "progressBar", _descriptor13, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "healthBar", _descriptor14, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songTitleLabel", _descriptor15, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songArtistLabel", _descriptor16, _assertThisInitialized(_this));
          // Results Elements
          _initializerDefineProperty(_this, "finalScoreLabel", _descriptor17, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "accuracyLabel", _descriptor18, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "maxComboLabel", _descriptor19, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "perfectCountLabel", _descriptor20, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "goodCountLabel", _descriptor21, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "okCountLabel", _descriptor22, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "missCountLabel", _descriptor23, _assertThisInitialized(_this));
          // Managers
          // @property(GameplayManager)
          // gameplayManager: GameplayManager = null!;
          // @property(ScoreManager)
          // scoreManager: ScoreManager = null!;
          // @property(TapValidator)
          // tapValidator: TapValidator = null!;
          // @property(SongSelectionManager)
          // songSelectionManager: SongSelectionManager = null!;
          // UI Settings
          _initializerDefineProperty(_this, "transitionDuration", _descriptor24, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "popupScaleDuration", _descriptor25, _assertThisInitialized(_this));
          // Current state
          _this.currentUIState = UIState.NONE;
          _this.previousUIState = UIState.NONE;
          _this.isTransitioning = false;
          _this.audioManager = null;
          // Screen size variables for responsive layout
          _this.screenWidth = 0;
          _this.screenHeight = 0;
          _this.safeAreaTop = 0;
          _this.safeAreaBottom = 0;
          _this.isPortrait = true;
          return _this;
        }
        var _proto = MTUIManager.prototype;
        _proto.onLoad = function onLoad() {
          // Set static instance
          MTUIManager._instance = this;

          // Get audio manager
          this.audioManager = MagicTilesAudioManager.instance;

          // Initialize UI state
          this.initializeUI();

          // Register for gameplay manager events
          // if (this.gameplayManager) {
          //     this.gameplayManager.onGameStateChanged(this.onGameStateChanged.bind(this));
          //     this.gameplayManager.onSurvivalHPChanged(this.updateHealthBar.bind(this));
          // }sys

          // // Register for score manager events
          // if (this.scoreManager) {
          //     this.scoreManager.onScoreChanged(this.updateScoreDisplay.bind(this));
          // }

          // // Register for tap validator events
          // if (this.tapValidator) {
          //     this.tapValidator.onComboChange(this.updateComboDisplay.bind(this));
          // }

          // Register for window resize events
          view.on('design-resolution-changed', this.onScreenResize, this);
          view.on('canvas-resize', this.onScreenResize, this);

          // Initial screen setup
          this.onScreenResize();
        };
        _proto.onDestroy = function onDestroy() {
          // Unregister from window resize events
          view.off('design-resolution-changed', this.onScreenResize, this);
          view.off('canvas-resize', this.onScreenResize, this);

          // Clear static instance
          if (MTUIManager._instance === this) {
            MTUIManager._instance = null;
          }
        }

        /**
         * Initialize UI state and hide all screens
         */;
        _proto.initializeUI = function initializeUI() {
          // Hide all screens initially
          this.hideAllScreens();

          // Set initial state
          this.changeUIState(UIState.MAIN_MENU);
        }

        /**
         * Handle screen resize to adjust layout
         */;
        _proto.onScreenResize = function onScreenResize() {
          var visibleSize = view.getVisibleSize();
          this.screenWidth = visibleSize.width;
          this.screenHeight = visibleSize.height;
          this.isPortrait = this.screenHeight > this.screenWidth;

          // Get safe area info (mainly for mobile devices with notches)
          if (sys.platform === sys.Platform.MOBILE_BROWSER || sys.platform === sys.Platform.IOS || sys.platform === sys.Platform.ANDROID) {
            var safeArea = sys.getSafeAreaRect();
            this.safeAreaTop = safeArea.y;
            this.safeAreaBottom = visibleSize.height - (safeArea.y + safeArea.height);
          }

          // Adjust layout for current orientation
          this.adjustLayoutForScreenSize();
        }

        /**
         * Adjust layout based on screen size and orientation
         */;
        _proto.adjustLayoutForScreenSize = function adjustLayoutForScreenSize() {
          // Find all widgets in the scene and update their alignments
          this.updateWidgetsInNode(this.node);

          // Adjust specific layouts based on orientation
          if (this.isPortrait) {
            this.applyPortraitLayout();
          } else {
            this.applyLandscapeLayout();
          }
        }

        /**
         * Apply portrait-specific layout changes
         */;
        _proto.applyPortraitLayout = function applyPortraitLayout() {
          // Adjust game elements for portrait mode
          // For example, make lanes narrower and taller

          // Position HUD elements for portrait
          if (this.scoreLabel) {
            this.scoreLabel.node.position = new Vec3(0, this.screenHeight * 0.4, 0);
          }
          if (this.comboLabel) {
            this.comboLabel.node.position = new Vec3(0, this.screenHeight * 0.3, 0);
          }

          // Adjust progress bar width
          if (this.progressBar) {
            var transform = this.progressBar.getComponent(UITransform);
            if (transform) {
              transform.width = this.screenWidth * 0.8;
            }
          }
          console.log("Applied portrait layout");
        }

        /**
         * Apply landscape-specific layout changes
         */;
        _proto.applyLandscapeLayout = function applyLandscapeLayout() {
          // Adjust game elements for landscape mode
          // For example, make lanes wider and shorter

          // Position HUD elements for landscape
          if (this.scoreLabel) {
            this.scoreLabel.node.position = new Vec3(this.screenWidth * 0.3, this.screenHeight * 0.4, 0);
          }
          if (this.comboLabel) {
            this.comboLabel.node.position = new Vec3(this.screenWidth * 0.3, this.screenHeight * 0.3, 0);
          }

          // Adjust progress bar width
          if (this.progressBar) {
            var transform = this.progressBar.getComponent(UITransform);
            if (transform) {
              transform.width = this.screenWidth * 0.6;
            }
          }
          console.log("Applied landscape layout");
        }

        /**
         * Update all widgets in a node hierarchy to refresh layout
         */;
        _proto.updateWidgetsInNode = function updateWidgetsInNode(node) {
          // Update the current node's widget if it has one
          var widget = node.getComponent(Widget);
          if (widget) {
            widget.updateAlignment();
          }

          // Update all children recursively
          for (var i = 0; i < node.children.length; i++) {
            this.updateWidgetsInNode(node.children[i]);
          }
        }

        /**
         * Handle game state changes from the gameplay manager
         */
        // private onGameStateChanged(newState: GameState) {
        //     switch (newState) {
        //         case GameState.NONE:
        //             // Usually means we're returning to menu
        //             this.changeUIState(UIState.MAIN_MENU);
        //             break;

        //         case GameState.LOADING:
        //             this.showLoadingScreen(true);
        //             break;

        //         case GameState.COUNTDOWN:
        //             this.showLoadingScreen(false);
        //             this.changeUIState(UIState.GAMEPLAY);
        //             break;

        //         case GameState.PLAYING:
        //             this.updateGameplayUI();
        //             break;

        //         case GameState.PAUSED:
        //             this.changeUIState(UIState.PAUSE_MENU);
        //             break;

        //         case GameState.COMPLETED:
        //         case GameState.FAILED:
        //             this.prepareResultsScreen();
        //             this.changeUIState(UIState.RESULTS);
        //             break;
        //     }
        // }

        /**
         * Change the current UI state with animation
         */;
        _proto.changeUIState = function changeUIState(newState) {
          var _this2 = this;
          // Prevent changing during transition
          if (this.isTransitioning) return;

          // Skip if same state
          if (newState === this.currentUIState) return;
          this.isTransitioning = true;
          this.previousUIState = this.currentUIState;
          this.currentUIState = newState;

          // Fade out current screen
          var currentScreen = this.getScreenForState(this.previousUIState);
          if (currentScreen) {
            tween(currentScreen).to(this.transitionDuration / 2, {
              scale: new Vec3(0.9, 0.9, 1)
            }).call(function () {
              currentScreen.active = false;

              // Fade in new screen
              var newScreen = _this2.getScreenForState(newState);
              if (newScreen) {
                newScreen.active = true;
                newScreen.scale = new Vec3(0.9, 0.9, 1);
                tween(newScreen).to(_this2.transitionDuration / 2, {
                  scale: new Vec3(1, 1, 1)
                }).call(function () {
                  _this2.isTransitioning = false;
                  _this2.onUIStateChanged(newState);
                }).start();
              } else {
                _this2.isTransitioning = false;
              }
            }).start();
          } else {
            // No current screen, just show new screen
            var newScreen = this.getScreenForState(newState);
            if (newScreen) {
              newScreen.active = true;
              newScreen.scale = new Vec3(0.9, 0.9, 1);
              tween(newScreen).to(this.transitionDuration / 2, {
                scale: new Vec3(1, 1, 1)
              }).call(function () {
                _this2.isTransitioning = false;
                _this2.onUIStateChanged(newState);
              }).start();
            } else {
              this.isTransitioning = false;
            }
          }
        }

        /**
         * Get the screen node for a UI state
         */;
        _proto.getScreenForState = function getScreenForState(state) {
          switch (state) {
            case UIState.MAIN_MENU:
              return this.mainMenuScreen;
            case UIState.SONG_SELECT:
              return this.songSelectScreen;
            case UIState.GAMEPLAY:
              return this.gameplayScreen;
            case UIState.PAUSE_MENU:
              return this.pauseMenuScreen;
            case UIState.RESULTS:
              return this.resultsScreen;
            case UIState.SETTINGS:
              return this.settingsScreen;
            case UIState.TUTORIAL:
              return this.tutorialScreen;
            case UIState.SHOP:
              return this.shopScreen;
            default:
              return null;
          }
        }

        /**
         * Handle actions when UI state has changed
         */;
        _proto.onUIStateChanged = function onUIStateChanged(newState) {
          // Handle state-specific actions
          switch (newState) {
            case UIState.MAIN_MENU:
              // Play menu music
              this.audioManager.playSound("menu_music");
              break;
            case UIState.SONG_SELECT:
              // Initialize song list
              // if (this.songSelectionManager) {
              //     this.songSelectionManager.refreshSongList();
              // }
              break;
            case UIState.GAMEPLAY:
              // Make sure HUD elements are visible and updated
              this.updateGameplayUI();
              break;
            case UIState.RESULTS:
              // Results screen is prepared in prepareResultsScreen()
              break;
          }
        }

        /**
         * Hide all UI screens
         */;
        _proto.hideAllScreens = function hideAllScreens() {
          if (this.mainMenuScreen) this.mainMenuScreen.active = false;
          if (this.songSelectScreen) this.songSelectScreen.active = false;
          if (this.gameplayScreen) this.gameplayScreen.active = false;
          if (this.pauseMenuScreen) this.pauseMenuScreen.active = false;
          if (this.resultsScreen) this.resultsScreen.active = false;
          if (this.settingsScreen) this.settingsScreen.active = false;
          if (this.tutorialScreen) this.tutorialScreen.active = false;
          if (this.shopScreen) this.shopScreen.active = false;
          if (this.loadingScreen) this.loadingScreen.active = false;
        }

        /**
         * Show/hide the loading screen
         */;
        _proto.showLoadingScreen = function showLoadingScreen(show) {
          if (this.loadingScreen) {
            this.loadingScreen.active = show;
          }
        }

        /**
         * Update gameplay HUD elements
         */;
        _proto.updateGameplayUI = function updateGameplayUI() {
          // this.updateScoreDisplay(this.scoreManager.getCurrentScore());
          // this.updateComboDisplay(this.tapValidator.getCombo());
          // this.updateProgressBar(this.gameplayManager.getProgress());
          // this.updateHealthBar(this.gameplayManager.getSurvivalHP());
        }

        /**
         * Update the score display
         */;
        _proto.updateScoreDisplay = function updateScoreDisplay(score) {
          if (this.scoreLabel) {
            this.scoreLabel.string = score.toLocaleString();
          }
        };
        _proto.updateSongTimeDisplay = function updateSongTimeDisplay(time) {
          if (this.songTimeLabel) {
            this.songTimeLabel.string = this.formatTime(time);
          }
        };
        _proto.formatTime = function formatTime(seconds) {
          var minutes = Math.floor(seconds / 60);
          var remainingSeconds = Math.floor(seconds % 60);
          return minutes + ":" + (remainingSeconds < 10 ? '0' + remainingSeconds : remainingSeconds);
        }

        /**
         * Update the combo display
         */;
        _proto.updateComboDisplay = function updateComboDisplay(combo) {
          if (this.comboLabel) {
            if (combo > 1) {
              this.comboLabel.string = combo + "x";
              this.comboLabel.node.active = true;

              // Pulse animation
              tween(this.comboLabel.node).to(0.1, {
                scale: new Vec3(1.2, 1.2, 1)
              }).to(0.1, {
                scale: new Vec3(1, 1, 1)
              }).start();
            } else {
              this.comboLabel.string = "";
              this.comboLabel.node.active = false;
            }
          }
        }

        /**
         * Update the progress bar
         */;
        _proto.updateProgressBar = function updateProgressBar(progress) {
          if (this.progressBar) {
            this.progressBar.progress = progress;
          }
        }

        /**
         * Update the health bar
         */;
        _proto.updateHealthBar = function updateHealthBar(hp) {
          // if (this.healthBar) {
          //     // Update fill amount
          //     const maxHP = this.gameplayManager.maxSurvivalHP;
          //     const fillAmount = hp / maxHP;

          //     // Get the fill sprite if this is a progress bar
          //     const fillSprite = this.healthBar.node.getChildByName("Fill")?.getComponent(Sprite);
          //     if (fillSprite) {
          //         const transform = fillSprite.getComponent(UITransform);
          //         if (transform) {
          //             const parentTransform = this.healthBar.getComponent(UITransform);
          //             transform.width = parentTransform.width * fillAmount;
          //         }
          //     }

          //     // Change color based on health
          //     let color = new Color();
          //     if (fillAmount > 0.6) {
          //         // Green for high health
          //         color = new Color(0, 255, 0, 255);
          //     } else if (fillAmount > 0.3) {
          //         // Yellow for medium health
          //         color = new Color(255, 255, 0, 255);
          //     } else {
          //         // Red for low health
          //         color = new Color(255, 0, 0, 255);

          //         // Pulse animation for low health
          //         if (fillAmount < 0.2) {
          //             tween(this.healthBar.node)
          //                 // .to(0.5, { opacity: 150 })
          //                 // .to(0.5, { opacity: 255 })
          //                 .union()
          //                 .repeatForever()
          //                 .start();
          //         }
          //     }

          //     if (fillSprite) {
          //         fillSprite.color = color;
          //     } else {
          //         this.healthBar.color = color;
          //     }
          // }
        }

        /**
         * Prepare the results screen with final stats
         */;
        _proto.prepareResultsScreen = function prepareResultsScreen(finalScore, accuracy, maxCombo, ratingCounts) {
          if (finalScore === void 0) {
            finalScore = 0;
          }
          if (accuracy === void 0) {
            accuracy = 0;
          }
          if (maxCombo === void 0) {
            maxCombo = 0;
          }
          if (ratingCounts === void 0) {
            ratingCounts = {
              perfect: 0,
              good: 0,
              ok: 0,
              miss: 0
            };
          }
          if (!this.resultsScreen) return;

          // Update UI elements
          if (this.finalScoreLabel) {
            this.finalScoreLabel.string = finalScore.toLocaleString();
          }
          if (this.accuracyLabel) {
            this.accuracyLabel.string = accuracy.toFixed(2) + "%";
          }
          if (this.maxComboLabel) {
            this.maxComboLabel.string = maxCombo + "x";
          }
          if (this.perfectCountLabel) {
            this.perfectCountLabel.string = ratingCounts.perfect.toString();
          }
          if (this.goodCountLabel) {
            this.goodCountLabel.string = ratingCounts.good.toString();
          }
          if (this.okCountLabel) {
            this.okCountLabel.string = ratingCounts.ok.toString();
          }
          if (this.missCountLabel) {
            this.missCountLabel.string = ratingCounts.miss.toString();
          }

          // Check for high score
          var isHighScore = false; // TODO: Implement high score check

          // Show high score label if applicable
          var highScoreLabel = this.resultsScreen.getChildByName("HighScoreLabel");
          if (highScoreLabel) {
            highScoreLabel.active = isHighScore;
          }
        }

        /**
         * Show a popup dialog
         */;
        _proto.showPopup = function showPopup(message, title, buttonText) {
          var _popup$getChildByName, _popup$getChildByName2, _popup$getChildByName3, _button$node$getChild;
          if (title === void 0) {
            title = "";
          }
          if (buttonText === void 0) {
            buttonText = "OK";
          }
          // Find popup template
          var popupTemplate = this.node.getChildByName("PopupTemplate");
          if (!popupTemplate) return;

          // Create popup instance
          var popup = instantiate(popupTemplate);
          popup.parent = this.node;
          popup.active = true;

          // Set content
          var titleLabel = (_popup$getChildByName = popup.getChildByName("Title")) == null ? void 0 : _popup$getChildByName.getComponent(Label);
          var messageLabel = (_popup$getChildByName2 = popup.getChildByName("Message")) == null ? void 0 : _popup$getChildByName2.getComponent(Label);
          var button = (_popup$getChildByName3 = popup.getChildByName("OkButton")) == null ? void 0 : _popup$getChildByName3.getComponent(Button);
          var buttonLabel = button == null || (_button$node$getChild = button.node.getChildByName("Label")) == null ? void 0 : _button$node$getChild.getComponent(Label);
          if (titleLabel) {
            titleLabel.string = title;
            titleLabel.node.active = title.length > 0;
          }
          if (messageLabel) {
            messageLabel.string = message;
          }
          if (buttonLabel) {
            buttonLabel.string = buttonText;
          }

          // Setup button action
          if (button) {
            var clickEventHandler = new EventHandler();
            clickEventHandler.target = popup;
            clickEventHandler.component = "UIManager";
            clickEventHandler.handler = "onPopupButtonClicked";
            button.clickEvents.push(clickEventHandler);
          }

          // Animation
          popup.scale = new Vec3(0.8, 0.8, 1);
          tween(popup).to(this.popupScaleDuration, {
            scale: new Vec3(1, 1, 1)
          }).start();
          return popup;
        }

        /**
         * Close a popup
         */;
        _proto.closePopup = function closePopup(popup) {
          tween(popup).to(this.popupScaleDuration, {
            scale: new Vec3(0.8, 0.8, 1)
          }).call(function () {
            popup.destroy();
          }).start();
        }

        /**
         * Event handler for popup button clicks
         */;
        _proto.onPopupButtonClicked = function onPopupButtonClicked(event, customData) {
          // Get the popup node (parent of the button)
          var button = event.target;
          if (!button) return;
          var popup = button.parent;
          if (!popup) return;

          // Close the popup
          this.closePopup(popup);
        }

        /**
         * Navigate to main menu
         */;
        _proto.navigateToMainMenu = function navigateToMainMenu() {
          this.changeUIState(UIState.MAIN_MENU);
        }

        /**
         * Navigate to song selection
         */;
        _proto.navigateToSongSelect = function navigateToSongSelect() {
          this.changeUIState(UIState.SONG_SELECT);
        }

        /**
         * Navigate to settings
         */;
        _proto.navigateToSettings = function navigateToSettings() {
          this.changeUIState(UIState.SETTINGS);
        }

        /**
         * Navigate to tutorial
         */;
        _proto.navigateToTutorial = function navigateToTutorial() {
          this.changeUIState(UIState.TUTORIAL);
        }

        /**
         * Navigate to shop
         */;
        _proto.navigateToShop = function navigateToShop() {
          this.changeUIState(UIState.SHOP);
        }

        /**
         * Handle back button or ESC key
         */;
        _proto.handleBackNavigation = function handleBackNavigation() {
          // Handle back navigation based on current state
          switch (this.currentUIState) {
            case UIState.SONG_SELECT:
            case UIState.SETTINGS:
            case UIState.TUTORIAL:
            case UIState.SHOP:
              this.navigateToMainMenu();
              break;
            case UIState.GAMEPLAY:
              // this.gameplayManager.togglePause();
              break;
            case UIState.PAUSE_MENU:
              // this.gameplayManager.resumeGame();
              break;
            case UIState.RESULTS:
              this.navigateToSongSelect();
              break;
          }
        };
        _createClass(MTUIManager, null, [{
          key: "instance",
          get: function get() {
            if (!MTUIManager._instance) {
              return null;
            }
            return MTUIManager._instance;
          }
        }]);
        return MTUIManager;
      }(Component), _class3._instance = null, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "mainMenuScreen", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "songSelectScreen", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "gameplayScreen", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "pauseMenuScreen", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "resultsScreen", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "settingsScreen", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "tutorialScreen", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "shopScreen", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "loadingScreen", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "scoreLabel", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "songTimeLabel", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "comboLabel", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "progressBar", [_dec14], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, "healthBar", [_dec15], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor15 = _applyDecoratedDescriptor(_class2.prototype, "songTitleLabel", [_dec16], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor16 = _applyDecoratedDescriptor(_class2.prototype, "songArtistLabel", [_dec17], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor17 = _applyDecoratedDescriptor(_class2.prototype, "finalScoreLabel", [_dec18], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor18 = _applyDecoratedDescriptor(_class2.prototype, "accuracyLabel", [_dec19], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor19 = _applyDecoratedDescriptor(_class2.prototype, "maxComboLabel", [_dec20], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor20 = _applyDecoratedDescriptor(_class2.prototype, "perfectCountLabel", [_dec21], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor21 = _applyDecoratedDescriptor(_class2.prototype, "goodCountLabel", [_dec22], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor22 = _applyDecoratedDescriptor(_class2.prototype, "okCountLabel", [_dec23], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor23 = _applyDecoratedDescriptor(_class2.prototype, "missCountLabel", [_dec24], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor24 = _applyDecoratedDescriptor(_class2.prototype, "transitionDuration", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.3;
        }
      }), _descriptor25 = _applyDecoratedDescriptor(_class2.prototype, "popupScaleDuration", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.2;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/multiply.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "eb609R33glDfpL2KytmHUQe", "multiply", undefined);
      var Multiply = exports('default', (_dec = register({
        menu: 'Math/Basic/Multiply',
        title: 'Multiply'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Multiply, _ShaderNode);
        function Multiply() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Max;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Multiply.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = " + input0 + " * " + input1 + ";\n        ";
        };
        return Multiply;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/negate.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "1b741yPEQlEVL911xSY0qGi", "negate", undefined);
      var Negate = exports('default', (_dec = register({
        menu: 'Math/Advanced/Negate',
        title: 'Negate'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Negate, _ShaderNode);
        function Negate() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Negate.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = -" + input0 + ";\n        ";
        };
        return Negate;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/noise-sine-wave.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, Vec2, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
      Vec2 = module.Vec2;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "fdd3afGjspKIb7t04FDpYVl", "noise-sine-wave", undefined);
      var NoiseSineWave = exports('default', (_dec = register({
        menu: 'Math/Wave/NoiseSineWave',
        title: 'NoiseSineWave'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(NoiseSineWave, _ShaderNode);
        function NoiseSineWave() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector'), slot('MinMax', Vec2.ZERO, 'vec2', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = NoiseSineWave.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            float sinIn = sin(" + input0 + ");\n            float sinInOffset = sin(" + input0 + " + 1.0);\n            float randomno =  frac(sin((sinIn - sinInOffset) * (12.9898 + 78.233))*43758.5453);\n            float noise = lerp(" + input1 + ".x, " + input1 + ".y, randomno);\n            " + output0 + " = sinIn + noise;\n        ";
        };
        return NoiseSineWave;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/normal-vector.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './base.ts', './type.ts', './utils.ts', './index3.ts', './register.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec3, ShaderNode, NormalSpace, ConcretePrecisionType, getEnumDefine, prop, slot, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec3 = module.Vec3;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      NormalSpace = module.NormalSpace;
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      getEnumDefine = module.getEnumDefine;
      prop = module.prop;
      slot = module.slot;
    }, null, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "f4d52tjGCZK1JsKsZ4QUDNC", "normal-vector", undefined);
      var NormalVectorNode = exports('default', (_dec = register({
        menu: 'Input/Geometry/NormalVector',
        title: 'NormalVector'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(NormalVectorNode, _ShaderNode);
        function NormalVectorNode() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.fixedConcretePrecision = 3;
          _this.data = {
            props: [prop('Space', NormalSpace.World, 'enum', {
              "enum": NormalSpace
            })],
            outputs: [slot('Normal', Vec3.ZERO, 'vec3', 'vector')]
          };
          return _this;
        }
        var _proto = NormalVectorNode.prototype;
        _proto.generateCode = function generateCode() {
          var prop = this.getPropWithName('Space');
          var name = 'normal';
          if (prop.value === NormalSpace.Local) {
            name = 'normal';
          } else if (prop.value === NormalSpace.View) {
            name = 'viewNormal';
          }
          // else if (prop.value === NormalSpace.Tangent) {
          //     // name = 'tangentNormal';
          //     name = 'worldNormal';
          // }
          else if (prop.value === NormalSpace.World) {
            name = 'worldNormal';
          }
          this.defines = [getEnumDefine(NormalSpace, prop.value)];
          return this.getOutputVarDefine(0) + " = " + name + ";";
        };
        return NormalVectorNode;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/normalize.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "00775HyBCRKYqjtgTFMEtIo", "normalize", undefined);
      var Normalize = exports('default', (_dec = register({
        menu: 'Math/Advanced/Normalize',
        title: 'Normalize'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Normalize, _ShaderNode);
        function Normalize() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Normalize.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = normalize(" + input0 + ");\n        ";
        };
        return Normalize;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/not.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "aad29jVDvZJX7eHgVCkzuSx", "not", undefined);
      var Not = exports('default', (_dec = register({
        menu: 'Logic/Not',
        title: 'Not'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Not, _ShaderNode);
        function Not() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Max;
          _this.data = {
            inputs: [slot('In', false, 'boolean', 'boolean')],
            outputs: [slot('Out', false, 'boolean', 'boolean')]
          };
          return _this;
        }
        var _proto = Not.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var i0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = (!" + i0 + ");\n        ";
        };
        return Not;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ObjectPoolData.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, _decorator, Prefab, Node;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Prefab = module.Prefab;
      Node = module.Node;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "6de52PO/FFI4qh57HrWi8RF", "ObjectPoolData", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var ObjectPoolData = exports('ObjectPoolData', (_dec = ccclass('ObjectPoolData'), _dec2 = property(Prefab), _dec3 = property(Node), _dec(_class = (_class2 = function ObjectPoolData() {
        _initializerDefineProperty(this, "prefab", _descriptor, this);
        _initializerDefineProperty(this, "container", _descriptor2, this);
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "prefab", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "container", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/one-minus.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "cd61fVd7UJBB6ngXO+30nVS", "one-minus", undefined);
      var OneMinus = exports('default', (_dec = register({
        menu: 'Math/Range/OneMinus',
        title: 'OneMinus'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(OneMinus, _ShaderNode);
        function OneMinus() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = OneMinus.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = 1. - " + input0 + ";\n        ";
        };
        return OneMinus;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/or.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "a2b3fR0/g9EC7haT+6NqTEL", "or", undefined);
      var Or = exports('default', (_dec = register({
        menu: 'Logic/Or',
        title: 'Or'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Or, _ShaderNode);
        function Or() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Max;
          _this.data = {
            inputs: [slot('A', false, 'boolean', 'boolean'), slot('B', false, 'boolean', 'boolean')],
            outputs: [slot('Out', false, 'boolean', 'boolean')]
          };
          return _this;
        }
        var _proto = Or.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var i0 = this.getInputValue(0);
          var i1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = (" + i0 + " || " + i1 + ");\n        ";
        };
        return Or;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PageViewBase.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './PageViewBasePage.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Node, Prefab, instantiate, Component, PageViewBasePage;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Prefab = module.Prefab;
      instantiate = module.instantiate;
      Component = module.Component;
    }, function (module) {
      PageViewBasePage = module.PageViewBasePage;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "fe2875NRMFPRoZfEkgoBxVz", "PageViewBase", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var PageViewBase = exports('PageViewBase', (_dec = ccclass('PageViewBase'), _dec2 = property(Node), _dec3 = property(Prefab), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(PageViewBase, _Component);
        function PageViewBase() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "content", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "prefabPageView", _descriptor2, _assertThisInitialized(_this));
          _this.onSelectedItem = void 0;
          _this.onCreatedItem = void 0;
          _this.itemPerPage = 0;
          _this.firstPage = null;
          _this.pages = [];
          _this.items = [];
          return _this;
        }
        var _proto = PageViewBase.prototype;
        _proto.init = function init(items) {
          if (items.length <= 0) return;
          this.items = items;
          this.createFristPage();
          this.createPages();
          this.setPageData();
        };
        _proto.createPages = function createPages() {
          var needPage = Math.ceil(this.items.length / this.itemPerPage);
          for (var i = this.pages.length; i < needPage; i++) {
            this.createPage();
          }
        };
        _proto.setPageData = function setPageData() {
          var _this2 = this;
          if (this.pages.length <= 0) return;
          var pageIndex = 0;
          var itemIndex = 0;
          var initPage = function initPage(page, data) {
            page.node.active = true;
            page.onSelectItem = _this2.onPageSelectItem.bind(_this2);
            page.onCreatedItem = _this2.onPageCreateItem.bind(_this2);
            page.init(data);
          };
          for (var i = 0; i < this.items.length; i += this.itemPerPage) {
            var breakItems = this.items.slice(i, i + this.itemPerPage);
            initPage(this.pages[pageIndex], breakItems);
            itemIndex = i + breakItems.length;
            pageIndex++;
          }

          //last page
          if (itemIndex < this.items.length - 1) {
            var lastItems = this.items.slice(itemIndex, this.items.length);
            initPage(this.pages[pageIndex], lastItems);
          }

          //disable redundant page
          pageIndex++;
          for (var _i = pageIndex; _i < this.pages.length; _i++) {
            this.pages[_i].node.active = false;
          }
        };
        _proto.createFristPage = function createFristPage() {
          var _this$firstPage;
          if (this.firstPage != null) return;
          this.firstPage = this.createPage();
          this.itemPerPage = (_this$firstPage = this.firstPage) == null ? void 0 : _this$firstPage.getChildNumber();
        };
        _proto.createPage = function createPage() {
          var obj = instantiate(this.prefabPageView);
          obj.parent = this.content;
          var script = obj.getComponent(PageViewBasePage);
          this.pages.push(script);
          return script;
        };
        _proto.onPageCreateItem = function onPageCreateItem(item) {
          var _this$onCreatedItem;
          (_this$onCreatedItem = this.onCreatedItem) == null || _this$onCreatedItem.call(this, item);
        };
        _proto.onPageSelectItem = function onPageSelectItem(item) {
          var _this$onSelectedItem;
          (_this$onSelectedItem = this.onSelectedItem) == null || _this$onSelectedItem.call(this, item);
        };
        return PageViewBase;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "content", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "prefabPageView", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PageViewBaseItem.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, Component;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "63b2flj0OJDBKxMBXVQtrFG", "PageViewBaseItem", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var PageViewBaseItem = exports('PageViewBaseItem', (_dec = ccclass('PageViewBaseItem'), _dec(_class = /*#__PURE__*/function (_Component) {
        _inheritsLoose(PageViewBaseItem, _Component);
        function PageViewBaseItem() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this.onSelected = void 0;
          return _this;
        }
        var _proto = PageViewBaseItem.prototype;
        _proto.init = function init(data, onSelected) {
          this.onSelected = onSelected;
          //depend on data get sprite from tile controller
        };

        _proto.onTouch_Main = function onTouch_Main() {
          var _this$onSelected;
          (_this$onSelected = this.onSelected) == null || _this$onSelected.call(this, this);
          // AudioManager.instance.playSound(GameConstant.SOUND_FILES.CLICK);
        };

        return PageViewBaseItem;
      }(Component)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PageViewBasePage.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './PageViewBaseItem.ts'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, Component, PageViewBaseItem;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
    }, function (module) {
      PageViewBaseItem = module.PageViewBaseItem;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "1049b+/UgpATrtKU8hoqIHQ", "PageViewBasePage", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var PageViewBasePage = exports('PageViewBasePage', (_dec = ccclass('PageViewBasePage'), _dec(_class = /*#__PURE__*/function (_Component) {
        _inheritsLoose(PageViewBasePage, _Component);
        function PageViewBasePage() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this.items = [];
          _this.itemData = [];
          _this.onSelectItem = void 0;
          _this.onCreatedItem = void 0;
          return _this;
        }
        var _proto = PageViewBasePage.prototype;
        _proto.onLoad = function onLoad() {
          this.getChilds();
        };
        _proto.getChildNumber = function getChildNumber() {
          if (this.items.length > 0) this.items.length;
          this.getChilds();
          return this.items.length;
        };
        _proto.getChilds = function getChilds() {
          if (this.items.length > 0) return;
          this.items = this.getComponentsInChildren(PageViewBaseItem);
        };
        _proto.init = function init(vessels) {
          var _this2 = this;
          this.getChilds();
          this.itemData = vessels;
          for (var i = 0; i < this.items.length; i++) {
            var _item = this.items[i];
            var isActive = i < vessels.length;
            _item.node.active = isActive;
            if (isActive) {
              var _this$onCreatedItem;
              var data = vessels[i];
              _item.init(data, function (item) {
                _this2.onSelectItem == null || _this2.onSelectItem(item);
              });
              (_this$onCreatedItem = this.onCreatedItem) == null || _this$onCreatedItem.call(this, _item);
            }
          }
        };
        return PageViewBasePage;
      }(Component)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PageViewManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Manager.ts', './enum.ts', './ScrollManager.ts', './ViewManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Manager, AlwaysScroll, ScrollManager, ViewManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
    }, function (module) {
      Manager = module.Manager;
    }, function (module) {
      AlwaysScroll = module.AlwaysScroll;
    }, function (module) {
      ScrollManager = module.ScrollManager;
    }, function (module) {
      ViewManager = module.ViewManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _class3;
      cclegacy._RF.push({}, "e3a2d9kCydCzZKVh5E8qZ8J", "PageViewManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var Event = /*#__PURE__*/function (Event) {
        Event[Event["ON_PAGE_LENGTH_CHANGED"] = 0] = "ON_PAGE_LENGTH_CHANGED";
        Event[Event["ON_SCROLL_PAGE_BEFOR"] = 1] = "ON_SCROLL_PAGE_BEFOR";
        Event[Event["ON_SCROLL_PAGE_END"] = 2] = "ON_SCROLL_PAGE_END";
        return Event;
      }(Event || {});
      var PageViewManager = exports('PageViewManager', (_dec = ccclass('PageViewManager'), _dec2 = property("boolean"), _dec3 = property({
        range: [0, 1],
        slide: true,
        step: 0.01,
        visible: function visible() {
          return this.enabled;
        },
        tooltip: ""
      }), _dec4 = property({
        range: [0, 1],
        slide: true,
        step: 0.01,
        visible: function visible() {
          return this.enabled;
        },
        tooltip: " PageView PageTurning "
      }), _dec5 = property({
        visible: function visible() {
          return this.enabled;
        },
        tooltip: "\u5FEB\u901F\u6ED1\u52A8\u7FFB\u9875\u4E34\u754C\u503C\n        \u5F53\u7528\u6237\u5FEB\u901F\u6ED1\u52A8\u65F6\uFF0C\u4F1A\u6839\u636E\u6ED1\u52A8\u5F00\u59CB\u548C\u7ED3\u675F\u7684\u8DDD\u79BB\u4E0E\u65F6\u95F4\u8BA1\u7B97\u51FA\u4E00\u4E2A\u901F\u5EA6\u503C\n        \u8BE5\u503C\u4E0E\u6B64\u4E34\u754C\u503C\u76F8\u6BD4\u8F83\uFF0C\u5982\u679C\u5927\u4E8E\u4E34\u754C\u503C\uFF0C\u5219\u8FDB\u884C\u81EA\u52A8\u7FFB\u9875"
      }), _dec6 = property({
        visible: function visible() {
          return this.enabled;
        },
        tooltip: ""
      }), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Manager) {
        _inheritsLoose(PageViewManager, _Manager);
        function PageViewManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Manager.call.apply(_Manager, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "_enabled", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "scrollThreshold", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "pageTurningEventTiming", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "autoPageTurningThreshold", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "pageTurningSpeed", _descriptor5, _assertThisInitialized(_this));
          _this._currentIndex = 0;
          return _this;
        }
        var _proto = PageViewManager.prototype;
        _proto.onInit = function onInit() {
          this._register();
        };
        _proto._register = function _register() {
          if (!this.adapter || !this.enabled) return;
          this.adapter.scrollManager.on(ScrollManager.Event.ON_SCROLL_END, this._handleReleaseLogic, this);
          this.adapter.scrollManager.on(ScrollManager.Event.ON_SCROLL_CANCEL, this._handleReleaseLogic, this);
          this.adapter.scrollManager.on(ScrollManager.Event.ON_SCROLL_TO_GROUPINDEX_BEFOR, this._onScrollToIndex, this);
          this.adapter.viewManager.on(ViewManager.Event.ON_UPDATE_VIEWS, this._onUpdateViews, this, true);
        };
        _proto._unregister = function _unregister() {
          if (!this.adapter || this.enabled) return;
          this.adapter.scrollManager.off(ScrollManager.Event.ON_SCROLL_END, this._handleReleaseLogic, this);
          this.adapter.scrollManager.off(ScrollManager.Event.ON_SCROLL_CANCEL, this._handleReleaseLogic, this);
          this.adapter.scrollManager.off(ScrollManager.Event.ON_SCROLL_TO_GROUPINDEX_BEFOR, this._onScrollToIndex, this);
          this.adapter.viewManager.off(ViewManager.Event.ON_UPDATE_VIEWS, this._onUpdateViews, this);
        };
        _proto.scrollToPage = function scrollToPage(duration, index, alwaysScroll) {
          if (index < 0 || index >= this.length) {
            return;
          }
          if (index == this.currentIndex && this.adapter.scrollManager.calcOffset() != 0) {
            return;
          }
          this.adapter.scrollManager.scrollToGroupIndex(duration, index, alwaysScroll);
          this.emit(Event.ON_SCROLL_PAGE_BEFOR, index);
        }
        /**
         * 
         * @param duration 
         * @param alwaysScrollToHeader 
         */;
        _proto.scrollToPrevPage = function scrollToPrevPage(duration, alwaysScroll) {
          if (duration === void 0) {
            duration = this.pageTurningSpeed;
          }
          if (alwaysScroll === void 0) {
            alwaysScroll = AlwaysScroll.Header;
          }
          if (this._currentIndex == 0) {
            if (this.adapter.viewManager.loopHeader) {
              this.scrollToPage(duration, this.length - 1, alwaysScroll);
            }
            return;
          }
          this.scrollToPage(duration, this._currentIndex - 1, alwaysScroll);
        }
        /**
         * 
         * @param duration 
         * @param alwaysScrollToFooter 
         */;
        _proto.scrollToNextPage = function scrollToNextPage(duration, alwaysScroll) {
          if (duration === void 0) {
            duration = this.pageTurningSpeed;
          }
          if (alwaysScroll === void 0) {
            alwaysScroll = AlwaysScroll.Footer;
          }
          if (this._currentIndex >= this.length - 1) {
            if (this.adapter.viewManager.loopFooter) {
              this.scrollToPage(duration, 0, alwaysScroll);
            }
            return;
          }
          this.scrollToPage(duration, this._currentIndex + 1, alwaysScroll);
        };
        _proto._onUpdateViews = function _onUpdateViews() {
          this.emit(Event.ON_PAGE_LENGTH_CHANGED);
          this._currentIndex = 0;
          this.scrollToPage(this.pageTurningSpeed, this._currentIndex);
        };
        _proto._onScrollToIndex = function _onScrollToIndex(index) {
          this._currentIndex = index;
          this.emit(Event.ON_SCROLL_PAGE_END, index);
        };
        _proto._handleReleaseLogic = function _handleReleaseLogic(event) {
          if (!this._enabled || !this.adapter.scrollManager.isMyEventAndMoved) return;
          var start = event.getUIStartLocation()[this.adapter.mainAxis];
          var end = event.getUILocation()[this.adapter.mainAxis];
          var offset = start - end;
          var nextIndex = this._getNextIndex(offset);
          if (this._isScrollable(offset) || this._isQuicklyScrollable(this.adapter.scrollManager.velocity)) {
            this.scrollToPage(this.pageTurningSpeed, nextIndex);
            return;
          }
          this.scrollToPage(this.pageTurningSpeed, this._currentIndex);
        };
        _proto._getNextIndex = function _getNextIndex(offset) {
          var index = this._currentIndex;
          if (this.adapter.isHorizontal) {
            if (this.adapter.isArrangeAxisStart) {
              if (offset > 0) {
                index++;
              } else if (offset < 0) {
                index--;
              }
            } else {
              if (offset < 0) {
                index++;
              }
              if (offset > 0) {
                index--;
              }
            }
          } else {
            if (this.adapter.isArrangeAxisStart) {
              if (offset < 0) {
                index++;
              } else if (offset > 0) {
                index--;
              }
            } else {
              if (offset > 0) {
                index++;
              } else if (offset < 0) {
                index--;
              }
            }
          }
          if (index >= this.length && this.adapter.viewManager.loopFooter) {
            index = 0;
          } else if (index < 0 && this.adapter.viewManager.loopHeader) {
            index = this.length - 1;
          }
          if (index < 0 || index >= this.length) {
            index = this._currentIndex;
          }
          return index;
        };
        _proto._isScrollable = function _isScrollable(offset) {
          return Math.abs(offset) >= this.adapter.mainAxisSize * this.scrollThreshold;
        };
        _proto._isQuicklyScrollable = function _isQuicklyScrollable(touchMoveVelocity) {
          return Math.abs(touchMoveVelocity) > this.autoPageTurningThreshold;
        };
        _createClass(PageViewManager, [{
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(value) {
            if (value == this._enabled) return;
            this._enabled = value;
            if (this._enabled) {
              this._register();
            } else {
              this._unregister();
            }
          }
        }, {
          key: "currentIndex",
          get: function get() {
            return this._currentIndex;
          }
        }, {
          key: "length",
          get: function get() {
            return this.adapter.viewManager.groupLength;
          }
        }]);
        return PageViewManager;
      }(Manager), _class3.Event = Event, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "_enabled", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "enabled", [_dec2], Object.getOwnPropertyDescriptor(_class2.prototype, "enabled"), _class2.prototype), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "scrollThreshold", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.5;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "pageTurningEventTiming", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "autoPageTurningThreshold", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 100;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "pageTurningSpeed", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.3;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PersistentNode.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, director, Component;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      director = module.director;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "cf006zT+RZGvahsGniqfbWl", "PersistentNode", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var PersistentNode = exports('PersistentNode', (_dec = ccclass('PersistentNode'), _dec(_class = /*#__PURE__*/function (_Component) {
        _inheritsLoose(PersistentNode, _Component);
        function PersistentNode() {
          return _Component.apply(this, arguments) || this;
        }
        var _proto = PersistentNode.prototype;
        _proto.onLoad = function onLoad() {
          director.addPersistRootNode(this.node);
        };
        return PersistentNode;
      }(Component)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PitchCharacterAnimator.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './PitchConstants.ts', './resourceUtil.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Node, Animation, SkeletalAnimation, AnimationClip, Component, PitchConstants, resourceUtil;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Animation = module.Animation;
      SkeletalAnimation = module.SkeletalAnimation;
      AnimationClip = module.AnimationClip;
      Component = module.Component;
    }, function (module) {
      PitchConstants = module.PitchConstants;
    }, function (module) {
      resourceUtil = module.resourceUtil;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;
      cclegacy._RF.push({}, "2e7c57Ev6lF8Ih44/MNJsG1", "PitchCharacterAnimator", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Character Animator for the Pitch Detection Game
       * Controls the 3D character's animations based on detected notes
       */
      var PitchCharacterAnimator = exports('PitchCharacterAnimator', (_dec = ccclass('PitchCharacterAnimator'), _dec2 = property(Node), _dec3 = property(Animation), _dec4 = property(SkeletalAnimation), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(PitchCharacterAnimator, _Component);
        function PitchCharacterAnimator() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Character model
          _initializerDefineProperty(_this, "characterNode", _descriptor, _assertThisInitialized(_this));
          // Animation component
          _initializerDefineProperty(_this, "animationComponent", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "skeletalAnimation", _descriptor3, _assertThisInitialized(_this));
          // Animation properties
          _initializerDefineProperty(_this, "transitionDuration", _descriptor4, _assertThisInitialized(_this));
          // Duration for animation transitions
          // Current state
          _this.currentNote = null;
          _this.isAnimating = false;
          _this.animationClips = new Map();
          _this.idleAnimationClip = null;
          // Animation names
          _this.IDLE_ANIMATION = 'Idle';
          return _this;
        }
        var _proto = PitchCharacterAnimator.prototype;
        _proto.onLoad = function onLoad() {
          // Initialize animation component if not set
          if (!this.animationComponent && this.characterNode) {
            this.animationComponent = this.characterNode.getComponent(Animation);
          }
          if (!this.skeletalAnimation && this.characterNode) {
            this.skeletalAnimation = this.characterNode.getComponent(SkeletalAnimation);
          }
        };
        _proto.start = function start() {
          // Load animation clips
          this.loadAnimationClips();
        }

        /**
         * Load animation clips for each note
         */;
        _proto.loadAnimationClips = function loadAnimationClips() {
          var _this2 = this;
          // Load idle animation
          resourceUtil.loadRes("pitch/animations/" + this.IDLE_ANIMATION, AnimationClip, function (err, clip) {
            if (err) {
              console.error("Failed to load idle animation: " + err);
              return;
            }
            _this2.idleAnimationClip = clip;
            _this2.registerAnimationClip(_this2.IDLE_ANIMATION, clip);
            console.log('Idle animation loaded');

            // Play idle animation initially
            _this2.playIdleAnimation();
          });

          // Load note animations
          var _loop = function _loop() {
            var note = i;
            var animationName = PitchConstants.NOTE_ANIMATIONS[note];
            resourceUtil.loadRes("pitch/animations/" + animationName, AnimationClip, function (err, clip) {
              if (err) {
                console.error("Failed to load animation for note " + PitchConstants.NOTE_NAMES[note] + ": " + err);
                return;
              }
              _this2.animationClips.set(note, clip);
              _this2.registerAnimationClip(animationName, clip);
              console.log("Animation for note " + PitchConstants.NOTE_NAMES[note] + " loaded");
            });
          };
          for (var i = 0; i < 7; i++) {
            _loop();
          }
        }

        /**
         * Register an animation clip with the animation component
         * @param name Animation name
         * @param clip Animation clip
         */;
        _proto.registerAnimationClip = function registerAnimationClip(name, clip) {
          if (!this.animationComponent) return;

          // Check if the animation state already exists
          if (!this.animationComponent.getState(name)) {
            this.animationComponent.createState(clip, name);
          }
        }

        /**
         * Play animation for a specific note
         * @param note Musical note
         * @param accuracy Detection accuracy
         */;
        _proto.playNoteAnimation = function playNoteAnimation(note, accuracy) {
          var _this3 = this;
          if (!this.animationComponent || note === null) return;
          var animationName = PitchConstants.NOTE_ANIMATIONS[note];
          var animationState = this.animationComponent.getState(animationName);
          if (!animationState) {
            console.warn("Animation state not found for note " + PitchConstants.NOTE_NAMES[note]);
            return;
          }

          // Skip if already playing this note animation
          if (this.currentNote === note && this.isAnimating) return;
          this.currentNote = note;
          this.isAnimating = true;

          // Play animation with crossfade
          this.animationComponent.crossFade(animationName, this.transitionDuration);
          console.log("Playing animation for note " + PitchConstants.NOTE_NAMES[note]);

          // Set up callback to return to idle when animation completes
          animationState.once('finished', function () {
            _this3.isAnimating = false;
            _this3.playIdleAnimation();
          });
        }

        /**
         * Play idle animation
         */;
        _proto.playIdleAnimation = function playIdleAnimation() {
          if (!this.animationComponent) return;
          var animationState = this.animationComponent.getState(this.IDLE_ANIMATION);
          if (!animationState) {
            console.warn('Idle animation state not found');
            return;
          }
          this.currentNote = null;
          this.isAnimating = false;

          // Play idle animation with crossfade
          this.animationComponent.crossFade(this.IDLE_ANIMATION, this.transitionDuration);
          console.log('Playing idle animation');
        }

        /**
         * Play a special animation (e.g., for game start/end)
         * @param animationName Animation name
         * @param loop Whether to loop the animation
         * @param callback Callback function when animation completes
         */;
        _proto.playSpecialAnimation = function playSpecialAnimation(animationName, loop, callback) {
          var _this4 = this;
          if (loop === void 0) {
            loop = false;
          }
          if (!this.animationComponent) return;
          resourceUtil.loadRes("pitch/animations/" + animationName, AnimationClip, function (err, clip) {
            if (err) {
              console.error("Failed to load special animation " + animationName + ": " + err);
              return;
            }
            _this4.registerAnimationClip(animationName, clip);
            var animationState = _this4.animationComponent.getState(animationName);
            if (!animationState) {
              console.warn("Special animation state not found: " + animationName);
              return;
            }
            _this4.currentNote = null;
            _this4.isAnimating = true;

            // Set loop property
            animationState.wrapMode = loop ? 2 : 1; // 1 = Normal, 2 = Loop

            // Play animation with crossfade
            _this4.animationComponent.crossFade(animationName, _this4.transitionDuration);
            console.log("Playing special animation: " + animationName);

            // Set up callback when animation completes
            if (!loop && callback) {
              animationState.once('finished', callback);
            }
          });
        }

        /**
         * Stop all animations and return to idle
         */;
        _proto.stopAllAnimations = function stopAllAnimations() {
          if (!this.animationComponent) return;
          this.animationComponent.stop();
          this.playIdleAnimation();
          console.log('All animations stopped');
        }

        /**
         * Check if an animation is currently playing
         * @returns True if an animation is playing
         */;
        _proto.isAnimationPlaying = function isAnimationPlaying() {
          return this.isAnimating;
        }

        /**
         * Get the current note being animated
         * @returns Current note or null if idle
         */;
        _proto.getCurrentNote = function getCurrentNote() {
          return this.currentNote;
        };
        return PitchCharacterAnimator;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "characterNode", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "animationComponent", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "skeletalAnimation", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "transitionDuration", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.3;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PitchConstants.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      var _PitchConstants$NOTE_, _PitchConstants$CENTE, _PitchConstants$FREQU, _PitchConstants$ANIMA, _PitchConstants$NOTE_2;
      cclegacy._RF.push({}, "60fa6arq75JzaMOMyrnUyBF", "PitchConstants", undefined);
      /**
       * Enum for musical notes
       */
      var MusicalNote = exports('MusicalNote', /*#__PURE__*/function (MusicalNote) {
        MusicalNote[MusicalNote["DO"] = 0] = "DO";
        MusicalNote[MusicalNote["RE"] = 1] = "RE";
        MusicalNote[MusicalNote["MI"] = 2] = "MI";
        MusicalNote[MusicalNote["FA"] = 3] = "FA";
        MusicalNote[MusicalNote["SOL"] = 4] = "SOL";
        MusicalNote[MusicalNote["LA"] = 5] = "LA";
        MusicalNote[MusicalNote["SI"] = 6] = "SI";
        return MusicalNote;
      }({}));

      /**
       * Enum for game states
       */
      var GameState = exports('GameState', /*#__PURE__*/function (GameState) {
        GameState[GameState["INIT"] = 0] = "INIT";
        GameState[GameState["CALIBRATING"] = 1] = "CALIBRATING";
        GameState[GameState["PLAYING"] = 2] = "PLAYING";
        GameState[GameState["PAUSED"] = 3] = "PAUSED";
        GameState[GameState["GAME_OVER"] = 4] = "GAME_OVER";
        return GameState;
      }({}));

      /**
       * Enum for pitch detection accuracy
       */
      var PitchAccuracy = exports('PitchAccuracy', /*#__PURE__*/function (PitchAccuracy) {
        PitchAccuracy[PitchAccuracy["MISS"] = 0] = "MISS";
        PitchAccuracy[PitchAccuracy["GOOD"] = 1] = "GOOD";
        PitchAccuracy[PitchAccuracy["PERFECT"] = 2] = "PERFECT";
        return PitchAccuracy;
      }({}));

      /**
       * Enum for feedback types
       */
      var FeedbackType = exports('FeedbackType', /*#__PURE__*/function (FeedbackType) {
        FeedbackType[FeedbackType["PERFECT"] = 0] = "PERFECT";
        FeedbackType[FeedbackType["GOOD"] = 1] = "GOOD";
        FeedbackType[FeedbackType["MISS"] = 2] = "MISS";
        FeedbackType[FeedbackType["TIME_WARNING"] = 3] = "TIME_WARNING";
        return FeedbackType;
      }({}));

      /**
       * Constants for the Pitch Detection Game
       */
      var PitchConstants = exports('PitchConstants', function PitchConstants() {});
      // Game duration in seconds
      PitchConstants.GAME_DURATION = 60;
      // Warning times in seconds
      PitchConstants.WARNING_TIME_1 = 30;
      PitchConstants.WARNING_TIME_2 = 10;
      // Note frequency ranges (Hz)
      PitchConstants.NOTE_FREQUENCIES = (_PitchConstants$NOTE_ = {}, _PitchConstants$NOTE_[MusicalNote.DO] = [261.63 - 10, 261.63 + 10], _PitchConstants$NOTE_[MusicalNote.RE] = [293.66 - 10, 293.66 + 10], _PitchConstants$NOTE_[MusicalNote.MI] = [329.63 - 10, 329.63 + 10], _PitchConstants$NOTE_[MusicalNote.FA] = [349.23 - 10, 349.23 + 10], _PitchConstants$NOTE_[MusicalNote.SOL] = [392.00 - 10, 392.00 + 10], _PitchConstants$NOTE_[MusicalNote.LA] = [440.00 - 10, 440.00 + 10], _PitchConstants$NOTE_[MusicalNote.SI] = [493.88 - 10, 493.88 + 10], _PitchConstants$NOTE_);
      // Note names
      PitchConstants.NOTE_NAMES = ["Do", "Re", "Mi", "Fa", "Sol", "La", "Si"];
      // Center frequencies for notes (Hz)
      PitchConstants.CENTER_FREQUENCIES = (_PitchConstants$CENTE = {}, _PitchConstants$CENTE[MusicalNote.DO] = 261.63, _PitchConstants$CENTE[MusicalNote.RE] = 293.66, _PitchConstants$CENTE[MusicalNote.MI] = 329.63, _PitchConstants$CENTE[MusicalNote.FA] = 349.23, _PitchConstants$CENTE[MusicalNote.SOL] = 392.00, _PitchConstants$CENTE[MusicalNote.LA] = 440.00, _PitchConstants$CENTE[MusicalNote.SI] = 493.88, _PitchConstants$CENTE);
      // Note frequency ranges (Hz) - Alias for compatibility
      // Updated ranges based on midpoints for C4-B4 octave
      PitchConstants.FREQUENCY_RANGES = (_PitchConstants$FREQU = {}, _PitchConstants$FREQU[MusicalNote.DO] = [254.12, 277.65], _PitchConstants$FREQU[MusicalNote.RE] = [277.65, 311.65], _PitchConstants$FREQU[MusicalNote.MI] = [311.65, 339.43], _PitchConstants$FREQU[MusicalNote.FA] = [339.43, 370.62], _PitchConstants$FREQU[MusicalNote.SOL] = [370.62, 416.00], _PitchConstants$FREQU[MusicalNote.LA] = [416.00, 466.94], _PitchConstants$FREQU[MusicalNote.SI] = [466.94, 508.56], _PitchConstants$FREQU);
      // Animation names
      PitchConstants.ANIMATIONS = (_PitchConstants$ANIMA = {}, _PitchConstants$ANIMA[MusicalNote.DO] = "do_animation", _PitchConstants$ANIMA[MusicalNote.RE] = "re_animation", _PitchConstants$ANIMA[MusicalNote.MI] = "mi_animation", _PitchConstants$ANIMA[MusicalNote.FA] = "fa_animation", _PitchConstants$ANIMA[MusicalNote.SOL] = "sol_animation", _PitchConstants$ANIMA[MusicalNote.LA] = "la_animation", _PitchConstants$ANIMA[MusicalNote.SI] = "si_animation", _PitchConstants$ANIMA);
      // Animation names - Alias for compatibility
      PitchConstants.NOTE_ANIMATIONS = (_PitchConstants$NOTE_2 = {}, _PitchConstants$NOTE_2[MusicalNote.DO] = "do_animation", _PitchConstants$NOTE_2[MusicalNote.RE] = "re_animation", _PitchConstants$NOTE_2[MusicalNote.MI] = "mi_animation", _PitchConstants$NOTE_2[MusicalNote.FA] = "fa_animation", _PitchConstants$NOTE_2[MusicalNote.SOL] = "sol_animation", _PitchConstants$NOTE_2[MusicalNote.LA] = "la_animation", _PitchConstants$NOTE_2[MusicalNote.SI] = "si_animation", _PitchConstants$NOTE_2);
      // Event names
      PitchConstants.EVENTS = {
        PITCH_DETECTED: "pitch_detected",
        TIME_WARNING: "time_warning",
        GAME_OVER: "game_over",
        NOTE_MATCHED: "note_matched",
        SEQUENCE_COMPLETE: "sequence_complete"
      };
      // Accuracy thresholds
      PitchConstants.ACCURACY_THRESHOLDS = {
        PERFECT: 3,
        // Hz difference for perfect match
        GOOD: 7 // Hz difference for good match
      };

      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PitchDetectionSystem.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './PitchConstants.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, _asyncToGenerator, _regeneratorRuntime, cclegacy, _decorator, EventTarget, Component, PitchAccuracy, PitchConstants;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
      _asyncToGenerator = module.asyncToGenerator;
      _regeneratorRuntime = module.regeneratorRuntime;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      EventTarget = module.EventTarget;
      Component = module.Component;
    }, function (module) {
      PitchAccuracy = module.PitchAccuracy;
      PitchConstants = module.PitchConstants;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor, _class3;
      cclegacy._RF.push({}, "f8ec1Ju28VBfoeISSQmPsrE", "PitchDetectionSystem", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Pitch detection result interface
       */

      /**
       * Pitch Detection System for the Pitch Detection Game
       * Handles microphone input and real-time pitch detection
       */
      var PitchDetectionSystem = exports('PitchDetectionSystem', (_dec = ccclass('PitchDetectionSystem'), _dec2 = property({
        range: [0, 1],
        slide: true,
        tooltip: "Minimum volume level to detect pitch"
      }), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(PitchDetectionSystem, _Component);
        function PitchDetectionSystem() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Audio context and analyzer
          _this.audioContext = null;
          _this.analyzer = null;
          _this.microphone = null;
          _this.microphoneStream = null;
          _this.aubioPitch = null;
          // Buffer for audio analysis
          _this.analyzerBuffer = null;
          _this.aubioInputBuffer = null;
          _this.bufferSize = 2048;
          // Detection state
          _this.isDetecting = false;
          _this.detectionInterval = null;
          _this.detectionIntervalMs = 50;
          // Detection interval in milliseconds
          // Smoothing for pitch detection
          _this.smoothingFactor = 0.8;
          _this.lastFrequency = 0;
          _this.lastNote = null;
          _this.noteStabilityCounter = new Map();
          _this.noteStabilityThreshold = 3;
          // Number of consecutive detections to confirm a note
          // Volume threshold for detection
          _initializerDefineProperty(_this, "volumeThreshold", _descriptor, _assertThisInitialized(_this));
          // Calibration
          _this.isCalibrating = false;
          _this.calibrationCallback = null;
          return _this;
        }
        var _proto = PitchDetectionSystem.prototype;
        _proto.onLoad = function onLoad() {
          // Set up singleton instance
          if (PitchDetectionSystem._instance !== null) {
            this.node.destroy();
            return;
          }
          PitchDetectionSystem._instance = this;

          // Initialize note stability counter
          for (var i = 0; i < 7; i++) {
            this.noteStabilityCounter.set(i, 0);
          }
        }

        /**
         * Initialize the pitch detection system
         * @returns Promise that resolves when initialization is complete
         */;
        _proto.initialize = /*#__PURE__*/
        function () {
          var _initialize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            var AudioContextClass;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _context.next = 3;
                  return aubio.ready;
                case 3:
                  if (!(!window.AudioContext && !window['webkitAudioContext'])) {
                    _context.next = 6;
                    break;
                  }
                  console.error('AudioContext is not supported in this browser');
                  return _context.abrupt("return", false);
                case 6:
                  // Create audio context
                  AudioContextClass = window.AudioContext || window['webkitAudioContext'];
                  this.audioContext = new AudioContextClass();

                  // Create analyzer
                  this.analyzer = this.audioContext.createAnalyser();
                  this.analyzer.fftSize = this.bufferSize;
                  this.analyzer.smoothingTimeConstant = 0.8;

                  // Create buffers
                  this.analyzerBuffer = new Float32Array(this.analyzer.frequencyBinCount);
                  this.aubioInputBuffer = new Float32Array(this.bufferSize);

                  // Initialize aubio pitch detector
                  this.aubioPitch = new aubio.Pitch("default", this.bufferSize, this.bufferSize / 8, this.audioContext.sampleRate);
                  console.log('Pitch detection system initialized with aubio');
                  return _context.abrupt("return", true);
                case 18:
                  _context.prev = 18;
                  _context.t0 = _context["catch"](0);
                  console.error('Failed to initialize pitch detection system:', _context.t0);
                  return _context.abrupt("return", false);
                case 22:
                case "end":
                  return _context.stop();
              }
            }, _callee, this, [[0, 18]]);
          }));
          function initialize() {
            return _initialize.apply(this, arguments);
          }
          return initialize;
        }()
        /**
         * Request microphone access
         * @returns Promise that resolves when microphone access is granted
         */;

        _proto.requestMicrophoneAccess = /*#__PURE__*/
        function () {
          var _requestMicrophoneAccess = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.prev = 0;
                  if (!(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)) {
                    _context2.next = 4;
                    break;
                  }
                  console.error('getUserMedia is not supported in this browser');
                  return _context2.abrupt("return", false);
                case 4:
                  _context2.next = 6;
                  return navigator.mediaDevices.getUserMedia({
                    audio: {
                      echoCancellation: true,
                      noiseSuppression: true,
                      autoGainControl: false
                    }
                  });
                case 6:
                  this.microphoneStream = _context2.sent;
                  // Create microphone source
                  this.microphone = this.audioContext.createMediaStreamSource(this.microphoneStream);

                  // Connect microphone to analyzer
                  this.microphone.connect(this.analyzer);
                  console.log('Microphone access granted');
                  return _context2.abrupt("return", true);
                case 13:
                  _context2.prev = 13;
                  _context2.t0 = _context2["catch"](0);
                  console.error('Failed to access microphone:', _context2.t0);
                  return _context2.abrupt("return", false);
                case 17:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this, [[0, 13]]);
          }));
          function requestMicrophoneAccess() {
            return _requestMicrophoneAccess.apply(this, arguments);
          }
          return requestMicrophoneAccess;
        }()
        /**
         * Start pitch detection
         */;

        _proto.startDetection = function startDetection() {
          var _this2 = this;
          if (this.isDetecting) return;

          // Resume audio context if it's suspended
          if (this.audioContext && this.audioContext.state === 'suspended') {
            this.audioContext.resume();
          }
          this.isDetecting = true;

          // Start detection loop
          this.detectionInterval = setInterval(function () {
            _this2.detectPitch();
          }, this.detectionIntervalMs);
          console.log('Pitch detection started');
        }

        /**
         * Stop pitch detection
         */;
        _proto.stopDetection = function stopDetection() {
          if (!this.isDetecting) return;
          this.isDetecting = false;

          // Stop detection loop
          if (this.detectionInterval !== null) {
            clearInterval(this.detectionInterval);
            this.detectionInterval = null;
          }
          console.log('Pitch detection stopped');
        }

        /**
         * Detect pitch from microphone input using aubio.js
         */;
        _proto.detectPitch = function detectPitch() {
          if (!this.analyzer || !this.isDetecting || !this.aubioPitch) return;

          // Get frequency data
          this.analyzer.getFloatTimeDomainData(this.aubioInputBuffer);

          // Calculate volume
          var sum = 0;
          for (var i = 0; i < this.aubioInputBuffer.length; i++) {
            sum += this.aubioInputBuffer[i] * this.aubioInputBuffer[i];
          }
          var volume = Math.sqrt(sum / this.aubioInputBuffer.length);

          // Skip detection if volume is too low
          if (volume < this.volumeThreshold) {
            this.resetNoteStability();
            this.emitPitchDetected(0, null, PitchAccuracy.MISS, volume);
            return;
          }

          // Detect pitch using aubio
          var frequency = this.aubioPitch["do"](this.aubioInputBuffer);

          // Apply smoothing
          var smoothedFrequency = this.smoothingFactor * this.lastFrequency + (1 - this.smoothingFactor) * frequency;
          this.lastFrequency = smoothedFrequency;

          // Map frequency to note
          var _this$mapFrequencyToN = this.mapFrequencyToNote(smoothedFrequency),
            note = _this$mapFrequencyToN.note,
            accuracy = _this$mapFrequencyToN.accuracy;

          // Update note stability
          if (note !== null) {
            this.updateNoteStability(note);

            // Emit event if note is stable
            if (this.noteStabilityCounter.get(note) >= this.noteStabilityThreshold) {
              this.emitPitchDetected(smoothedFrequency, note, accuracy, volume);
            }
          } else {
            this.resetNoteStability();
            this.emitPitchDetected(smoothedFrequency, null, PitchAccuracy.MISS, volume);
          }
        }

        /**
         * Map frequency to musical note
         * @param frequency Frequency in Hz
         * @returns Musical note and accuracy
         */;
        _proto.mapFrequencyToNote = function mapFrequencyToNote(frequency) {
          if (frequency <= 0) {
            return {
              note: null,
              accuracy: PitchAccuracy.MISS
            };
          }

          // Check each note's frequency range
          for (var noteValue = 0; noteValue < 7; noteValue++) {
            var note = noteValue;
            var _PitchConstants$FREQU = PitchConstants.FREQUENCY_RANGES[note],
              minFreq = _PitchConstants$FREQU[0],
              maxFreq = _PitchConstants$FREQU[1];
            if (frequency >= minFreq && frequency <= maxFreq) {
              // Calculate how close to the center of the range
              var centerFreq = (minFreq + maxFreq) / 2;
              var distance = Math.abs(frequency - centerFreq);
              var rangeWidth = (maxFreq - minFreq) / 2;
              var normalizedDistance = distance / rangeWidth;

              // Determine accuracy based on distance from center
              var accuracy = void 0;
              if (normalizedDistance < 0.3) {
                accuracy = PitchAccuracy.PERFECT;
              } else if (normalizedDistance < 0.7) {
                accuracy = PitchAccuracy.GOOD;
              } else {
                accuracy = PitchAccuracy.MISS;
              }
              return {
                note: note,
                accuracy: accuracy
              };
            }
          }
          return {
            note: null,
            accuracy: PitchAccuracy.MISS
          };
        }

        /**
         * Update note stability counter
         * @param note Detected note
         */;
        _proto.updateNoteStability = function updateNoteStability(note) {
          // Reset counters for other notes
          for (var i = 0; i < 7; i++) {
            if (i !== note) {
              this.noteStabilityCounter.set(i, 0);
            }
          }

          // Increment counter for detected note
          var currentCount = this.noteStabilityCounter.get(note) || 0;
          this.noteStabilityCounter.set(note, currentCount + 1);
        }

        /**
         * Reset all note stability counters
         */;
        _proto.resetNoteStability = function resetNoteStability() {
          for (var i = 0; i < 7; i++) {
            this.noteStabilityCounter.set(i, 0);
          }
        }

        /**
         * Emit pitch detected event
         * @param frequency Detected frequency
         * @param note Detected note
         * @param accuracy Detection accuracy
         * @param volume Audio volume
         */;
        _proto.emitPitchDetected = function emitPitchDetected(frequency, note, accuracy, volume) {
          var result = {
            frequency: frequency,
            note: note,
            accuracy: accuracy,
            volume: volume
          };
          PitchDetectionSystem.emit(PitchConstants.EVENTS.PITCH_DETECTED, result);
        }

        /**
         * Start calibration process
         * @param callback Callback function called when calibration is complete
         */;
        _proto.startCalibration = function startCalibration(callback) {
          var _this3 = this;
          if (this.isCalibrating) return;
          this.isCalibrating = true;
          this.calibrationCallback = callback;

          // TODO: Implement calibration logic
          // For now, just simulate a successful calibration
          setTimeout(function () {
            _this3.isCalibrating = false;
            if (_this3.calibrationCallback) {
              _this3.calibrationCallback(true);
              _this3.calibrationCallback = null;
            }
          }, 2000);
          console.log('Calibration started');
        }

        /**
         * Get the current volume level
         * @returns Volume level (0-1)
         */;
        _proto.getVolumeLevel = function getVolumeLevel() {
          if (!this.analyzer) return 0;
          this.analyzer.getFloatTimeDomainData(this.analyzerBuffer);
          var sum = 0;
          for (var i = 0; i < this.analyzerBuffer.length; i++) {
            sum += this.analyzerBuffer[i] * this.analyzerBuffer[i];
          }
          return Math.sqrt(sum / this.analyzerBuffer.length);
        }

        /**
         * Clean up aubio resources
         */;
        _proto.cleanupAubio = function cleanupAubio() {
          if (this.aubioPitch) {
            this.aubioPitch["delete"]();
            this.aubioPitch = null;
          }
        };
        _proto.onDestroy = function onDestroy() {
          // Clean up resources
          this.stopDetection();
          this.cleanupAubio();
          if (this.microphoneStream) {
            this.microphoneStream.getTracks().forEach(function (track) {
              return track.stop();
            });
            this.microphoneStream = null;
          }
          if (this.audioContext) {
            this.audioContext.close();
            this.audioContext = null;
          }
        }

        /**
         * Add a listener for pitch detection events
         * @param eventName Event name
         * @param callback Callback function
         * @param target Target object
         */;
        PitchDetectionSystem.on = function on(eventName, callback, target) {
          this.eventTarget.on(eventName, callback, target);
        }

        /**
         * Remove a listener for pitch detection events
         * @param eventName Event name
         * @param callback Callback function
         * @param target Target object
         */;
        PitchDetectionSystem.off = function off(eventName, callback, target) {
          this.eventTarget.off(eventName, callback, target);
        }

        /**
         * Emit a pitch detection event
         * @param eventName Event name
         * @param arg1 First argument
         * @param arg2 Second argument
         * @param arg3 Third argument
         * @param arg4 Fourth argument
         * @param arg5 Fifth argument
         */;
        PitchDetectionSystem.emit = function emit(eventName, arg1, arg2, arg3, arg4, arg5) {
          this.eventTarget.emit(eventName, arg1, arg2, arg3, arg4, arg5);
        };
        _createClass(PitchDetectionSystem, null, [{
          key: "instance",
          get:
          /**
           * Get the singleton instance
           */
          function get() {
            return this._instance;
          }
        }]);
        return PitchDetectionSystem;
      }(Component), _class3._instance = null, _class3.eventTarget = new EventTarget(), _class3), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "volumeThreshold", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.05;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PitchGameplayController.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './PitchConstants.ts', './PitchDetectionSystem.ts', './PitchCharacterAnimator.ts', './PitchTimer.ts', './PitchUIManager.ts', './PitchNoteSequence.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Component, GameState, PitchConstants, FeedbackType, PitchAccuracy, PitchDetectionSystem, PitchCharacterAnimator, PitchTimer, PitchUIManager, PitchSequenceLibrary;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
    }, function (module) {
      GameState = module.GameState;
      PitchConstants = module.PitchConstants;
      FeedbackType = module.FeedbackType;
      PitchAccuracy = module.PitchAccuracy;
    }, function (module) {
      PitchDetectionSystem = module.PitchDetectionSystem;
    }, function (module) {
      PitchCharacterAnimator = module.PitchCharacterAnimator;
    }, function (module) {
      PitchTimer = module.PitchTimer;
    }, function (module) {
      PitchUIManager = module.PitchUIManager;
    }, function (module) {
      PitchSequenceLibrary = module.PitchSequenceLibrary;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3, _class3;
      cclegacy._RF.push({}, "ed6fbHqK/JJv6q+lwtbCqxi", "PitchGameplayController", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Pitch detection result interface
       */

      /**
       * Main controller for the Pitch Detection Game
       * Manages game flow, integrates all components, and handles user input
       */
      var PitchGameplayController = exports('PitchGameplayController', (_dec = ccclass('PitchGameplayController'), _dec2 = property(PitchDetectionSystem), _dec3 = property(PitchCharacterAnimator), _dec4 = property(PitchTimer), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(PitchGameplayController, _Component);
        function PitchGameplayController() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Core components
          _initializerDefineProperty(_this, "detectionSystem", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "characterAnimator", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "timer", _descriptor3, _assertThisInitialized(_this));
          // Game state
          _this.gameState = GameState.INIT;
          _this.currentSequence = null;
          _this.totalNotesMatched = 0;
          _this.totalAccuracy = 0;
          _this.noteMatchThreshold = 3;
          // Number of consecutive frames to match a note
          _this.noteMatchCounter = 0;
          return _this;
        }
        var _proto = PitchGameplayController.prototype;
        _proto.onLoad = function onLoad() {
          // Set up singleton instance
          if (PitchGameplayController._instance !== null) {
            this.node.destroy();
            return;
          }
          PitchGameplayController._instance = this;

          // Initialize PitchSequenceLibrary
          PitchSequenceLibrary.initialize();
        };
        _proto.start = function start() {
          // Set up event listeners
          this.setupEventListeners();

          // Show main menu initially
          // PitchUIManager.instance.showMainMenu();
          this.startGame('sequence_1');
        }

        /**
         * Set up event listeners for game events
         */;
        _proto.setupEventListeners = function setupEventListeners() {
          // Listen for pitch detection events
          PitchDetectionSystem.on(PitchConstants.EVENTS.PITCH_DETECTED, this.onPitchDetected, this);

          // Listen for timer events
          PitchTimer.on(PitchConstants.EVENTS.TIME_WARNING, this.onTimeWarning, this);
          PitchTimer.on(PitchConstants.EVENTS.GAME_OVER, this.onTimeUp, this);
        }

        /**
         * Start a new game with the specified sequence
         * @param sequenceId Sequence ID to play
         */;
        _proto.startGame = function startGame(sequenceId) {
          var _this2 = this;
          // Get the sequence
          var sequence = PitchSequenceLibrary.getSequenceById(sequenceId);
          if (!sequence) {
            console.error("Sequence with ID " + sequenceId + " not found");
            return;
          }
          this.currentSequence = sequence;
          this.gameState = GameState.PLAYING;
          this.totalNotesMatched = 0;
          this.totalAccuracy = 0;
          this.noteMatchCounter = 0;

          // Initialize UI
          PitchUIManager.instance.showGameplay(sequence);

          // Initialize detection system
          this.detectionSystem.initialize().then(function () {
            return _this2.detectionSystem.requestMicrophoneAccess();
          }).then(function (success) {
            if (success) {
              // Start detection
              _this2.detectionSystem.startDetection();

              // Start timer
              _this2.timer.startTimer();
              console.log('Game started');
            } else {
              console.error('Failed to access microphone');
              // TODO: Show error message to user
            }
          })["catch"](function (error) {
            console.error('Error starting game:', error);
            // TODO: Show error message to user
          });
        }

        /**
         * Pause the game
         */;
        _proto.pauseGame = function pauseGame() {
          if (this.gameState !== GameState.PLAYING) return;
          this.gameState = GameState.PAUSED;

          // Pause timer
          this.timer.pauseTimer();

          // Pause detection
          this.detectionSystem.stopDetection();
          console.log('Game paused');
        }

        /**
         * Resume the game
         */;
        _proto.resumeGame = function resumeGame() {
          if (this.gameState !== GameState.PAUSED) return;
          this.gameState = GameState.PLAYING;

          // Resume timer
          this.timer.resumeTimer();

          // Resume detection
          this.detectionSystem.startDetection();
          console.log('Game resumed');
        }

        /**
         * End the game
         * @param success Whether the player completed the sequence successfully
         */;
        _proto.endGame = function endGame(success) {
          this.gameState = GameState.GAME_OVER;

          // Stop timer
          this.timer.stopTimer();

          // Stop detection
          this.detectionSystem.stopDetection();

          // Calculate accuracy
          var accuracy = this.totalNotesMatched > 0 ? this.totalAccuracy / this.totalNotesMatched * 100 : 0;

          // Show results
          PitchUIManager.instance.showResults(success, this.timer.getRemainingTime(), accuracy);
          console.log("Game ended. Success: " + success + ", Accuracy: " + accuracy.toFixed(2) + "%");
        }

        /**
         * Start calibration process
         */;
        _proto.startCalibration = function startCalibration() {
          var _this3 = this;
          this.gameState = GameState.CALIBRATING;

          // Show calibration UI
          PitchUIManager.instance.showCalibration();

          // Initialize detection system
          this.detectionSystem.initialize().then(function () {
            return _this3.detectionSystem.requestMicrophoneAccess();
          }).then(function (success) {
            if (success) {
              // Start calibration
              _this3.detectionSystem.startCalibration(function (success) {
                if (success) {
                  console.log('Calibration completed successfully');
                  // Return to main menu
                  PitchUIManager.instance.showMainMenu();
                  _this3.gameState = GameState.INIT;
                } else {
                  console.error('Calibration failed');
                  // TODO: Show error message to user
                }
              });
            } else {
              console.error('Failed to access microphone');
              // TODO: Show error message to user
            }
          })["catch"](function (error) {
            console.error('Error starting calibration:', error);
            // TODO: Show error message to user
          });
        }

        /**
         * Handle pitch detection event
         * @param result Pitch detection result
         */;
        _proto.onPitchDetected = function onPitchDetected(result) {
          if (this.gameState !== GameState.PLAYING) return;

          // Update UI with current note
          PitchUIManager.instance.updateCurrentNoteLabel(result.note);

          // Move butterfly to indicate current pitch
          PitchUIManager.instance.moveButterfly(result.note, result.volume);

          // Check if the detected note matches the target note
          var targetNote = PitchUIManager.instance.getCurrentTargetNote();
          if (targetNote !== null && result.note === targetNote) {
            // Increment match counter
            this.noteMatchCounter++;

            // Check if we've matched the note for enough consecutive frames
            if (this.noteMatchCounter >= this.noteMatchThreshold) {
              this.onNoteMatched(result.note, result.accuracy);
              this.noteMatchCounter = 0;
            }
          } else {
            // Reset match counter
            this.noteMatchCounter = 0;
          }
        }

        /**
         * Handle note matched event
         * @param note Matched note
         * @param accuracy Detection accuracy
         */;
        _proto.onNoteMatched = function onNoteMatched(note, accuracy) {
          // Play character animation
          this.characterAnimator.playNoteAnimation(note, accuracy);

          // Show feedback
          var feedbackType;
          switch (accuracy) {
            case PitchAccuracy.PERFECT:
              feedbackType = FeedbackType.PERFECT;
              break;
            case PitchAccuracy.GOOD:
              feedbackType = FeedbackType.GOOD;
              break;
            default:
              feedbackType = FeedbackType.MISS;
          }
          PitchUIManager.instance.showFeedback(feedbackType);

          // Update accuracy tracking
          this.totalNotesMatched++;
          this.totalAccuracy += accuracy === PitchAccuracy.PERFECT ? 1.0 : accuracy === PitchAccuracy.GOOD ? 0.7 : 0.3;

          // Advance progress
          PitchUIManager.instance.advanceProgressLine();

          // Check if there are more notes
          var hasMoreNotes = PitchUIManager.instance.advanceToNextNote();
          if (!hasMoreNotes) {
            // Sequence complete
            this.endGame(true);
          }
        }

        /**
         * Handle time warning event
         * @param remainingTime Remaining time in seconds
         */;
        _proto.onTimeWarning = function onTimeWarning(remainingTime) {
          if (this.gameState !== GameState.PLAYING) return;

          // Show time warning
          PitchUIManager.instance.showTimeWarning(remainingTime);
        }

        /**
         * Handle time up event
         */;
        _proto.onTimeUp = function onTimeUp() {
          if (this.gameState !== GameState.PLAYING) return;

          // End game with failure
          this.endGame(false);
        }

        /**
         * Update method called every frame
         * @param dt Delta time
         */;
        _proto.update = function update(dt) {
          if (this.gameState !== GameState.PLAYING) return;

          // Update timer display
          PitchUIManager.instance.updateTimer(this.timer.getRemainingTime());
        }

        /**
         * Return to the main menu
         */;
        _proto.returnToMainMenu = function returnToMainMenu() {
          // Stop any ongoing game
          if (this.gameState === GameState.PLAYING || this.gameState === GameState.PAUSED) {
            this.timer.stopTimer();
            this.detectionSystem.stopDetection();
          }

          // Reset game state
          this.gameState = GameState.INIT;

          // Show main menu
          PitchUIManager.instance.showMainMenu();
        }

        /**
         * Restart the current game
         */;
        _proto.restartGame = function restartGame() {
          if (!this.currentSequence) return;

          // Stop current game
          if (this.gameState === GameState.PLAYING || this.gameState === GameState.PAUSED) {
            this.timer.stopTimer();
            this.detectionSystem.stopDetection();
          }

          // Start a new game with the same sequence
          this.startGame(this.currentSequence.id);
        };
        _proto.onDestroy = function onDestroy() {
          // Clean up event listeners
          PitchDetectionSystem.off(PitchConstants.EVENTS.PITCH_DETECTED, this.onPitchDetected, this);
          PitchTimer.off(PitchConstants.EVENTS.TIME_WARNING, this.onTimeWarning, this);
          PitchTimer.off(PitchConstants.EVENTS.GAME_OVER, this.onTimeUp, this);

          // Stop detection and timer
          this.detectionSystem.stopDetection();
          this.timer.stopTimer();
        };
        _createClass(PitchGameplayController, null, [{
          key: "instance",
          get:
          /**
           * Get the singleton instance
           */
          function get() {
            return this._instance;
          }
        }]);
        return PitchGameplayController;
      }(Component), _class3._instance = null, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "detectionSystem", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "characterAnimator", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "timer", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PitchNoteSequence.ts", ['cc', './PitchConstants.ts'], function (exports) {
  var cclegacy, MusicalNote;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      MusicalNote = module.MusicalNote;
    }],
    execute: function () {
      cclegacy._RF.push({}, "dfe631CLPRPBowoQTyI/2P8", "PitchNoteSequence", undefined);

      /**
       * Interface for a note in a sequence
       */

      /**
       * Class representing a sequence of notes for the Pitch Detection Game
       */
      var PitchNoteSequence = exports('PitchNoteSequence', /*#__PURE__*/function () {
        function PitchNoteSequence(id, name, difficulty, notes) {
          this.id = void 0;
          this.name = void 0;
          this.difficulty = void 0;
          // 1-5, where 5 is hardest
          this.notes = void 0;
          this.id = id;
          this.name = name;
          this.difficulty = difficulty;
          this.notes = notes;
        }

        /**
         * Get the total duration of the sequence
         * @returns Total duration in seconds
         */
        var _proto = PitchNoteSequence.prototype;
        _proto.getTotalDuration = function getTotalDuration() {
          return this.notes.reduce(function (total, note) {
            return total + note.duration;
          }, 0);
        }

        /**
         * Get the number of notes in the sequence
         * @returns Number of notes
         */;
        _proto.getNoteCount = function getNoteCount() {
          return this.notes.length;
        };
        return PitchNoteSequence;
      }());

      /**
       * Library of predefined note sequences
       */
      var PitchSequenceLibrary = exports('PitchSequenceLibrary', /*#__PURE__*/function () {
        function PitchSequenceLibrary() {}
        /**
         * Initialize the sequence library with predefined sequences
         */
        PitchSequenceLibrary.initialize = function initialize() {
          // Add predefined sequences
          this.addSequence(new PitchNoteSequence('sequence_1', 'Basic Scale', 1, [{
            note: MusicalNote.DO,
            duration: 2
          }, {
            note: MusicalNote.RE,
            duration: 2
          }, {
            note: MusicalNote.MI,
            duration: 2
          }, {
            note: MusicalNote.FA,
            duration: 2
          }, {
            note: MusicalNote.SOL,
            duration: 2
          }, {
            note: MusicalNote.LA,
            duration: 2
          }, {
            note: MusicalNote.SI,
            duration: 2
          }]));
          this.addSequence(new PitchNoteSequence('sequence_2', 'Simple Melody', 2, [{
            note: MusicalNote.DO,
            duration: 1
          }, {
            note: MusicalNote.MI,
            duration: 1
          }, {
            note: MusicalNote.SOL,
            duration: 1
          }, {
            note: MusicalNote.MI,
            duration: 1
          }, {
            note: MusicalNote.DO,
            duration: 2
          }]));
          this.addSequence(new PitchNoteSequence('sequence_3', 'Advanced Pattern', 3, [{
            note: MusicalNote.DO,
            duration: 1
          }, {
            note: MusicalNote.MI,
            duration: 1
          }, {
            note: MusicalNote.SOL,
            duration: 1
          }, {
            note: MusicalNote.SI,
            duration: 1
          }, {
            note: MusicalNote.LA,
            duration: 1
          }, {
            note: MusicalNote.FA,
            duration: 1
          }, {
            note: MusicalNote.RE,
            duration: 1
          }, {
            note: MusicalNote.DO,
            duration: 2
          }]));
          this.addSequence(new PitchNoteSequence('sequence_4', 'Expert Challenge', 5, [{
            note: MusicalNote.DO,
            duration: 0.5
          }, {
            note: MusicalNote.RE,
            duration: 0.5
          }, {
            note: MusicalNote.MI,
            duration: 0.5
          }, {
            note: MusicalNote.FA,
            duration: 0.5
          }, {
            note: MusicalNote.SOL,
            duration: 0.5
          }, {
            note: MusicalNote.LA,
            duration: 0.5
          }, {
            note: MusicalNote.SI,
            duration: 0.5
          }, {
            note: MusicalNote.LA,
            duration: 0.5
          }, {
            note: MusicalNote.SOL,
            duration: 0.5
          }, {
            note: MusicalNote.FA,
            duration: 0.5
          }, {
            note: MusicalNote.MI,
            duration: 0.5
          }, {
            note: MusicalNote.RE,
            duration: 0.5
          }, {
            note: MusicalNote.DO,
            duration: 1
          }]));
        }

        /**
         * Add a sequence to the library
         * @param sequence Sequence to add
         */;
        PitchSequenceLibrary.addSequence = function addSequence(sequence) {
          this.sequences.set(sequence.id, sequence);
        }

        /**
         * Get a sequence by ID
         * @param id Sequence ID
         * @returns Sequence or null if not found
         */;
        PitchSequenceLibrary.getSequenceById = function getSequenceById(id) {
          return this.sequences.get(id) || null;
        }

        /**
         * Get all sequences
         * @returns Array of all sequences
         */;
        PitchSequenceLibrary.getAllSequences = function getAllSequences() {
          return Array.from(this.sequences.values());
        }

        /**
         * Get sequences by difficulty
         * @param difficulty Difficulty level (1-5)
         * @returns Array of sequences with the specified difficulty
         */;
        PitchSequenceLibrary.getSequencesByDifficulty = function getSequencesByDifficulty(difficulty) {
          return Array.from(this.sequences.values()).filter(function (sequence) {
            return sequence.difficulty === difficulty;
          });
        };
        return PitchSequenceLibrary;
      }());
      PitchSequenceLibrary.sequences = new Map();
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PitchTimer.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './PitchConstants.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, EventTarget, Component, PitchConstants;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      EventTarget = module.EventTarget;
      Component = module.Component;
    }, function (module) {
      PitchConstants = module.PitchConstants;
    }],
    execute: function () {
      var _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _class3;
      cclegacy._RF.push({}, "34dfdy0Mg9MWooFmqWcRhjg", "PitchTimer", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Timer for the Pitch Detection Game
       * Manages the 60-second countdown timer
       */
      var PitchTimer = exports('PitchTimer', (_dec = ccclass('PitchTimer'), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(PitchTimer, _Component);
        function PitchTimer() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Timer properties
          _initializerDefineProperty(_this, "duration", _descriptor, _assertThisInitialized(_this));
          // Default duration in seconds
          _initializerDefineProperty(_this, "warningTime1", _descriptor2, _assertThisInitialized(_this));
          // First warning time in seconds
          _initializerDefineProperty(_this, "warningTime2", _descriptor3, _assertThisInitialized(_this));
          // Second warning time in seconds
          // Timer state
          _this.isRunning = false;
          _this.isPaused = false;
          _this.startTime = 0;
          _this.pauseTime = 0;
          _this.pausedDuration = 0;
          _this.remainingTime = 0;
          _this.warningEmitted1 = false;
          _this.warningEmitted2 = false;
          return _this;
        }
        var _proto = PitchTimer.prototype;
        _proto.onLoad = function onLoad() {
          // Set up singleton instance
          if (PitchTimer._instance !== null) {
            this.node.destroy();
            return;
          }
          PitchTimer._instance = this;
        }

        /**
         * Start the timer
         * @param duration Optional custom duration in seconds
         */;
        _proto.startTimer = function startTimer(duration) {
          if (this.isRunning) return;

          // Set duration if provided
          if (duration !== undefined) {
            this.duration = duration;
          }
          this.isRunning = true;
          this.isPaused = false;
          this.startTime = Date.now();
          this.pausedDuration = 0;
          this.remainingTime = this.duration;
          this.warningEmitted1 = false;
          this.warningEmitted2 = false;
          console.log("Timer started with duration: " + this.duration + "s");
        }

        /**
         * Pause the timer
         */;
        _proto.pauseTimer = function pauseTimer() {
          if (!this.isRunning || this.isPaused) return;
          this.isPaused = true;
          this.pauseTime = Date.now();
          console.log('Timer paused');
        }

        /**
         * Resume the timer
         */;
        _proto.resumeTimer = function resumeTimer() {
          if (!this.isRunning || !this.isPaused) return;
          this.isPaused = false;
          this.pausedDuration += Date.now() - this.pauseTime;
          console.log('Timer resumed');
        }

        /**
         * Stop the timer
         */;
        _proto.stopTimer = function stopTimer() {
          if (!this.isRunning) return;
          this.isRunning = false;
          this.isPaused = false;
          console.log('Timer stopped');
        }

        /**
         * Reset the timer
         */;
        _proto.resetTimer = function resetTimer() {
          this.isRunning = false;
          this.isPaused = false;
          this.startTime = 0;
          this.pauseTime = 0;
          this.pausedDuration = 0;
          this.remainingTime = this.duration;
          this.warningEmitted1 = false;
          this.warningEmitted2 = false;
          console.log('Timer reset');
        }

        /**
         * Get the remaining time
         * @returns Remaining time in seconds
         */;
        _proto.getRemainingTime = function getRemainingTime() {
          return this.remainingTime;
        }

        /**
         * Get the elapsed time
         * @returns Elapsed time in seconds
         */;
        _proto.getElapsedTime = function getElapsedTime() {
          return this.duration - this.remainingTime;
        }

        /**
         * Get the progress percentage
         * @returns Progress percentage (0-1)
         */;
        _proto.getProgress = function getProgress() {
          return 1 - this.remainingTime / this.duration;
        }

        /**
         * Set a custom duration
         * @param duration Duration in seconds
         */;
        _proto.setDuration = function setDuration(duration) {
          if (this.isRunning) {
            console.warn('Cannot change duration while timer is running');
            return;
          }
          this.duration = duration;
          this.remainingTime = duration;
        }

        /**
         * Add time to the timer
         * @param seconds Seconds to add
         */;
        _proto.addTime = function addTime(seconds) {
          if (!this.isRunning) return;
          this.remainingTime += seconds;

          // Reset warning flags if time goes back above warning thresholds
          if (this.remainingTime > this.warningTime1) {
            this.warningEmitted1 = false;
          }
          if (this.remainingTime > this.warningTime2) {
            this.warningEmitted2 = false;
          }
          console.log("Added " + seconds + "s to timer. Remaining time: " + this.remainingTime.toFixed(1) + "s");
        }

        /**
         * Update method called every frame
         * @param dt Delta time
         */;
        _proto.update = function update(dt) {
          if (!this.isRunning || this.isPaused) return;

          // Calculate remaining time
          var elapsed = (Date.now() - this.startTime - this.pausedDuration) / 1000;
          this.remainingTime = Math.max(0, this.duration - elapsed);

          // Check for time warnings
          if (!this.warningEmitted1 && this.remainingTime <= this.warningTime1) {
            this.warningEmitted1 = true;
            PitchTimer.emit(PitchConstants.EVENTS.TIME_WARNING, this.remainingTime);
            console.log("Time warning 1: " + this.remainingTime.toFixed(1) + "s remaining");
          }
          if (!this.warningEmitted2 && this.remainingTime <= this.warningTime2) {
            this.warningEmitted2 = true;
            PitchTimer.emit(PitchConstants.EVENTS.TIME_WARNING, this.remainingTime);
            console.log("Time warning 2: " + this.remainingTime.toFixed(1) + "s remaining");
          }

          // Check if time is up
          if (this.remainingTime <= 0) {
            this.isRunning = false;
            PitchTimer.emit(PitchConstants.EVENTS.GAME_OVER);
            console.log('Time\'s up!');
          }
        }

        /**
         * Add a listener for timer events
         * @param eventName Event name
         * @param callback Callback function
         * @param target Target object
         */;
        PitchTimer.on = function on(eventName, callback, target) {
          this.eventTarget.on(eventName, callback, target);
        }

        /**
         * Remove a listener for timer events
         * @param eventName Event name
         * @param callback Callback function
         * @param target Target object
         */;
        PitchTimer.off = function off(eventName, callback, target) {
          this.eventTarget.off(eventName, callback, target);
        }

        /**
         * Emit a timer event
         * @param eventName Event name
         * @param arg1 First argument
         * @param arg2 Second argument
         * @param arg3 Third argument
         * @param arg4 Fourth argument
         * @param arg5 Fifth argument
         */;
        PitchTimer.emit = function emit(eventName, arg1, arg2, arg3, arg4, arg5) {
          this.eventTarget.emit(eventName, arg1, arg2, arg3, arg4, arg5);
        };
        _createClass(PitchTimer, null, [{
          key: "instance",
          get:
          /**
           * Get the singleton instance
           */
          function get() {
            return this._instance;
          }
        }]);
        return PitchTimer;
      }(Component), _class3._instance = null, _class3.eventTarget = new EventTarget(), _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "duration", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return PitchConstants.GAME_DURATION;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "warningTime1", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return PitchConstants.WARNING_TIME_1;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "warningTime2", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return PitchConstants.WARNING_TIME_2;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PitchUIManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './PitchConstants.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createForOfIteratorHelperLoose, _createClass, cclegacy, _decorator, Node, Label, Sprite, ParticleSystem2D, Animation, Button, Vec3, Color, tween, Component, GameState, PitchConstants, FeedbackType;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createForOfIteratorHelperLoose = module.createForOfIteratorHelperLoose;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Label = module.Label;
      Sprite = module.Sprite;
      ParticleSystem2D = module.ParticleSystem2D;
      Animation = module.Animation;
      Button = module.Button;
      Vec3 = module.Vec3;
      Color = module.Color;
      tween = module.tween;
      Component = module.Component;
    }, function (module) {
      GameState = module.GameState;
      PitchConstants = module.PitchConstants;
      FeedbackType = module.FeedbackType;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _descriptor20, _class3;
      cclegacy._RF.push({}, "eaf8ab4I6VMYr2n+WmMAYid", "PitchUIManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * UI Manager for the Pitch Detection Game
       * Manages all UI elements and visual feedback
       */
      var PitchUIManager = exports('PitchUIManager', (_dec = ccclass('PitchUIManager'), _dec2 = property(Node), _dec3 = property(Node), _dec4 = property(Node), _dec5 = property(Node), _dec6 = property(Node), _dec7 = property(Node), _dec8 = property(Node), _dec9 = property(Label), _dec10 = property(Label), _dec11 = property(Label), _dec12 = property(Sprite), _dec13 = property({
        type: [Node]
      }), _dec14 = property({
        type: [Node]
      }), _dec15 = property(ParticleSystem2D), _dec16 = property(Animation), _dec17 = property(Label), _dec18 = property(Label), _dec19 = property(Label), _dec20 = property(Button), _dec21 = property(Button), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(PitchUIManager, _Component);
        function PitchUIManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // UI screens
          _initializerDefineProperty(_this, "mainMenuScreen", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "gameplayScreen", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "resultsScreen", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "calibrationScreen", _descriptor4, _assertThisInitialized(_this));
          // Gameplay UI elements
          _initializerDefineProperty(_this, "musicalStaff", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "butterfly", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "progressLine", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "timerLabel", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "currentNoteLabel", _descriptor9, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "targetNoteLabel", _descriptor10, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "microphone", _descriptor11, _assertThisInitialized(_this));
          // Note indicators on the musical staff
          _initializerDefineProperty(_this, "noteIndicators", _descriptor12, _assertThisInitialized(_this));
          // Feedback elements
          _initializerDefineProperty(_this, "feedbackNodes", _descriptor13, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "butterflyParticles", _descriptor14, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "feedbackAnimation", _descriptor15, _assertThisInitialized(_this));
          // Results UI elements
          _initializerDefineProperty(_this, "resultsTitleLabel", _descriptor16, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "resultsTimeLabel", _descriptor17, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "resultsAccuracyLabel", _descriptor18, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "retryButton", _descriptor19, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "mainMenuButton", _descriptor20, _assertThisInitialized(_this));
          // Animation properties
          _this.BUTTERFLY_MOVE_DURATION = 0.3;
          _this.PROGRESS_LINE_MOVE_DURATION = 0.5;
          // Current state
          _this.currentGameState = GameState.INIT;
          _this.currentSequence = null;
          _this.currentNoteIndex = 0;
          _this.butterflyTween = null;
          return _this;
        }
        var _proto = PitchUIManager.prototype;
        _proto.onLoad = function onLoad() {
          // Set up singleton instance
          if (PitchUIManager._instance !== null) {
            this.node.destroy();
            return;
          }
          PitchUIManager._instance = this;
        };
        _proto.start = function start() {
          // Hide all screens initially
          this.hideAllScreens();

          // Show main menu by default
          this.showMainMenu();
        }

        /**
         * Hide all UI screens
         */;
        _proto.hideAllScreens = function hideAllScreens() {
          if (this.mainMenuScreen) this.mainMenuScreen.active = false;
          if (this.gameplayScreen) this.gameplayScreen.active = false;
          if (this.resultsScreen) this.resultsScreen.active = false;
          if (this.calibrationScreen) this.calibrationScreen.active = false;
        }

        /**
         * Show the main menu screen
         */;
        _proto.showMainMenu = function showMainMenu() {
          this.hideAllScreens();
          if (this.mainMenuScreen) {
            this.mainMenuScreen.active = true;
            this.currentGameState = GameState.INIT;
          }
        }

        /**
         * Show the gameplay screen
         * @param sequence Note sequence for the level
         */;
        _proto.showGameplay = function showGameplay(sequence) {
          this.hideAllScreens();
          if (this.gameplayScreen) {
            this.gameplayScreen.active = true;
            this.currentGameState = GameState.PLAYING;
            this.currentSequence = sequence;
            this.currentNoteIndex = 0;

            // Initialize UI elements
            this.initializeGameplayUI();
          }
        }

        /**
         * Show the calibration screen
         */;
        _proto.showCalibration = function showCalibration() {
          this.hideAllScreens();
          if (this.calibrationScreen) {
            this.calibrationScreen.active = true;
            this.currentGameState = GameState.CALIBRATING;
          }
        }

        /**
         * Show the results screen
         * @param success Whether the player completed the sequence successfully
         * @param timeRemaining Time remaining in seconds
         * @param accuracy Overall accuracy percentage
         */;
        _proto.showResults = function showResults(success, timeRemaining, accuracy) {
          this.hideAllScreens();
          if (this.resultsScreen) {
            this.resultsScreen.active = true;
            this.currentGameState = GameState.GAME_OVER;

            // Update results UI
            if (this.resultsTitleLabel) {
              this.resultsTitleLabel.string = success ? "Success!" : "Time's Up!";
            }
            if (this.resultsTimeLabel) {
              this.resultsTimeLabel.string = "Time: " + timeRemaining.toFixed(1) + "s remaining";
            }
            if (this.resultsAccuracyLabel) {
              this.resultsAccuracyLabel.string = "Accuracy: " + accuracy.toFixed(1) + "%";
            }
          }
        }

        /**
         * Initialize gameplay UI elements
         */;
        _proto.initializeGameplayUI = function initializeGameplayUI() {
          // Reset butterfly position to the bottom
          if (this.butterfly) {
            this.butterfly.setPosition(new Vec3(0, -150, 0));
          }

          // Reset progress line to the start
          if (this.progressLine) {
            this.progressLine.setPosition(new Vec3(-200, 0, 0));
          }

          // Set up note indicators
          this.setupNoteIndicators();

          // Update target note label
          this.updateTargetNoteLabel();

          // Reset current note label
          if (this.currentNoteLabel) {
            this.currentNoteLabel.string = "";
          }

          // Reset timer label
          if (this.timerLabel) {
            this.timerLabel.string = PitchConstants.GAME_DURATION + "s";
          }
        }

        /**
         * Set up note indicators on the musical staff
         */;
        _proto.setupNoteIndicators = function setupNoteIndicators() {
          if (!this.noteIndicators || !this.currentSequence) return;

          // Hide all note indicators initially
          for (var _iterator = _createForOfIteratorHelperLoose(this.noteIndicators), _step; !(_step = _iterator()).done;) {
            var indicator = _step.value;
            indicator.active = false;
          }

          // Show indicators for notes in the sequence
          var notes = this.currentSequence.notes;
          for (var i = 0; i < notes.length && i < this.noteIndicators.length; i++) {
            var noteValue = notes[i].note;
            if (noteValue >= 0 && noteValue < this.noteIndicators.length) {
              this.noteIndicators[noteValue].active = true;
            }
          }

          // Highlight the first note
          this.highlightNoteIndicator(notes[0].note);
        }

        /**
         * Highlight a specific note indicator
         * @param note Note to highlight
         */;
        _proto.highlightNoteIndicator = function highlightNoteIndicator(note) {
          if (!this.noteIndicators) return;

          // Reset all indicators to normal state
          for (var i = 0; i < this.noteIndicators.length; i++) {
            var indicator = this.noteIndicators[i];
            if (indicator && indicator.active) {
              var sprite = indicator.getComponent(Sprite);
              if (sprite) {
                sprite.color = new Color(255, 255, 255, 255);
              }
            }
          }

          // Highlight the target note
          if (note >= 0 && note < this.noteIndicators.length) {
            var _indicator = this.noteIndicators[note];
            if (_indicator && _indicator.active) {
              var _sprite = _indicator.getComponent(Sprite);
              if (_sprite) {
                _sprite.color = new Color(255, 255, 0, 255); // Yellow highlight
              }
            }
          }
        }

        /**
         * Update the target note label
         */;
        _proto.updateTargetNoteLabel = function updateTargetNoteLabel() {
          if (!this.targetNoteLabel || !this.currentSequence) return;
          var notes = this.currentSequence.notes;
          if (this.currentNoteIndex < notes.length) {
            var noteName = PitchConstants.NOTE_NAMES[notes[this.currentNoteIndex].note];
            this.targetNoteLabel.string = "Target: " + noteName;
          } else {
            this.targetNoteLabel.string = "";
          }
        }

        /**
         * Update the current note label
         * @param note Detected note
         */;
        _proto.updateCurrentNoteLabel = function updateCurrentNoteLabel(note) {
          if (!this.currentNoteLabel) return;
          if (note !== null) {
            var noteName = PitchConstants.NOTE_NAMES[note];
            this.currentNoteLabel.string = "Current: " + noteName;
          } else {
            this.currentNoteLabel.string = "Current: -";
          }
        }

        /**
         * Update the timer display
         * @param remainingTime Remaining time in seconds
         */;
        _proto.updateTimer = function updateTimer(remainingTime) {
          if (!this.timerLabel) return;
          this.timerLabel.string = Math.ceil(remainingTime) + "s";

          // Change color for time warnings
          if (remainingTime <= PitchConstants.WARNING_TIME_2) {
            this.timerLabel.color = new Color(255, 0, 0, 255); // Red for final warning
          } else if (remainingTime <= PitchConstants.WARNING_TIME_1) {
            this.timerLabel.color = new Color(255, 165, 0, 255); // Orange for first warning
          } else {
            this.timerLabel.color = new Color(255, 255, 255, 255); // White for normal
          }
        }

        /**
         * Move the butterfly to indicate the current pitch
         * @param note Detected note
         * @param volume Voice volume
         */;
        _proto.moveButterfly = function moveButterfly(note, volume) {
          if (!this.butterfly) return;

          // Cancel any existing tween
          if (this.butterflyTween) {
            this.butterflyTween.stop();
            this.butterflyTween = null;
          }

          // Calculate target position based on note
          var targetY = -150; // Default position at the bottom

          if (note !== null) {
            // Map note to Y position on the staff
            // DO is at the bottom, SI is at the top
            var notePositions = [-150,
            // DO
            -100,
            // RE
            -50,
            // MI
            0,
            // FA
            50,
            // SOL
            100,
            // LA
            150 // SI
            ];

            targetY = notePositions[note];

            // Activate butterfly particles
            if (this.butterflyParticles) {
              this.butterflyParticles.enabled = true;

              // Adjust particle emission rate based on volume
              // Note: Direct emission rate adjustment may need to be implemented
              // based on the specific ParticleSystem2D implementation
              this.butterflyParticles.emissionRate = volume * 100; // Scale volume to emission rate
            }
          } else {
            // Disable butterfly particles
            if (this.butterflyParticles) {
              this.butterflyParticles.enabled = false;
            }
          }

          // Create tween to move butterfly
          var currentPos = this.butterfly.position;
          this.butterflyTween = tween(this.butterfly).to(this.BUTTERFLY_MOVE_DURATION, {
            position: new Vec3(currentPos.x, targetY, currentPos.z)
          }, {
            easing: 'cubicOut'
          }).start();
        }

        /**
         * Advance the progress line
         */;
        _proto.advanceProgressLine = function advanceProgressLine() {
          if (!this.progressLine || !this.currentSequence) return;

          // Calculate progress percentage
          var totalNotes = this.currentSequence.notes.length;
          var progress = (this.currentNoteIndex + 1) / totalNotes;

          // Calculate target position
          var startX = -200;
          var endX = 200;
          var targetX = startX + (endX - startX) * progress;

          // Create tween to move progress line
          var currentPos = this.progressLine.position;
          tween(this.progressLine).to(this.PROGRESS_LINE_MOVE_DURATION, {
            position: new Vec3(targetX, currentPos.y, currentPos.z)
          }, {
            easing: 'cubicOut'
          }).start();
        }

        /**
         * Show feedback for note detection
         * @param type Feedback type
         */;
        _proto.showFeedback = function showFeedback(type) {
          if (!this.feedbackNodes || !this.feedbackAnimation) return;

          // Hide all feedback nodes
          for (var _iterator2 = _createForOfIteratorHelperLoose(this.feedbackNodes), _step2; !(_step2 = _iterator2()).done;) {
            var node = _step2.value;
            node.active = false;
          }

          // Show the appropriate feedback node
          if (type >= 0 && type < this.feedbackNodes.length) {
            this.feedbackNodes[type].active = true;
          }

          // Play feedback animation
          var animationName = ['perfect', 'good', 'miss', 'timeWarning'][type];
          this.feedbackAnimation.play(animationName);
        }

        /**
         * Advance to the next note in the sequence
         * @returns True if there are more notes, false if the sequence is complete
         */;
        _proto.advanceToNextNote = function advanceToNextNote() {
          if (!this.currentSequence) return false;
          this.currentNoteIndex++;

          // Check if there are more notes
          if (this.currentNoteIndex < this.currentSequence.notes.length) {
            // Update UI for the next note
            this.updateTargetNoteLabel();
            this.highlightNoteIndicator(this.currentSequence.notes[this.currentNoteIndex].note);
            return true;
          } else {
            // Sequence complete
            return false;
          }
        }

        /**
         * Get the current target note
         * @returns Current target note or null if no sequence is active
         */;
        _proto.getCurrentTargetNote = function getCurrentTargetNote() {
          if (!this.currentSequence || this.currentNoteIndex >= this.currentSequence.notes.length) {
            return null;
          }
          return this.currentSequence.notes[this.currentNoteIndex].note;
        }

        /**
         * Show a time warning effect
         * @param remainingTime Remaining time in seconds
         */;
        _proto.showTimeWarning = function showTimeWarning(remainingTime) {
          // Flash the timer
          if (this.timerLabel && this.timerLabel.node) {
            tween(this.timerLabel.node).to(0.2, {
              scale: new Vec3(1.5, 1.5, 1.5)
            }).to(0.2, {
              scale: new Vec3(1.0, 1.0, 1.0)
            }).repeat(2).start();
          }

          // Show time warning feedback
          this.showFeedback(FeedbackType.TIME_WARNING);
        }

        /**
         * Get the current game state
         * @returns Current game state
         */;
        _proto.getGameState = function getGameState() {
          return this.currentGameState;
        };
        _createClass(PitchUIManager, null, [{
          key: "instance",
          get:
          /**
           * Get the singleton instance
           */
          function get() {
            return this._instance;
          }
        }]);
        return PitchUIManager;
      }(Component), _class3._instance = null, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "mainMenuScreen", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "gameplayScreen", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "resultsScreen", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "calibrationScreen", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "musicalStaff", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "butterfly", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "progressLine", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "timerLabel", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "currentNoteLabel", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "targetNoteLabel", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "microphone", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "noteIndicators", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "feedbackNodes", [_dec14], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, "butterflyParticles", [_dec15], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor15 = _applyDecoratedDescriptor(_class2.prototype, "feedbackAnimation", [_dec16], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor16 = _applyDecoratedDescriptor(_class2.prototype, "resultsTitleLabel", [_dec17], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor17 = _applyDecoratedDescriptor(_class2.prototype, "resultsTimeLabel", [_dec18], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor18 = _applyDecoratedDescriptor(_class2.prototype, "resultsAccuracyLabel", [_dec19], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor19 = _applyDecoratedDescriptor(_class2.prototype, "retryButton", [_dec20], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor20 = _applyDecoratedDescriptor(_class2.prototype, "mainMenuButton", [_dec21], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/polar-coordinates.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec2, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec2 = module.Vec2;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "db427Xs0q5CMbRASs8quHqY", "polar-coordinates", undefined);
      var PolarCoordinates = exports('default', (_dec = register({
        menu: 'Uv/PolarCoordinates',
        title: 'PolarCoordinates'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(PolarCoordinates, _ShaderNode);
        function PolarCoordinates() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.depChunks = ['uv'];
          _this.data = {
            inputs: [slot('uv', Vec2.ZERO, 'vec2', 'vector'), slot('center', Vec2.ZERO, 'vec2', 'vector'), slot('radialScale', 0, 'float', 'vector'), slot('lengthScale', 0, 'float', 'vector')],
            outputs: [slot('Out', Vec2.ZERO, 'vec2', 'vector')]
          };
          return _this;
        }
        var _proto = PolarCoordinates.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          if (!this.inputs[0].connectSlot) {
            input0 = 'v_uv.xy';
          }
          var input1 = this.getInputValue(1);
          var input2 = this.getInputValue(2);
          var input3 = this.getInputValue(3);
          var output0 = this.getOutputVarDefine(0);
          return output0 + " = PolarCoordinates(" + input0 + ", " + input1 + ", " + input2 + ", " + input3 + ");";
        };
        return PolarCoordinates;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/poolManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _createClass, cclegacy, _decorator, instantiate, NodePool;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      instantiate = module.instantiate;
      NodePool = module.NodePool;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "411ad/aVKtGja0EX2BBJnVT", "poolManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var PoolManager = exports('PoolManager', (_dec = ccclass("PoolManager"), _dec(_class = (_class2 = /*#__PURE__*/function () {
        function PoolManager() {
          this._dictPool = {};
          //
          this._dictPrefab = {};
        }
        var _proto = PoolManager.prototype;
        /**
         * 
         */
        _proto.getNode = function getNode(prefab, parent) {
          var name = prefab.name;
          //@ts-ignore
          if (!prefab.position) {
            //@ts-ignore
            name = prefab.data.name;
          }
          this._dictPrefab[name] = prefab;
          var node = null;
          if (this._dictPool.hasOwnProperty(name)) {
            //
            var pool = this._dictPool[name];
            if (pool.size() > 0) {
              node = pool.get();
            } else {
              node = instantiate(prefab);
            }
          } else {
            //
            var _pool = new NodePool();
            this._dictPool[name] = _pool;
            node = instantiate(prefab);
          }
          node.parent = parent;
          node.active = true;
          node.name = name;
          return node;
        }

        /**
         * 
         */;
        _proto.putNode = function putNode(node) {
          if (!node) {
            return;
          }
          var name = node.name;
          var pool = null;
          if (this._dictPool.hasOwnProperty(name)) {
            //
            pool = this._dictPool[name];
          } else {
            //
            pool = new NodePool();
            this._dictPool[name] = pool;
          }
          pool.put(node);
        }

        /**
         * 
         */;
        _proto.clearPool = function clearPool(name) {
          if (this._dictPool.hasOwnProperty(name)) {
            var pool = this._dictPool[name];
            pool.clear();
          }
        }

        /**
         * 
         *
         * @param {Prefab} prefab 
         * @param {number} num 
         * @returns
         * @memberof PoolManager
         */;
        _proto.preloadPool = function preloadPool(prefab, num) {
          var name = prefab.name;
          // @ts-ignore
          if (!prefab.position) {
            // @ts-ignore
            name = prefab.data.name;
          }
          var pool = null;
          if (this._dictPool.hasOwnProperty(name)) {
            // 
            pool = this._dictPool[name];
          } else {
            // 
            pool = new NodePool();
            this._dictPool[name] = pool;
          }
          for (var i = 0; i < num; i++) {
            var node = instantiate(prefab);
            pool.put(node);
          }
        };
        _createClass(PoolManager, null, [{
          key: "instance",
          get: function get() {
            if (this._instance) {
              return this._instance;
            }
            this._instance = new PoolManager();
            return this._instance;
          }
        }]);
        return PoolManager;
      }(), _class2._instance = void 0, _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PopupBase.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './uiManager.ts', './AnimationPanel.ts'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, UIManager, AnimationPanel;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      AnimationPanel = module.AnimationPanel;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "60806q+/XRP8Yh7Fpwhr+Nd", "PopupBase", undefined);
      var ccclass = _decorator.ccclass;
      var PopupBase = exports('PopupBase', (_dec = ccclass('PopupBase'), _dec(_class = /*#__PURE__*/function (_AnimationPanel) {
        _inheritsLoose(PopupBase, _AnimationPanel);
        function PopupBase() {
          return _AnimationPanel.apply(this, arguments) || this;
        }
        var _proto = PopupBase.prototype;
        _proto.doUImanagerHide = function doUImanagerHide() {
          var _this = this;
          this.hide(function () {
            UIManager.instance.hideDialog(_this.node.name);
          });
        };
        return PopupBase;
      }(AnimationPanel)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PopupDefine.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "508dcnFkVtIbZwwhiY9QURR", "PopupDefine", undefined);
      var POPUP = exports('POPUP', {
        MESSAGE: "PopupMessage",
        LOADING: "PopupLoading",
        SAMPLE: "PopupSample"
      });
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PopupLoading.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './PopupBase.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Label, PopupBase;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Label = module.Label;
    }, function (module) {
      PopupBase = module.PopupBase;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "f3854cZ+7tJvbx0v7anFQPX", "PopupLoading", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var PopupLoading = exports('PopupLoading', (_dec = ccclass('PopupLoading'), _dec2 = property(Label), _dec(_class = (_class2 = /*#__PURE__*/function (_PopupBase) {
        _inheritsLoose(PopupLoading, _PopupBase);
        function PopupLoading() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _PopupBase.call.apply(_PopupBase, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "lbDetail", _descriptor, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = PopupLoading.prototype;
        _proto.show = function show(data, callback) {
          var _ref;
          _PopupBase.prototype.show.call(this, data, callback);
          var detail = (_ref = data) != null ? _ref : "";
          this.lbDetail.string = detail;
        };
        _proto.setLoadingDetail = function setLoadingDetail(detail) {
          this.lbDetail.string = detail;
        };
        return PopupLoading;
      }(PopupBase), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "lbDetail", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PopupMessage.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './PopupBase.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Label, PopupBase;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Label = module.Label;
    }, function (module) {
      PopupBase = module.PopupBase;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3;
      cclegacy._RF.push({}, "7cf33btXkBJaJszpFBOgTb7", "PopupMessage", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var PopupMessage = exports('PopupMessage', (_dec = ccclass('PopupMessage'), _dec2 = property(Label), _dec3 = property(Label), _dec4 = property(Label), _dec(_class = (_class2 = /*#__PURE__*/function (_PopupBase) {
        _inheritsLoose(PopupMessage, _PopupBase);
        function PopupMessage() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _PopupBase.call.apply(_PopupBase, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "lbContent", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "lbTitle", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "lbButtonText", _descriptor3, _assertThisInitialized(_this));
          _this.confirmCallback = null;
          return _this;
        }
        var _proto = PopupMessage.prototype;
        _proto.show = function show(data, callback) {
          var _data$title, _data$buttonText;
          _PopupBase.prototype.show.call(this, data, callback);
          if (!data) return;
          this.confirmCallback = data.buttonCallback;
          this.lbContent.string = data.message;
          this.lbTitle.string = (_data$title = data.title) != null ? _data$title : "";
          this.lbButtonText.string = (_data$buttonText = data.buttonText) != null ? _data$buttonText : "OK";
        };
        _proto.onTouch_Confirm = function onTouch_Confirm() {
          var _this$confirmCallback;
          (_this$confirmCallback = this.confirmCallback) == null || _this$confirmCallback.call(this);
          this.doUImanagerHide();
        };
        return PopupMessage;
      }(PopupBase), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "lbContent", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "lbTitle", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "lbButtonText", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PopupMTSongSelection.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './PopupBase.ts', './resourceUtil.ts', './MTItemSong.ts', './GameplayManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Node, director, JsonAsset, instantiate, PopupBase, resourceUtil, MTItemSong, GameplayManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      director = module.director;
      JsonAsset = module.JsonAsset;
      instantiate = module.instantiate;
    }, function (module) {
      PopupBase = module.PopupBase;
    }, function (module) {
      resourceUtil = module.resourceUtil;
    }, function (module) {
      MTItemSong = module.MTItemSong;
    }, function (module) {
      GameplayManager = module.GameplayManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "3828eDIEe1G/rr9u6tsVC3f", "PopupMTSongSelection", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var PopupMTSongSelection = exports('PopupMTSongSelection', (_dec = ccclass('PopupMTSongSelection'), _dec2 = property(Node), _dec3 = property(Node), _dec(_class = (_class2 = /*#__PURE__*/function (_PopupBase) {
        _inheritsLoose(PopupMTSongSelection, _PopupBase);
        function PopupMTSongSelection() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _PopupBase.call.apply(_PopupBase, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "contentNode", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "itemSongPrefab", _descriptor2, _assertThisInitialized(_this));
          _this.beatmaps = new Map();
          _this.gameplayManager = null;
          return _this;
        }
        var _proto = PopupMTSongSelection.prototype;
        _proto.start = function start() {
          // Find the GameplayManager
          this.gameplayManager = director.getScene().getComponentInChildren(GameplayManager);

          // Load all beatmap files from resources
          this.loadAllBeatmaps();
        }

        /**
         * Load all beatmap files from resources
         */;
        _proto.loadAllBeatmaps = function loadAllBeatmaps() {
          var _this2 = this;
          // Path to beatmaps folder
          var beatmapsPath = 'magic_tiles/beatmaps';

          // Use resourceUtil to load all JSON files in the beatmaps directory
          resourceUtil.loadAllResources(beatmapsPath, function (assets) {
            // Filter out only JsonAsset type resources
            var jsonAssets = assets.filter(function (asset) {
              return asset instanceof JsonAsset;
            });

            // Process each beatmap
            jsonAssets.forEach(function (jsonAsset) {
              if (jsonAsset && jsonAsset.json) {
                try {
                  var beatmapData = jsonAsset.json;
                  if (beatmapData && beatmapData.metadata) {
                    // Store the beatmap metadata
                    // Set the beatmap ID to the jsonAsset name
                    beatmapData.metadata.id = jsonAsset.name;
                    _this2.beatmaps.set(beatmapData.metadata.id, beatmapData.metadata);
                  }
                } catch (error) {
                  console.error("Failed to parse beatmap JSON: " + jsonAsset.name, error);
                }
              }
            });

            // Create UI items for each beatmap
            _this2.createSongItems();
          });
        }

        /**
         * Create song items in the content node
         */;
        _proto.createSongItems = function createSongItems() {
          var _this3 = this;
          // Clear existing content
          this.contentNode.removeAllChildren();

          // Create an item for each beatmap
          this.beatmaps.forEach(function (metadata) {
            // Instantiate the song item prefab
            var itemNode = instantiate(_this3.itemSongPrefab);
            itemNode.active = true;
            var itemComponent = itemNode.getComponent(MTItemSong);
            if (itemComponent) {
              // Set the song data and callback
              itemComponent.setSongData(metadata, _this3.onSongSelected.bind(_this3));

              // Add to the content node
              _this3.contentNode.addChild(itemNode);
            }
          });
        }

        /**
         * Callback when a song is selected
         * @param songId The ID of the selected song
         */;
        _proto.onSongSelected = function onSongSelected(songId) {
          var _this4 = this;
          if (!this.gameplayManager) {
            console.error('GameplayManager not found');
            return;
          }

          // Load the selected beatmap
          this.gameplayManager.LoadBeatMap(songId).then(function (success) {
            if (success) {
              // Hide this popup
              _this4.hide();
            } else {
              console.error("Failed to load beatmap: " + songId);
              // Could show an error message here
            }
          });
        };

        return PopupMTSongSelection;
      }(PopupBase), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "contentNode", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "itemSongPrefab", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/position.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './base.ts', './type.ts', './utils.ts', './index3.ts', './register.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec3, ShaderNode, PositionSpace, ConcretePrecisionType, getEnumDefine, prop, slot, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec3 = module.Vec3;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      PositionSpace = module.PositionSpace;
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      getEnumDefine = module.getEnumDefine;
      prop = module.prop;
      slot = module.slot;
    }, null, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "c4117F5YClIWKQl+GltCNqQ", "position", undefined);
      var PositionNode = exports('default', (_dec = register({
        menu: 'Input/Geometry/Position',
        title: 'Position'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(PositionNode, _ShaderNode);
        function PositionNode() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.fixedConcretePrecision = 3;
          _this.data = {
            props: [prop('Space', PositionSpace.World, 'enum', {
              "enum": PositionSpace
            })],
            outputs: [slot('Position', new Vec3(), 'vec3', 'vector')]
          };
          return _this;
        }
        var _proto = PositionNode.prototype;
        _proto.generateCode = function generateCode() {
          var prop = this.getPropWithName('Space');
          var name = 'position';
          if (prop.value === PositionSpace.Local) {
            name = 'position';
          } else if (prop.value === PositionSpace.View) {
            name = 'viewPos';
          }
          // else if (prop.value === PositionSpace.Tangent) {
          //     // name = 'v_tangentPos';
          //     name = 'worldPos';
          // }
          else if (prop.value === PositionSpace.World) {
            name = 'worldPos';
          }
          // else if (prop.value === PositionSpace.AbsoluteWorld) {
          //     name = 'worldPos';
          // }

          this.defines = [getEnumDefine(PositionSpace, prop.value)];
          return this.getOutputVarDefine(0) + " = " + name + ".xyz;";
        };
        return PositionNode;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/posterize.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "83ac4Oj/INHY7tCCfwuaa6d", "posterize", undefined);
      var Posterize = exports('default', (_dec = register({
        menu: 'Math/Advanced/Posterize',
        title: 'Posterize'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Posterize, _ShaderNode);
        function Posterize() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector'), slot('Steps', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Posterize.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = floor(" + input0 + " / (1. / " + input1 + ")) * (1. / " + input1 + ");\n        ";
        };
        return Posterize;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/power.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "94eaaC4omdHcaTHrDX60+tq", "power", undefined);
      var Power = exports('default', (_dec = register({
        menu: 'Math/Basic/Power',
        title: 'Power'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Power, _ShaderNode);
        function Power() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Power.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = pow(" + input0 + ", " + input1 + ");\n        ";
        };
        return Power;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PreviewNode.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './base.ts'], function (exports) {
  var _inheritsLoose, cclegacy, ShaderNode;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }],
    execute: function () {
      cclegacy._RF.push({}, "f8b0fdliVNBereLRNhLivTf", "PreviewNode", undefined);
      var PreviewNode = exports('default', /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(PreviewNode, _ShaderNode);
        function PreviewNode() {
          return _ShaderNode.apply(this, arguments) || this;
        }
        var _proto = PreviewNode.prototype;
        _proto.generateCode = function generateCode() {
          return this.getOutputVarDefine(0) + " = " + this.getInputValue(0) + ";";
        };
        return PreviewNode;
      }(ShaderNode));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ProjectileController.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Cannon.ts', './Cursor.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Camera, sys, input, Input, PhysicsSystem, Vec3, tween, Component, Cannon, Cursor;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Camera = module.Camera;
      sys = module.sys;
      input = module.input;
      Input = module.Input;
      PhysicsSystem = module.PhysicsSystem;
      Vec3 = module.Vec3;
      tween = module.tween;
      Component = module.Component;
    }, function (module) {
      Cannon = module.Cannon;
    }, function (module) {
      Cursor = module.Cursor;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3;
      cclegacy._RF.push({}, "065763s9dBIZrOHBYD+VlHO", "ProjectileController", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var ProjectileController = exports('ProjectileController', (_dec = ccclass('ProjectileController'), _dec2 = property({
        type: Camera
      }), _dec3 = property({
        type: Cannon
      }), _dec4 = property({
        type: Cursor
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(ProjectileController, _Component);
        function ProjectileController() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "camera", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "cannon", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "cursor", _descriptor3, _assertThisInitialized(_this));
          _this.isActive = false;
          _this.aimValue = {
            value: 0
          };
          _this.tweenAim = null;
          _this.beginAimPosition = null;
          _this.targetAimPosition = null;
          return _this;
        }
        var _proto = ProjectileController.prototype;
        _proto.onLoad = function onLoad() {
          // this.registerEvent();
        };
        _proto.onDestroy = function onDestroy() {
          // this.unregisterEvent();
        };
        _proto.update = function update(dt) {
          this.updateAimPosition(dt);
        };
        _proto.registerEvent = function registerEvent() {
          if (sys.platform === sys.Platform.MOBILE_BROWSER) {
            input.on(Input.EventType.TOUCH_START, this.onTouchStart, this);
            input.on(Input.EventType.TOUCH_MOVE, this.onTouchMove, this);
            input.on(Input.EventType.TOUCH_END, this.onTouchEnd, this);
          } else {
            input.on(Input.EventType.MOUSE_DOWN, this.onMouseDown, this);
            input.on(Input.EventType.MOUSE_MOVE, this.onMouseMove, this);
            input.on(Input.EventType.MOUSE_UP, this.onMouseUp, this);
          }
        };
        _proto.unregisterEvent = function unregisterEvent() {
          if (sys.platform === sys.Platform.MOBILE_BROWSER) {
            input.off(Input.EventType.TOUCH_START, this.onTouchStart, this);
            input.off(Input.EventType.TOUCH_MOVE, this.onTouchMove, this);
            input.off(Input.EventType.TOUCH_END, this.onTouchEnd, this);
          } else {
            input.off(Input.EventType.MOUSE_DOWN, this.onMouseDown, this);
            input.off(Input.EventType.MOUSE_MOVE, this.onMouseMove, this);
            input.off(Input.EventType.MOUSE_UP, this.onMouseUp, this);
          }
        };
        _proto.onTouchStart = function onTouchStart(event) {
          if (event.getAllTouches().length > 1) {
            return;
          }
          this.aimWithScreenPos(event.getLocation());
        };
        _proto.onTouchMove = function onTouchMove(event) {
          if (event.getAllTouches().length > 1) {
            return;
          }
          this.aimWithScreenPos(event.getLocation());
        };
        _proto.onTouchEnd = function onTouchEnd(event) {
          if (event.getAllTouches().length > 0) {
            return;
          }
          this.aimWithScreenPos(event.getLocation());
          this.fire();
        };
        _proto.onMouseDown = function onMouseDown(event) {
          this.aimWithScreenPos(event.getLocation());
        };
        _proto.onMouseMove = function onMouseMove(event) {
          this.aimWithScreenPos(event.getLocation());
        };
        _proto.onMouseUp = function onMouseUp(event) {
          this.fire();
        };
        _proto.aimWithScreenPos = function aimWithScreenPos(screenPos) {
          if (!this.isActive) return;
          var ray = this.camera.screenPointToRay(screenPos.x, screenPos.y);
          if (!PhysicsSystem.instance.raycastClosest(ray)) {
            return;
          }
          var raycastClosest = PhysicsSystem.instance.raycastClosestResult;
          var hitPoint = raycastClosest.hitPoint;
          var hitNormal = raycastClosest.hitNormal;
          this.cannon.aim(hitPoint);
          this.cursor.set(hitPoint, hitNormal);
        };
        _proto.aimToPosition = function aimToPosition(position, duration, callback) {
          var _this$tweenAim,
            _this2 = this;
          if (duration === void 0) {
            duration = 0.0;
          }
          if (callback === void 0) {
            callback = null;
          }
          if (duration <= 0) {
            this.cannon.aim(position);
            this.cursor.set(position, Vec3.FORWARD);
            return;
          }
          this.aimValue.value = 0;
          this.beginAimPosition = this.cannon.curTargetPos.clone();
          this.targetAimPosition = position.clone();
          (_this$tweenAim = this.tweenAim) == null || _this$tweenAim.stop();
          this.tweenAim = tween(this.aimValue).to(duration, {
            value: 1.0
          }).call(function () {
            _this2.tweenAim = null;
            _this2.cannon.aim(_this2.targetAimPosition);
            _this2.cursor.set(_this2.targetAimPosition, Vec3.FORWARD);
            callback == null || callback();
          }).start();
        };
        _proto.updateAimPosition = function updateAimPosition(dt) {
          if (this.tweenAim === null) return;
          var aimPosition = Vec3.lerp(new Vec3(), this.beginAimPosition, this.targetAimPosition, this.aimValue.value);
          this.cannon.aim(aimPosition);
          this.cursor.set(aimPosition, Vec3.FORWARD);
        };
        _proto.fire = function fire() {
          this.cannon.fire();
        };
        return ProjectileController;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "camera", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "cannon", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "cursor", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ProjectileMath.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Constants.ts'], function (exports) {
  var _createClass, cclegacy, GameConstant;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      GameConstant = module.GameConstant;
    }],
    execute: function () {
      cclegacy._RF.push({}, "cc22b8mSmVF0q6lb6/6cNhf", "ProjectileMath", undefined);

      /**  */
      var rad2Deg = 180 / Math.PI;

      /**  */
      var deg2Rad = Math.PI / 180;

      /**
       * 
       */
      var ProjectileMath = exports('ProjectileMath', /*#__PURE__*/function () {
        function ProjectileMath() {}
        /**
         * 
         * @param x 
         * @param angle 
         * @param velocity 
         */
        ProjectileMath.calculateTotalTime = function calculateTotalTime(x, angle, velocity) {
          // 
          var  = angle * deg2Rad;

          // 
          // t = x / ( v * cos() )
          var t = x / (velocity * Math.cos());
          return t;
        }

        /**
         * 
         * @param angle 
         * @param velocity 
         * @param time 
         * @param returnInRadians 
         */;
        ProjectileMath.calculateAngleAtMoment = function calculateAngleAtMoment(angle, velocity, time, returnInRadians) {
          if (returnInRadians === void 0) {
            returnInRadians = false;
          }
          // 
          var g = ProjectileMath.gravity;
          // 
          var  = angle * deg2Rad;

          // 
          // vx = v * cos()
          var vx = velocity * Math.cos();

          // 
          // vy = v * sin() - g * t
          var vy = velocity * Math.sin() - g * time;

          // 
          var t = Math.atan(vy / vx);
          return returnInRadians ? t : t * rad2Deg;
        }

        /**
         * 
         * @param angle 
         * @param velocity 
         * @param time 
         */;
        ProjectileMath.calculateDisplacementAtMoment = function calculateDisplacementAtMoment(angle, velocity, time) {
          // 
          var g = ProjectileMath.gravity;
          // 
          var  = angle * deg2Rad;

          // 
          // x = v * cos() * t
          var x = velocity * Math.cos() * time;

          // 
          // y = v * sin() * t - 0.5 * g * t^2
          var y = velocity * Math.sin() * time - 0.5 * g * Math.pow(time, 2);
          return {
            x: x,
            y: y
          };
        }

        /**
         * 
         * @param x 
         * @param y 
         * @param angle 
         */;
        ProjectileMath.calculateWithAngle = function calculateWithAngle(x, y, angle) {
          // 
          // const g = Math.abs(PhysicsSystem.instance.gravity.y);
          var g = GameConstant.GAME.PHYSIC_GRAVITY;
          // 
          var  = angle * deg2Rad;

          // 
          // v = sqrt( ( x^2 * g ) / ( 2 * x * sin() * cos() - 2 * y * cos()^2 ) )

          // 
          var p1 = 2 * x * Math.sin() * Math.cos() - 2 * y * Math.pow(Math.cos(), 2);
          // 
          if (p1 < 0) {
            return NaN;
          }
          // 
          var v = Math.sqrt(g * Math.pow(x, 2) / p1);
          return v;
        }

        /**
         * 
         * @param x 
         * @param y 
         * @param velocity 
         */;
        ProjectileMath.calculateWithVelocity = function calculateWithVelocity(x, y, velocity) {
          // 
          var g = ProjectileMath.gravity;
          // 
          var v = velocity;

          // 
          //  = atan( ( -v^2  sqrt( v^4 - g * ( g * x^2 + 2 * y * v^2 ) ) / ( -g * x ) ) )

          // 
          var p1 = Math.pow(v, 2);
          var p2 = Math.pow(v, 4) - g * (g * Math.pow(x, 2) + 2 * y * p1);
          // 
          if (p2 < 0) {
            return {
              angle1: NaN,
              angle2: NaN
            };
          }
          // 
          var p3 = Math.sqrt(p2);
          // 
          var 1 = Math.atan((-p1 + p3) / (-g * x));
          var 2 = Math.atan((-p1 - p3) / (-g * x));
          return {
            angle1: 1 * rad2Deg,
            angle2: 2 * rad2Deg
          };
        }

        /**
         * 
         * @param x 
         * @param y 
         * @param maxHeight 
         */;
        ProjectileMath.calculateWithMaxHeight = function calculateWithMaxHeight(x, y, maxHeight) {
          // 
          var g = ProjectileMath.gravity;
          // 
          var h = maxHeight;

          //  0
          if (h < 0 || h - y < 0) {
            return {
              angle: NaN,
              velocity: NaN,
              time: NaN
            };
          }

          // 
          var p1 = Math.sqrt(2 * g * h);
          var p2 = Math.sqrt(2 * g * (h - y));

          // 
          // t = ( -sqrt( 2 * g * h )  sqrt( 2 * g * ( h - y ) ) ) / -g
          var t1 = (-p1 + p2) / -g;
          var t2 = (-p1 - p2) / -g;
          // 
          var t = Math.max(t1, t2);

          // 
          //  = atan( ( sqrt( 2 * g * h ) * t ) / x )
          var  = Math.atan(p1 * t / x);

          // 
          // v = sqrt( 2 * g * h ) / sin()
          var v = p1 / Math.sin();
          return {
            angle:  * rad2Deg,
            velocity: v,
            time: t
          };
        };
        _createClass(ProjectileMath, null, [{
          key: "gravity",
          get:
          /**
           * 
           */
          function get() {
            return GameConstant.GAME.PHYSIC_GRAVITY;
            // return Math.abs(PhysicsSystem.instance.gravity.y);
          }
        }]);

        return ProjectileMath;
      }());
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/projection.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "76ce8feSIBML7x6UxKZ/iDJ", "projection", undefined);
      var Projection = exports('default', (_dec = register({
        menu: 'Math/Vector/Projection',
        title: 'Projection'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Projection, _ShaderNode);
        function Projection() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Projection.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = " + input1 + " * dot(" + input0 + ", " + input1 + ") / dot(" + input1 + ", " + input1 + ");\n        ";
        };
        return Projection;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/property-node.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './base.ts', './context.ts', './property.ts', './type.ts', './utils.ts', './register.ts'], function (exports) {
  var _inheritsLoose, cclegacy, ShaderNode, shaderContext, ShaderPropertyType, ConcretePrecisionType, slot, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      shaderContext = module.shaderContext;
    }, function (module) {
      ShaderPropertyType = module.ShaderPropertyType;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "93194csMENJ+oWCPxFCx+9c", "property-node", undefined);
      var PropertyNode = exports('default', (_dec = register({
        style: {
          headerColor: '#ec7063'
        }
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(PropertyNode, _ShaderNode);
        function PropertyNode() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.property = null;
          _this.name = '';
          _this.data = {
            outputs: [slot('Out', {}, 'any', 'any')]
          };
          _this.isPropertyNode = true;
          return _this;
        }
        var _proto = PropertyNode.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          var _this2 = this;
          // super.calcConcretePrecision()

          var concretePrecision = 0;
          var prop = shaderContext.properties.find(function (p) {
            return p.name === _this2.name;
          });
          switch (prop.type) {
            case ShaderPropertyType.Float:
            case ShaderPropertyType.Boolean:
              concretePrecision = 1;
              break;
            case ShaderPropertyType.Vector2:
              concretePrecision = 2;
              break;
            case ShaderPropertyType.Vector3:
              concretePrecision = 4;
              break;
            case ShaderPropertyType.Vector4:
            case ShaderPropertyType.Color:
              concretePrecision = 4;
              break;
          }
          this.slots[0]._concretePrecision = concretePrecision;
        };
        _proto.generateCode = function generateCode() {
          var code = '';
          // let prop = shaderContext.properties.find(p => p.name === this.name)
          // if (prop) {
          //     this.outputs.forEach((o, i) => {
          //         if (o.connectSlot) {
          //             o.value = prop.value;
          //             code += `${this.getOutputVarDefine(i)} = ${this.name};\n`
          //         }
          //     })
          // }

          return code;
        };
        return PropertyNode;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/property.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './utils.ts'], function (exports) {
  var _createClass, cclegacy, ValueType, TextureCube, Texture2D, Color, Vec4, Vec3, Vec2, slot, getValueConcretePrecision;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      ValueType = module.ValueType;
      TextureCube = module.TextureCube;
      Texture2D = module.Texture2D;
      Color = module.Color;
      Vec4 = module.Vec4;
      Vec3 = module.Vec3;
      Vec2 = module.Vec2;
    }, function (module) {
      slot = module.slot;
      getValueConcretePrecision = module.getValueConcretePrecision;
    }],
    execute: function () {
      cclegacy._RF.push({}, "b05a8ea74hDTb7wArT51Kxn", "property", undefined);
      var ShaderPropertyType = exports('ShaderPropertyType', /*#__PURE__*/function (ShaderPropertyType) {
        ShaderPropertyType["Float"] = "Float";
        ShaderPropertyType["Boolean"] = "Boolean";
        ShaderPropertyType["Vector2"] = "Vector2";
        ShaderPropertyType["Vector3"] = "Vector3";
        ShaderPropertyType["Vector4"] = "Vector4";
        ShaderPropertyType["Color"] = "Color";
        ShaderPropertyType["Texture2D"] = "Texture2D";
        ShaderPropertyType["TextureCube"] = "TextureCube";
        return ShaderPropertyType;
      }({})); // Gradient = 'Gradient',
      // Matrix2 = 'Matrix2',
      // Matrix3 = 'Matrix3',
      // Matrix4 = 'Matrix4',
      var ShaderProperty = exports('ShaderProperty', /*#__PURE__*/function () {
        function ShaderProperty(type) {
          this.details = {
            menu: '',
            // -> IBlockStyle,
            style: {
              headerColor: '#ec7063'
            }
            // feature: { } // -> IBlockFeature,
          };

          this.name = '';
          this.type = ShaderPropertyType.Float;
          this.value = 0;
          this.outputs = [];
          if (typeof type === 'string') {
            this.type = ShaderPropertyType[type];
          } else {
            this.type = type;
          }
          this.name = ShaderPropertyType[type];
          this.details.menu = this.name;
          this.updateDefaultValue();
        }
        var _proto = ShaderProperty.prototype;
        _proto.setValue = function setValue(value) {
          if (this.value instanceof ValueType) {
            this.value.set(value);
          } else if (this.type === ShaderPropertyType.Texture2D || this.type === ShaderPropertyType.TextureCube) {
            this.value._uuid = value.uuid;
          } else {
            this.value = value;
          }
        };
        _proto.updateDefaultValue = function updateDefaultValue() {
          switch (this.type) {
            case ShaderPropertyType.Float:
              this.value = 0;
              this.outputs = [slot('Out', this.value, 'float', 'vector')];
              break;
            case ShaderPropertyType.Boolean:
              this.value = false;
              this.outputs = [slot('Out', this.value, 'boolean', 'boolean')];
              break;
            case ShaderPropertyType.Vector2:
              this.value = new Vec2();
              this.outputs = [slot('Out', this.value, 'vec2', 'vector')];
              break;
            case ShaderPropertyType.Vector3:
              this.value = new Vec3();
              this.outputs = [slot('Out', this.value, 'vec3', 'vector')];
              break;
            case ShaderPropertyType.Vector4:
              this.value = new Vec4();
              this.outputs = [slot('Out', this.value, 'vec4', 'vector')];
              break;
            case ShaderPropertyType.Color:
              this.value = new Color();
              this.outputs = [slot('Out', this.value, 'color', 'vector')];
              break;
            case ShaderPropertyType.Texture2D:
              this.value = new Texture2D();
              this.outputs = [slot('Out', this.value, 'texture2D', 'texture2D')];
              break;
            case ShaderPropertyType.TextureCube:
              this.value = new TextureCube();
              this.outputs = [slot('Out', this.value, 'textureCube', 'textureCube')];
              break;
          }
        };
        _proto.isTexture = function isTexture() {
          switch (this.type) {
            case ShaderPropertyType.Texture2D:
            case ShaderPropertyType.TextureCube:
              return true;
          }
          return false;
        };
        _createClass(ShaderProperty, [{
          key: "concretePrecision",
          get: function get() {
            return getValueConcretePrecision(this.value);
          }
        }]);
        return ShaderProperty;
      }());
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/radians-to-degrees.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "122290sL5ZBopCyAP2bpg8T", "radians-to-degrees", undefined);
      var RadiansToDegrees = exports('default', (_dec = register({
        menu: 'Math/Trigonometry/RadiansToDegrees',
        title: 'RadiansToDegrees'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(RadiansToDegrees, _ShaderNode);
        function RadiansToDegrees() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = RadiansToDegrees.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = degrees(" + input0 + ");\n        ";
        };
        return RadiansToDegrees;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/random-range.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec2, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec2 = module.Vec2;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "33710RUTT1JXZDzqyhgRRxS", "random-range", undefined);
      var RandomRange = exports('default', (_dec = register({
        menu: 'Math/Range/RandomRange',
        title: 'RandomRange'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(RandomRange, _ShaderNode);
        function RandomRange() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.depChunks = ['range'];
          _this.data = {
            inputs: [slot('seed', Vec2.ZERO, 'vec2', 'vector'), slot('minv', 0, 'float', 'vector'), slot('maxv', 0, 'float', 'vector')],
            outputs: [slot('Out', 0, 'float', 'vector')]
          };
          return _this;
        }
        var _proto = RandomRange.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var input2 = this.getInputValue(2);
          var output0 = this.getOutputVarDefine(0);
          return output0 + " = RandomRange(" + input0 + ", " + input1 + ", " + input2 + ");";
        };
        return RandomRange;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/reciprocal-square.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "eae1erXirxEXq46sl0FpxV0", "reciprocal-square", undefined);
      var ReciprocalSquare = exports('default', (_dec = register({
        menu: 'Math/Advanced/ReciprocalSquare',
        title: 'ReciprocalSquare'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(ReciprocalSquare, _ShaderNode);
        function ReciprocalSquare() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = ReciprocalSquare.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = 1. / (" + input0 + " * " + input0 + ");\n        ";
        };
        return ReciprocalSquare;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/reciprocal.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "5e330r2wGBAfouLL0jpsqul", "reciprocal", undefined);
      var Reciprocal = exports('default', (_dec = register({
        menu: 'Math/Advanced/Reciprocal',
        title: 'Reciprocal'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Reciprocal, _ShaderNode);
        function Reciprocal() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Reciprocal.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = 1. / " + input0 + ";\n        ";
        };
        return Reciprocal;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/rectangle.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec2, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec2 = module.Vec2;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "c5bfexyH39Fw4zoC+a2iqVE", "rectangle", undefined);
      var Rectangle = exports('default', (_dec = register({
        menu: 'Procedural/Shape/Rectangle',
        title: 'Rectangle'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Rectangle, _ShaderNode);
        function Rectangle() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.depChunks = ['shape'];
          _this.data = {
            inputs: [slot('uv', Vec2.ZERO, 'vec2', 'vector'), slot('width', 0.5, 'float', 'vector')],
            outputs: [slot('Out', 0, 'float', 'vector')]
          };
          return _this;
        }
        var _proto = Rectangle.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          if (!this.inputs[0].connectSlot) {
            input0 = 'v_uv.xy';
          }
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return output0 + " = Rectangle(" + input0 + ", " + input1 + ");";
        };
        return Rectangle;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/reflection.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "83264s8H2BKlb81PIs6fbLm", "reflection", undefined);
      var Reflection = exports('default', (_dec = register({
        menu: 'Math/Vector/Reflection',
        title: 'Reflection'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Reflection, _ShaderNode);
        function Reflection() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector'), slot('Normal', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Reflection.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = reflect(" + input0 + ", " + input1 + ");\n        ";
        };
        return Reflection;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/register-local-var.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './base.ts', './utils.ts', './index3.ts', './register.ts'], function (exports) {
  var _inheritsLoose, _createClass, cclegacy, Vec4, ShaderNode, prop, slot, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      prop = module.prop;
      slot = module.slot;
    }, null, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "b61a9DvFcxESK2/fNFtqY0h", "register-local-var", undefined);
      var RegisterLocalVar = exports('default', (_dec = register({
        menu: 'Input/Variable/RegisterLocalVar',
        title: 'RegisterLocalVar'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(RegisterLocalVar, _ShaderNode);
        function RegisterLocalVar() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.isRegisterLocalVar = true;
          _this.data = {
            props: [prop('Name', 'local_var', 'string', {
              registerEnumType: 'RegisterLocalVarName'
            })],
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = RegisterLocalVar.prototype;
        _proto.generateCode = function generateCode() {
          return '';

          // const name = this.getPropWithName('Name');
          // const precisionName = this.inputs[0].connectSlot.precisionName;
          // return `${precisionName} ${name.value}= ${this.getInputValue(0)};`;
        };

        _createClass(RegisterLocalVar, [{
          key: "name",
          get: function get() {
            var name = this.getPropWithName('Name');
            return name.value;
          },
          set: function set(v) {
            var name = this.getPropWithName('Name');
            name.value = v;
          }
        }]);
        return RegisterLocalVar;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/register.ts", ['cc', './property.ts'], function (exports) {
  var cclegacy, ShaderPropertyType, ShaderProperty;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      ShaderPropertyType = module.ShaderPropertyType;
      ShaderProperty = module.ShaderProperty;
    }],
    execute: function () {
      exports('register', register);
      cclegacy._RF.push({}, "663baRF6QZFi6zhc8Qt66NF", "register", undefined);
      var shaderNodeMap = exports('shaderNodeMap', new Map());
      var shaderPropertyMap = exports('shaderPropertyMap', new Map());
      var shaderNodeClassMap = exports('shaderNodeClassMap', new Map());

      /**
       *  dump 
       * @param options
       */

      function register(options) {
        return function (sclass) {
          var nodeCls = new sclass();
          var extend = Object.getPrototypeOf(nodeCls.constructor).name;
          var nodeDefine = {
            type: nodeCls.type,
            extend: extend,
            details: options,
            node: nodeCls.data
          };
          if (nodeCls.type === 'PropertyNode') {
            collectShaderProperty(nodeCls.type);
          }
          shaderNodeClassMap.set(nodeCls.type, sclass);
          shaderNodeMap.set(nodeCls.type, nodeDefine);
        };
      }

      /**
       *  ShaderProperty 
       * @param declareType -  Block 
       */
      function collectShaderProperty(declareType) {
        //  property
        shaderPropertyMap.clear();
        for (var key in ShaderPropertyType) {
          var type = ShaderPropertyType[key];
          if (typeof type === 'string') {
            var shaderProperty = new ShaderProperty(type);
            shaderProperty.type = type;
            shaderPropertyMap.set(type, {
              type: type,
              declareType: declareType,
              name: shaderProperty.name,
              outputs: shaderProperty.outputs,
              "default": shaderProperty.value,
              details: shaderProperty.details
            });
          }
        }
      }
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/rejection.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "36176dcQhhIm7tg8pihGhm0", "rejection", undefined);
      var Rejection = exports('default', (_dec = register({
        menu: 'Math/Vector/Rejection',
        title: 'Rejection'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Rejection, _ShaderNode);
        function Rejection() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Rejection.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = " + input0 + " - (" + input1 + " * dot(" + input0 + ", " + input1 + ") / dot(" + input1 + ", " + input1 + "))\n        ";
        };
        return Rejection;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ReleaseManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Manager.ts', './enum.ts', './ScrollManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _createClass, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Manager, ReleaseState, ScrollManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _createClass = module.createClass;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
    }, function (module) {
      Manager = module.Manager;
    }, function (module) {
      ReleaseState = module.ReleaseState;
    }, function (module) {
      ScrollManager = module.ScrollManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _class3;
      cclegacy._RF.push({}, "797a5chXbhC64OnuHlVCMHV", "ReleaseManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var Event = /*#__PURE__*/function (Event) {
        Event[Event["ON_PULL_UP"] = 0] = "ON_PULL_UP";
        Event[Event["ON_PULL_DOWN"] = 1] = "ON_PULL_DOWN";
        Event[Event["ON_PULL_LEFT"] = 2] = "ON_PULL_LEFT";
        Event[Event["ON_PULL_RIGHT"] = 3] = "ON_PULL_RIGHT";
        return Event;
      }(Event || {});
      var ReleaseManager = exports('ReleaseManager', (_dec = ccclass('ReleaseManager'), _dec2 = property("boolean"), _dec3 = property({
        range: [0, 1],
        slide: true,
        step: 0.01,
        visible: function visible() {
          return this.enabled;
        },
        tooltip: "state"
      }), _dec4 = property({
        range: [0, 1],
        slide: true,
        step: 0.01,
        visible: function visible() {
          return this.enabled;
        },
        tooltip: "state"
      }), _dec5 = property({
        range: [0, 1],
        slide: true,
        step: 0.01,
        visible: function visible() {
          return this.enabled;
        },
        tooltip: "state"
      }), _dec6 = property({
        range: [0, 1],
        slide: true,
        step: 0.01,
        visible: function visible() {
          return this.enabled;
        },
        tooltip: "state"
      }), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Manager) {
        _inheritsLoose(ReleaseManager, _Manager);
        function ReleaseManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Manager.call.apply(_Manager, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "_enabled", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "left", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "right", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "top", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "bottom", _descriptor5, _assertThisInitialized(_this));
          _this._pullUp = void 0;
          _this._pullDown = void 0;
          _this._pullLeft = void 0;
          _this._pullRight = void 0;
          return _this;
        }
        var _proto = ReleaseManager.prototype;
        _proto.onInit = function onInit() {
          if (!this.enabled) return;
          this._pullUp = new ReleaseEvent(this, Event.ON_PULL_UP, this.bottom);
          this._pullDown = new ReleaseEvent(this, Event.ON_PULL_DOWN, this.top);
          this._pullLeft = new ReleaseEvent(this, Event.ON_PULL_LEFT, this.right);
          this._pullRight = new ReleaseEvent(this, Event.ON_PULL_RIGHT, this.left);
          this.adapter.scrollManager.on(ScrollManager.Event.ON_SCROLL_START, this.onScrollStart, this);
          this.adapter.scrollManager.on(ScrollManager.Event.ON_SCROLL_END, this.onScrollEnd, this);
          this.adapter.scrollManager.on(ScrollManager.Event.ON_SCROLL_CANCEL, this.onScrollEnd, this);
          this.checkLoop();
        };
        _proto.checkLoop = function checkLoop() {
          if (this.adapter.isHorizontal) {
            if (this.adapter.isArrangeAxisStart) {
              if (this.left > 0) {
                this.adapter.viewManager.loopHeader = false;
              }
              if (this.right > 0) {
                this.adapter.viewManager.loopFooter = false;
              }
            } else {
              if (this.left > 0) {
                this.adapter.viewManager.loopFooter = false;
              }
              if (this.right > 0) {
                this.adapter.viewManager.loopHeader = false;
              }
            }
          } else {
            if (this.adapter.isArrangeAxisStart) {
              if (this.top > 0) {
                this.adapter.viewManager.loopHeader = false;
              }
              if (this.bottom > 0) {
                this.adapter.viewManager.loopFooter = false;
              }
            } else {
              if (this.top > 0) {
                this.adapter.viewManager.loopFooter = false;
              }
              if (this.bottom > 0) {
                this.adapter.viewManager.loopHeader = false;
              }
            }
          }
        };
        _proto.onScrollStart = function onScrollStart() {
          if (this.adapter.isHorizontal) {
            if (this.left > 0) {
              this._pullRight["_setState"](ReleaseState.IDLE);
            }
            if (this.right > 0) {
              this._pullLeft["_setState"](ReleaseState.IDLE);
            }
          } else {
            if (this.top > 0) {
              this._pullDown["_setState"](ReleaseState.IDLE);
            }
            if (this.bottom > 0) {
              this._pullUp["_setState"](ReleaseState.IDLE);
            }
          }
        };
        _proto.onScrollEnd = function onScrollEnd() {
          if (this.adapter.isHorizontal) {
            if (this.left > 0) {
              this._pullRight["_setState"](ReleaseState.RELEASE);
            }
            if (this.right > 0) {
              this._pullLeft["_setState"](ReleaseState.RELEASE);
            }
          } else {
            if (this.top > 0) {
              this._pullDown["_setState"](ReleaseState.RELEASE);
            }
            if (this.bottom > 0) {
              this._pullUp["_setState"](ReleaseState.RELEASE);
            }
          }
        }
        /** @deprecated  */;
        _proto.internal_lateUpdate = function internal_lateUpdate(deltaTime) {
          if (!this.enabled) return;
          var offset = this.adapter.scrollManager.boundaryOffset;
          if (!this.adapter.scrollManager.dragging) {
            offset = 0;
          }
          if (this.adapter.isHorizontal) {
            if (this.left > 0) {
              this._pullRight["_set"](Math.max(-offset, 0), offset < 0);
            }
            if (this.right > 0) {
              this._pullLeft["_set"](Math.max(offset, 0), offset > 0);
            }
          } else {
            if (this.top > 0) {
              this._pullDown["_set"](Math.max(offset, 0), offset > 0);
            }
            if (this.bottom > 0) {
              this._pullUp["_set"](Math.max(-offset, 0), offset < 0);
            }
          }
        };
        _createClass(ReleaseManager, [{
          key: "enabled",
          get: function get() {
            return this._enabled;
          },
          set: function set(value) {
            if (value == this._enabled) return;
            this._enabled = value;
          }
        }, {
          key: "max",
          get: function get() {
            if (!this.enabled) return 0;
            if (this.adapter.isHorizontal) {
              return this._pullLeft ? this._pullLeft.expand : 0;
            } else {
              return this._pullDown ? this._pullDown.expand : 0;
            }
          }
        }, {
          key: "min",
          get: function get() {
            if (!this.enabled) return 0;
            if (this.adapter.isHorizontal) {
              return this._pullRight ? this._pullRight.expand : 0;
            } else {
              return this._pullUp ? this._pullUp.expand : 0;
            }
          }
        }]);
        return ReleaseManager;
      }(Manager), _class3.Event = Event, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "_enabled", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "enabled", [_dec2], Object.getOwnPropertyDescriptor(_class2.prototype, "enabled"), _class2.prototype), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "left", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "right", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "top", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "bottom", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class2)) || _class));
      /**  */
      var ReleaseEvent = exports('ReleaseEvent', /*#__PURE__*/function () {
        function ReleaseEvent(manager, event, defaultPercentage) {
          this._expand = 0;
          this._progress = 0;
          this._offset = 0;
          this._state = void 0;
          this._defaultPercentage = void 0;
          this._manager = void 0;
          this._event = void 0;
          this._stop = void 0;
          this._defaultPercentage = defaultPercentage;
          this._manager = manager;
          this._event = event;
        }
        var _proto2 = ReleaseEvent.prototype;
        _proto2._set = function _set(offset, isContinue) {
          if (isContinue) {
            this._stop = false;
          }
          if (this._stop) return;
          this._offset = offset;
          this._progress = offset / (this._defaultPercentage * this._manager.adapter.mainAxisSize);
          this._stop = this._offset <= 0.1;
          this._setState(ReleaseState.PULL);
          this._manager.emit(this._event, this);
        };
        _proto2._setState = function _setState(value) {
          if (this._state == ReleaseState.WAIT) {
            return;
          }
          if (value == ReleaseState.PULL && this._state == ReleaseState.RELEASE) {
            return;
          }
          this._state = value;
        }
        /**
         * 
         * @param expandSize 
         */;
        _proto2.wait = function wait(expandSize) {
          if (expandSize === void 0) {
            expandSize = this._defaultPercentage * this._manager.adapter.mainAxisSize;
          }
          this._expand = expandSize;
          this._state = ReleaseState.WAIT;
        }
        /**
         * 
         */;
        _proto2.release = function release() {
          this._expand = 0;
          this._state = ReleaseState.IDLE;
          if (this.offset <= 0.1) {
            this._offset = 0;
            this._progress = 0;
            this._manager.emit(this._event, this);
          }
        };
        _createClass(ReleaseEvent, [{
          key: "expand",
          get: function get() {
            return this._expand;
          }
        }, {
          key: "progress",
          get: function get() {
            return this._progress;
          }
        }, {
          key: "offset",
          get: function get() {
            return this._offset;
          }
        }, {
          key: "state",
          get: function get() {
            return this._state;
          }
        }]);
        return ReleaseEvent;
      }());
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/remap.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, Vec2, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
      Vec2 = module.Vec2;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "c8987U3zUlCXZn8OW+mTz8j", "remap", undefined);
      var Remap = exports('default', (_dec = register({
        menu: 'Math/Range/Remap',
        title: 'Remap'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Remap, _ShaderNode);
        function Remap() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Max;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector'), slot('InMinMax', Vec2.ZERO, 'vec2', 'vector'), slot('OutMinMax', Vec2.ZERO, 'vec2', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Remap.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var input2 = this.getInputValue(2);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = " + input2 + ".x + (" + input0 + " - " + input1 + ".x) * (" + input2 + ".y - " + input2 + ".x) / (" + input1 + ".y - " + input1 + ".x);\n        ";
        };
        return Remap;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/resourceUtil.ts", ['cc'], function (exports) {
  var cclegacy, _decorator, resources, error, Prefab, SpriteFrame, Texture2D, instantiate, find, isValid, SpriteAtlas;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      resources = module.resources;
      error = module.error;
      Prefab = module.Prefab;
      SpriteFrame = module.SpriteFrame;
      Texture2D = module.Texture2D;
      instantiate = module.instantiate;
      find = module.find;
      isValid = module.isValid;
      SpriteAtlas = module.SpriteAtlas;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "f11da56ne5J4oRL4Avag26V", "resourceUtil", undefined);
      var ccclass = _decorator.ccclass;
      var resourceUtil = exports('resourceUtil', (_dec = ccclass("resourceUtil"), _dec(_class = (_class2 = /*#__PURE__*/function () {
        function resourceUtil() {}
        resourceUtil.loadRes = function loadRes(url, type, cb) {
          var _this = this;
          if (cb === void 0) {
            cb = function cb() {};
          }
          if (this.resLoadedMap.has(url)) {
            cb && cb(null, this.resLoadedMap.get(url));
            return;
          }
          resources.load(url, function (err, res) {
            if (err) {
              error(err.message || err);
              cb(err, res);
              return;
            }
            if (!res) {
              error("res not found");
              cb("res not found", res);
              return;
            }
            _this.resLoadedMap.set(url, res);
            cb && cb(null, res);
          });
        };
        resourceUtil.loadResNoCache = function loadResNoCache(url, type, cb) {
          var _this2 = this;
          if (cb === void 0) {
            cb = function cb() {};
          }
          resources.load(url, function (err, res) {
            if (err) {
              error(err.message || err);
              cb(err, res);
              return;
            }
            _this2.resLoadedMap.set(url, res);
            cb && cb(null, res);
          });
        };
        resourceUtil.loadEffectRes = function loadEffectRes(modulePath) {
          var _this3 = this;
          return new Promise(function (resolve, reject) {
            _this3.loadRes("prefab/effect/" + modulePath, Prefab, function (err, prefab) {
              if (err) {
                console.error('effect load failed', modulePath);
                reject && reject();
                return;
              }
              resolve && resolve(prefab);
            });
          });
        };
        resourceUtil.loadModelResArr = function loadModelResArr(path, arrName, progressCb, completeCb) {
          var arrUrls = arrName.map(function (item) {
            return path + "/" + item;
          });
          resources.load(arrUrls, Prefab, progressCb, completeCb);
        };
        resourceUtil.loadResArr = function loadResArr(arrName, progressCb, completeCb) {
          resources.load(arrName, Prefab, progressCb, completeCb);
        };
        resourceUtil.loadSpriteFrameRes = function loadSpriteFrameRes(path) {
          var _this4 = this;
          return new Promise(function (resolve, reject) {
            _this4.loadRes(path, SpriteFrame, function (err, img) {
              if (err) {
                console.error('spriteFrame load failed!', path, err);
                reject && reject();
                return;
              }
              var texture = new Texture2D();
              texture.image = img;
              var sf = new SpriteFrame();
              sf.texture = texture;
              resolve && resolve(sf);
            });
          });
        };
        resourceUtil.getMap = function getMap(level, cb) {
          var levelStr = 'map';
          if (level >= 100) {
            levelStr += level;
          } else if (level >= 10) {
            levelStr += '0' + level;
          } else {
            levelStr += '00' + level;
          }
          this.loadRes("map/config/" + levelStr, null, function (err, txtAsset) {
            if (err) {
              cb(err, txtAsset);
              return;
            }
            var content = '';
            if (txtAsset._file) {
              //@ts-ignore
              if (window['LZString']) {
                //@ts-ignore
                content = window['LZString'].decompressFromEncodedURIComponent(txtAsset._file);
              }
              var objJson = JSON.parse(content);
              cb(null, objJson);
            } else if (txtAsset.text) {
              //@ts-ignore
              if (window['LZString']) {
                //@ts-ignore
                content = window['LZString'].decompressFromEncodedURIComponent(txtAsset.text);
              }
              var objJson = JSON.parse(content);
              cb(null, objJson);
            } else if (txtAsset.json) {
              cb(null, txtAsset.json);
            } else {
              cb('failed');
            }
          });
        };
        resourceUtil.getMapObj = function getMapObj(type, arrName, progressCb, completeCb) {
          var arrUrls = [];
          for (var idx = 0; idx < arrName.length; idx++) {
            arrUrls.push("map/" + type + "/" + arrName[idx]);
          }
          resources.load(arrUrls, Prefab, progressCb, completeCb);
        };
        resourceUtil.getUIPrefabRes = function getUIPrefabRes(prefabPath, cb) {
          this.loadRes("prefab/ui/" + prefabPath, Prefab, cb);
        };
        resourceUtil.createUI = function createUI(path, cb, parent, parentPath) {
          if (parentPath === void 0) {
            parentPath = "Canvas/Popup";
          }
          this.getUIPrefabRes(path, function (err, prefab) {
            if (err) return;
            var node = instantiate(prefab);
            node.setPosition(0, 0, 0);
            if (!parent) {
              parent = find(parentPath);
              if (!parent) {
                // Try to find the Canvas node in the scene
                parent = find("Canvas");
                if (!parent) {
                  // If Canvas not found, try to find it in the scene root
                  parent = find("/Canvas");
                }
                // If still not found, log an error
                if (!parent) {
                  console.error("Canvas node not found in the scene");
                }
              }
            }
            if (!parent) {
              cb && cb(null, node);
              return;
            }
            parent.addChild(node);
            cb && cb(null, node);
          });
        };
        resourceUtil.preloadUI = function preloadUI(path, cb) {
          this.getUIPrefabRes(path, function (err, prefab) {
            if (err) {
              cb && cb(err, null);
              return;
            }
            var node = instantiate(prefab);
            cb && cb(null, node);
          });
        };
        resourceUtil.getJsonData = function getJsonData(fileName, cb) {
          this.loadRes("datas/" + fileName, null, function (err, content) {
            if (err) {
              error(err.message || err);
              return;
            }
            if (content.json) {
              cb(err, content.json);
            } else {
              cb('failed!!!');
            }
          });
        };
        resourceUtil.getTextData = function getTextData(fileName, cb) {
          this.loadRes("datas/" + fileName, null, function (err, content) {
            if (err) {
              error(err.message || err);
              return;
            }
            var text = content.text;
            cb(err, text);
          });
        };
        resourceUtil.setSpriteFrame = function setSpriteFrame(path, sprite, cb) {
          resources.load(path, function (err, spriteFrame) {
            if (err) {
              error(err.message || err);
              cb(err, spriteFrame);
              return;
            }
            if (sprite && isValid(sprite)) {
              sprite.spriteFrame = spriteFrame;
              cb == null || cb(null);
            }
          });
        };
        resourceUtil.setSpriteFrameFromAtlas = function setSpriteFrameFromAtlas(pathAtlas, imgName, sprite, cb) {
          resources.load(pathAtlas, SpriteAtlas, function (err, atlas) {
            if (err) {
              console.error('set sprite frame form atlas failed! err:', pathAtlas, err);
              cb == null || cb(err);
              return;
            }
            if (sprite && isValid(sprite)) {
              var spriteFrame = atlas.getSpriteFrame(imgName);
              sprite.spriteFrame = spriteFrame;
              cb == null || cb(null);
            }
          });
        };
        resourceUtil.setSpriteFrameFromAutoAtlas = function setSpriteFrameFromAutoAtlas(pathAtlas, imgName, sprite, cb) {
          resources.load(pathAtlas + "/" + imgName, SpriteFrame, function (err, sf) {
            if (err) {
              console.error('set sprite frame form atlas failed! err:', pathAtlas, err);
              cb == null || cb(err);
              return;
            }
            if (sprite && isValid(sprite)) {
              sprite.spriteFrame = sf;
              cb == null || cb(null);
            }
          });
        };
        resourceUtil.loadAndConvertSpriteFrame = function loadAndConvertSpriteFrame(path, sprite, cb) {
          this.loadRes(path, SpriteFrame, function (err, img) {
            if (err) {
              console.error('set sprite frame failed! err:', path, err);
              cb == null || cb(err);
              return;
            }
            var texture = new Texture2D();
            texture.image = img;
            var sf = new SpriteFrame();
            sf.texture = texture;
            if (sf && isValid(sf)) {
              sprite.spriteFrame = sf;
              cb == null || cb(null);
            }
          });
        };
        resourceUtil.setSpriteFrameRenderer = function setSpriteFrameRenderer(path, sprite, cb) {
          this.loadRes(path, SpriteFrame, function (err, img) {
            if (err) {
              console.error('set sprite frame failed! err:', path, err);
              cb == null || cb(err);
              return;
            }
            var texture = new Texture2D();
            texture.image = img;
            var sf = new SpriteFrame();
            sf.texture = texture;
            if (sf && isValid(sf)) {
              sprite.spriteFrame = sf;
              cb == null || cb(null);
            }
          });
        };
        resourceUtil.loadAllResources = function loadAllResources(directory, callback) {
          resources.loadDir(directory, function (err, assets) {
            if (err) {
              console.error("Error loading resources: ", err);
              return;
            }
            callback(assets);
          });
        };
        resourceUtil.loadAllSprites = function loadAllSprites(directory, callback) {
          resources.loadDir(directory, function (err, assets) {
            if (err) {
              console.error("Error loading resources: ", err);
              return;
            }
            var spriteFrames = assets.filter(function (asset) {
              return asset instanceof SpriteFrame;
            });
            callback(spriteFrames);
          });
        };
        return resourceUtil;
      }(), _class2.resLoadedMap = new Map(), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/rotate-coordinates.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec2, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec2 = module.Vec2;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "d6912eLcHVBjrq4U/b1qppk", "rotate-coordinates", undefined);
      var RotateCoordinates = exports('default', (_dec = register({
        menu: 'Uv/RotateCoordinates',
        title: 'RotateCoordinates'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(RotateCoordinates, _ShaderNode);
        function RotateCoordinates() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.depChunks = ['uv'];
          _this.data = {
            inputs: [slot('uv', Vec2.ZERO, 'vec2', 'vector'), slot('center', Vec2.ZERO, 'vec2', 'vector'), slot('rotation', 0, 'float', 'vector')],
            outputs: [slot('Out', Vec2.ZERO, 'vec2', 'vector')]
          };
          return _this;
        }
        var _proto = RotateCoordinates.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          if (!this.inputs[0].connectSlot) {
            input0 = 'v_uv.xy';
          }
          var input1 = this.getInputValue(1);
          var input2 = this.getInputValue(2);
          var output0 = this.getOutputVarDefine(0);
          return output0 + " = RotateCoordinates(" + input0 + ", " + input1 + ", " + input2 + ");";
        };
        return RotateCoordinates;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/round-rectangle.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec2, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec2 = module.Vec2;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "ce89b57LA5CTpEIa3CV7imi", "round-rectangle", undefined);
      var RoundRectangle = exports('default', (_dec = register({
        menu: 'Procedural/Shape/RoundRectangle',
        title: 'RoundRectangle'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(RoundRectangle, _ShaderNode);
        function RoundRectangle() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.depChunks = ['shape'];
          _this.data = {
            inputs: [slot('uv', Vec2.ZERO, 'vec2', 'vector'), slot('width', 0.5, 'float', 'vector'), slot('radius', 0.1, 'float', 'vector')],
            outputs: [slot('Out', 0, 'float', 'vector')]
          };
          return _this;
        }
        var _proto = RoundRectangle.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          if (!this.inputs[0].connectSlot) {
            input0 = 'v_uv.xy';
          }
          var input1 = this.getInputValue(1);
          var input2 = this.getInputValue(2);
          var output0 = this.getOutputVarDefine(0);
          return output0 + " = RoundRectangle(" + input0 + ", " + input1 + ", " + input2 + ");";
        };
        return RoundRectangle;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/round.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "62b43+zJdRCqaCEyKSYFKtF", "round", undefined);
      var Round = exports('default', (_dec = register({
        menu: 'Math/Round/Round',
        title: 'Round'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Round, _ShaderNode);
        function Round() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Round.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = floor(" + input0 + " + 0.5);\n        ";
        };
        return Round;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/sample-cubemap.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './input-node.ts'], function (exports) {
  var _inheritsLoose, cclegacy, InputNode;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      InputNode = module.default;
    }],
    execute: function () {
      cclegacy._RF.push({}, "6f28a7ED/hGlLSDg1Rd/nOf", "sample-cubemap", undefined);
      var SampleTexture2D = exports('default', /*#__PURE__*/function (_InputNode) {
        _inheritsLoose(SampleTexture2D, _InputNode);
        function SampleTexture2D() {
          return _InputNode.apply(this, arguments) || this;
        }
        var _proto = SampleTexture2D.prototype;
        _proto.generateCode = function generateCode() {
          var _node$property;
          var cubeSlot = this.getSlotWithSlotName('Cube');
          var node = (cubeSlot == null ? void 0 : cubeSlot.connectSlot) && (cubeSlot == null ? void 0 : cubeSlot.connectSlot.node);
          if (!node) {
            return '';
          }
          var V = 'view';
          var N = 'normal';
          var viewSlot = this.getSlotWithSlotName('ViewDir');
          if (viewSlot != null && viewSlot.connectSlot) {
            V = viewSlot == null ? void 0 : viewSlot.connectSlot.varName;
          }
          var normalSlot = this.getSlotWithSlotName('Normal');
          if (normalSlot != null && normalSlot.connectSlot) {
            N = normalSlot == null ? void 0 : normalSlot.connectSlot.varName;
          }
          var R = this.getOutputVarName(0) + "_R";
          var code = '';
          code += "vec3 " + R + " = reflect( -normalize( " + V + " ), " + N + " );\n";
          code += this.getOutputVarDefine(0) + " = texture(" + ((_node$property = node.property) == null ? void 0 : _node$property.name) + ", " + R + ");\n";
          return code;
        };
        return SampleTexture2D;
      }(InputNode));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/sample-texture2d.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './input-node.ts', './utils.ts', './index3.ts', './register.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Texture2D, Vec2, Vec4, InputNode, prop, slot, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Texture2D = module.Texture2D;
      Vec2 = module.Vec2;
      Vec4 = module.Vec4;
    }, function (module) {
      InputNode = module.default;
    }, function (module) {
      prop = module.prop;
      slot = module.slot;
    }, null, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "5895aMpjJJED5bYGNm0JmUq", "sample-texture2d", undefined);
      var TextureType = /*#__PURE__*/function (TextureType) {
        TextureType[TextureType["Default"] = 0] = "Default";
        TextureType[TextureType["Normal"] = 1] = "Normal";
        return TextureType;
      }(TextureType || {});
      var TextureNormalSpace = /*#__PURE__*/function (TextureNormalSpace) {
        TextureNormalSpace[TextureNormalSpace["Tangent"] = 0] = "Tangent";
        TextureNormalSpace[TextureNormalSpace["Object"] = 1] = "Object";
        return TextureNormalSpace;
      }(TextureNormalSpace || {});
      var SampleTexture2D = exports('default', (_dec = register({
        menu: 'Input/Texture/SampleTexture2D',
        title: 'SampleTexture2D'
      }), _dec(_class = /*#__PURE__*/function (_InputNode) {
        _inheritsLoose(SampleTexture2D, _InputNode);
        function SampleTexture2D() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _InputNode.call.apply(_InputNode, [this].concat(args)) || this;
          _this.data = {
            props: [prop('TextureType', TextureType.Default, 'enum', {
              "enum": TextureType
            }), prop('NormalSpace', TextureNormalSpace.Tangent, 'enum', {
              "enum": TextureNormalSpace
            })],
            inputs: [slot('Texture', new Texture2D(), 'texture2D', 'texture2D'), slot('UV', Vec2.ZERO, 'vec2', 'vector')],
            outputs: [slot('RGBA', Vec4.ZERO, 'vec4', 'vector'), slot('R', 0, 'float', 'vector'), slot('G', 0, 'float', 'vector'), slot('B', 0, 'float', 'vector'), slot('A', 0, 'float', 'vector')]
          };
          return _this;
        }
        var _proto = SampleTexture2D.prototype;
        _proto.generateCode = function generateCode() {
          var textureSlot = this.getSlotWithSlotName('Texture');
          var uvSlot = this.getSlotWithSlotName('UV');
          var rgbaSlot = this.getSlotWithSlotName('RGBA');
          var rgbaVarName = rgbaSlot == null ? void 0 : rgbaSlot.varName;
          var code;
          if (!(textureSlot != null && textureSlot.connectSlot)) {
            code = "vec4 " + rgbaVarName + " = vec4(1.);\n";
          } else {
            var uv;
            if (!uvSlot.connectSlot) {
              uv = 'v_uv';
            } else {
              uv = uvSlot.slotValue;
            }
            code = "vec4 " + rgbaVarName + " = texture(" + (textureSlot == null ? void 0 : textureSlot.connectSlot.varName) + ", " + uv + ");\n";
          }
          var textureType = this.getPropWithName('TextureType');
          var normalSpace = this.getPropWithName('NormalSpace');
          if (textureType.value === TextureType.Normal && normalSpace.value === TextureNormalSpace.Tangent) {
            code += rgbaVarName + ".xyz -= vec3(0.5);\n";
            code += rgbaVarName + ".xyz = \n";
            code += "  " + rgbaVarName + ".x * normalize(worldTangent) +\n";
            code += "  " + rgbaVarName + ".y * normalize(worldBinormal) +\n";
            code += "  " + rgbaVarName + ".z * normalize(worldNormal);\n";
            this.defines.push('CC_SURFACES_USE_TANGENT_SPACE');
          }
          var r = this.getSlotWithSlotName('R');
          if (r && r.connectSlot) {
            code += "float " + r.varName + " = " + rgbaVarName + ".r;\n";
          }
          var g = this.getSlotWithSlotName('G');
          if (g && g.connectSlot) {
            code += "float " + g.varName + " = " + rgbaVarName + ".g;\n";
          }
          var b = this.getSlotWithSlotName('B');
          if (b && b.connectSlot) {
            code += "float " + b.varName + " = " + rgbaVarName + ".b;\n";
          }
          var a = this.getSlotWithSlotName('A');
          if (a && a.connectSlot) {
            code += "float " + a.varName + " = " + rgbaVarName + ".a;\n";
          }
          return code;
        };
        return SampleTexture2D;
      }(InputNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/saturate.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "28c0baw9D1DwrDezfnwuGKN", "saturate", undefined);
      var Saturate = exports('default', (_dec = register({
        menu: 'Math/Range/Saturate',
        title: 'Saturate'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Saturate, _ShaderNode);
        function Saturate() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Saturate.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = saturate(" + input0 + ");\n        ";
        };
        return Saturate;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/sawtooth-wave.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "00c7bwAaf9HZYpgf9WzhbZa", "sawtooth-wave", undefined);
      var SawtoothWave = exports('default', (_dec = register({
        menu: 'Math/Wave/SawtoothWave',
        title: 'SawtoothWave'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(SawtoothWave, _ShaderNode);
        function SawtoothWave() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = SawtoothWave.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = 2 * (" + input0 + " - floor(0.5 + " + input0 + "));\n        ";
        };
        return SawtoothWave;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/SceneDefine.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "a4ed0rV6NNLHYnS0I+Yctb7", "SceneDefine", undefined);
      var SCENE_NAME = exports('SCENE_NAME', {
        HOME: "Home",
        AUDITION: "Audition",
        MT: "MagicTile",
        PITCH: "Pitch",
        KARAOKE: "Karaoke"
      });
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ScoreManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './TapValidator.ts', './Tile.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Label, Component, TapValidator, HitRating;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Label = module.Label;
      Component = module.Component;
    }, function (module) {
      TapValidator = module.TapValidator;
    }, function (module) {
      HitRating = module.HitRating;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9;
      cclegacy._RF.push({}, "9daf9azaSJIKJ3U9ri2+dcr", "ScoreManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * ScoreManager for Magic Tiles 3
       * Handles score calculation, tracking, and display
       */
      var ScoreManager = exports('ScoreManager', (_dec = ccclass('ScoreManager'), _dec2 = property(TapValidator), _dec3 = property(Label), _dec4 = property(Label), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(ScoreManager, _Component);
        function ScoreManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Reference to the tap validator
          _initializerDefineProperty(_this, "tapValidator", _descriptor, _assertThisInitialized(_this));
          // UI references
          _initializerDefineProperty(_this, "scoreLabel", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "accuracyLabel", _descriptor3, _assertThisInitialized(_this));
          // Score settings
          _initializerDefineProperty(_this, "perfectScore", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "goodScore", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "okScore", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "missScore", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "maxComboBonus", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "accuracyBonus", _descriptor9, _assertThisInitialized(_this));
          // Current score data
          _this.currentScore = 0;
          _this.finalScore = 0;
          _this.isTracking = false;
          _this.highScores = new Map();
          // Callbacks
          _this.onScoreChangedCallback = null;
          return _this;
        }
        var _proto = ScoreManager.prototype;
        _proto.onLoad = function onLoad() {
          // Initialize score display
          this.updateScoreDisplay();

          // Register for rating events to update score in real-time
          if (this.tapValidator) {
            this.tapValidator.onRating(this.onRatingEvent.bind(this));
          }
        }

        /**
         * Start tracking score
         */;
        _proto.startTracking = function startTracking() {
          this.resetScore();
          this.isTracking = true;
        }

        /**
         * Pause score tracking
         */;
        _proto.pauseTracking = function pauseTracking() {
          this.isTracking = false;
        }

        /**
         * Resume score tracking
         */;
        _proto.resumeTracking = function resumeTracking() {
          this.isTracking = true;
        }

        /**
         * Stop tracking and finalize the score
         */;
        _proto.stopTracking = function stopTracking() {
          this.isTracking = false;
          this.finalizeScore();
        }

        /**
         * Reset the score to zero
         */;
        _proto.resetScore = function resetScore() {
          this.currentScore = 0;
          this.finalScore = 0;
          this.updateScoreDisplay();
        }

        /**
         * Handle a rating event and update the score
         */;
        _proto.onRatingEvent = function onRatingEvent(lane, rating) {
          if (!this.isTracking) return;

          // Add points based on the rating
          var points = 0;
          switch (rating) {
            case HitRating.PERFECT:
              points = this.perfectScore;
              break;
            case HitRating.GREAT:
              points = this.goodScore;
              break;
            case HitRating.COOL:
              points = this.okScore;
              break;
            case HitRating.MISS:
              points = this.missScore;
              break;
          }

          // Apply combo multiplier (bonus for consecutive hits)
          var combo = this.tapValidator.getCombo();
          if (combo > 1) {
            // Increase points by up to 50% for higher combos
            var comboMultiplier = 1 + Math.min(combo / 100, 0.5);
            points = Math.round(points * comboMultiplier);
          }

          // Add points to the current score
          this.addScore(points);
        }

        /**
         * Add points to the current score
         */;
        _proto.addScore = function addScore(points) {
          if (!this.isTracking) return;
          this.currentScore += points;
          this.updateScoreDisplay();

          // Notify listeners
          if (this.onScoreChangedCallback) {
            this.onScoreChangedCallback(this.currentScore);
          }
        }

        /**
         * Update the score display
         */;
        _proto.updateScoreDisplay = function updateScoreDisplay() {
          if (this.scoreLabel) {
            this.scoreLabel.string = this.formatScore(this.currentScore);
          }
          if (this.accuracyLabel && this.tapValidator) {
            var accuracy = this.tapValidator.getAccuracy();
            this.accuracyLabel.string = accuracy + "%";
          }
        }

        /**
         * Format the score for display
         */;
        _proto.formatScore = function formatScore(score) {
          return score.toLocaleString();
        }

        /**
         * Calculate and finalize the score when the game ends
         */;
        _proto.finalizeScore = function finalizeScore() {
          if (!this.tapValidator) {
            this.finalScore = this.currentScore;
            return;
          }

          // Get performance metrics
          var accuracy = this.tapValidator.getAccuracy();
          var maxCombo = this.tapValidator.getMaxCombo();
          var ratingCounts = this.tapValidator.getRatingCounts();
          var totalNotes = this.tapValidator.getTotalNotes();

          // Base score from tap ratings
          var baseScore = this.currentScore;

          // Add combo bonus
          var maxPossibleCombo = totalNotes;
          var comboPercentage = maxPossibleCombo > 0 ? maxCombo / maxPossibleCombo : 0;
          var comboBonus = Math.round(this.maxComboBonus * comboPercentage);

          // Add accuracy bonus
          var accuracyBonus = Math.round(this.accuracyBonus * (accuracy / 100));

          // Final score calculation
          this.finalScore = baseScore + comboBonus + accuracyBonus;

          // Console log for debugging
          console.log("Score Breakdown:");
          console.log("Base Score: " + baseScore);
          console.log("Combo Bonus (" + maxCombo + "x): " + comboBonus);
          console.log("Accuracy Bonus (" + accuracy + "%): " + accuracyBonus);
          console.log("Final Score: " + this.finalScore);

          // Update high score if applicable
          this.checkHighScore();
        }

        /**
         * Check if this is a new high score
         */;
        _proto.checkHighScore = function checkHighScore() {
          // This would typically use the beatmap ID as the key
          var beatmapId = "current"; // Placeholder

          if (!this.highScores.has(beatmapId) || this.finalScore > this.highScores.get(beatmapId)) {
            this.highScores.set(beatmapId, this.finalScore);
            return true;
          }
          return false;
        }

        /**
         * Get the current score
         */;
        _proto.getCurrentScore = function getCurrentScore() {
          return this.currentScore;
        }

        /**
         * Get the final score
         */;
        _proto.getFinalScore = function getFinalScore() {
          return this.finalScore;
        }

        /**
         * Register a callback for score changes
         */;
        _proto.onScoreChanged = function onScoreChanged(callback) {
          this.onScoreChangedCallback = callback;
        }

        /**
         * Get the high score for a beatmap
         */;
        _proto.getHighScore = function getHighScore(beatmapId) {
          return this.highScores.get(beatmapId) || 0;
        }

        /**
         * Save high scores to persistent storage
         */;
        _proto.saveHighScores = function saveHighScores() {
          // Convert Map to plain object for storage
          var scoreObject = {};
          this.highScores.forEach(function (score, beatmapId) {
            scoreObject[beatmapId] = score;
          });

          // Save to local storage or other persistent storage
          var scoresJSON = JSON.stringify(scoreObject);
          localStorage.setItem('magicTilesHighScores', scoresJSON);
        }

        /**
         * Load high scores from persistent storage
         */;
        _proto.loadHighScores = function loadHighScores() {
          // Load from local storage or other persistent storage
          var scoresJSON = localStorage.getItem('magicTilesHighScores');
          if (scoresJSON) {
            try {
              var scoreObject = JSON.parse(scoresJSON);

              // Convert plain object back to Map
              this.highScores.clear();
              for (var beatmapId in scoreObject) {
                if (Object.prototype.hasOwnProperty.call(scoreObject, beatmapId)) {
                  this.highScores.set(beatmapId, scoreObject[beatmapId]);
                }
              }
            } catch (e) {
              console.error('Failed to parse high scores:', e);
            }
          }
        };
        return ScoreManager;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "tapValidator", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "scoreLabel", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "accuracyLabel", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "perfectScore", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1000;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "goodScore", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 500;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "okScore", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 100;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "missScore", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "maxComboBonus", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 10000;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "accuracyBonus", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 10000;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ScrollAdapter.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './enum.ts', './CenterManager.ts', './LayoutManager.ts', './ModelManager.ts', './PageViewManager.ts', './ReleaseManager.ts', './ScrollManager.ts', './ViewManager.ts', './Holder.ts', './View.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Component, Orientation, ArrangeAxis, ViewEvent, HolderEvent, CenterManager, LayoutManager, ModelManager, PageViewManager, ReleaseManager, ScrollManager, ViewManager, Holder, View;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
    }, function (module) {
      Orientation = module.Orientation;
      ArrangeAxis = module.ArrangeAxis;
      ViewEvent = module.ViewEvent;
      HolderEvent = module.HolderEvent;
    }, function (module) {
      CenterManager = module.CenterManager;
    }, function (module) {
      LayoutManager = module.LayoutManager;
    }, function (module) {
      ModelManager = module.ModelManager;
    }, function (module) {
      PageViewManager = module.PageViewManager;
    }, function (module) {
      ReleaseManager = module.ReleaseManager;
    }, function (module) {
      ScrollManager = module.ScrollManager;
    }, function (module) {
      ViewManager = module.ViewManager;
    }, function (module) {
      Holder = module.Holder;
    }, function (module) {
      View = module.View;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6;
      cclegacy._RF.push({}, "4f9c5h5sDhP/78kLerCTNfA", "ScrollAdapter", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var ScrollAdapter = exports('ScrollAdapter', (_dec = ccclass('ScrollAdapter'), _dec2 = property(ScrollManager), _dec3 = property(ViewManager), _dec4 = property(LayoutManager), _dec5 = property(PageViewManager), _dec6 = property(ReleaseManager), _dec7 = property(CenterManager), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(ScrollAdapter, _Component);
        function ScrollAdapter() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          /**
           * 
           * ScrollView
           */
          _initializerDefineProperty(_this, "scrollManager", _descriptor, _assertThisInitialized(_this));
          /**
           * 
           * item
           */
          _initializerDefineProperty(_this, "viewManager", _descriptor2, _assertThisInitialized(_this));
          /**
           *  
           * 
           */
          _initializerDefineProperty(_this, "layoutManager", _descriptor3, _assertThisInitialized(_this));
          /**
           * 
           * 
           */
          _initializerDefineProperty(_this, "pageViewManager", _descriptor4, _assertThisInitialized(_this));
          /**
           * 
           * 4   
           */
          _initializerDefineProperty(_this, "releaseManager", _descriptor5, _assertThisInitialized(_this));
          /**
           * 
           * 
           */
          _initializerDefineProperty(_this, "centerManager", _descriptor6, _assertThisInitialized(_this));
          /**
           * 
           * 
           */
          _this.modelManager = new ModelManager();
          return _this;
        }
        var _proto = ScrollAdapter.prototype;
        /** 
         *  
         *  element.wrapAfterModeelement.wrapBeforeMode
        */
        _proto.initElement = function initElement(element, data) {}
        /** 
         * View
         * 
         */;
        _proto.getView = function getView() {
          return new DefaultView(this);
        }
        /** 
         * Holder
         * 
         */;
        _proto.getHolder = function getHolder(node, code) {
          return new DefaultHolder(node, code, this);
        }
        /**  */;
        /**
         *  ScrollAdapter
         * @param node ScrollAdapternode
         * @return  ScrollAdapter
         */
        _proto.getParentAdapter = function getParentAdapter(node) {
          if (node == null) return;
          var adapter = node.getComponent("ScrollAdapter");
          if (adapter) {
            return adapter;
          }
          return this.getParentAdapter(node.parent);
        };
        _proto.__preload = function __preload() {
          this.scrollManager.internal_create(this);
          this.viewManager.internal_create(this);
          this.modelManager.internal_create(this);
          this.releaseManager.internal_create(this);
          this.layoutManager.internal_create(this);
          this.pageViewManager.internal_create(this);
          this.centerManager.internal_create(this);
          this.viewManager.internal_init();
          this.releaseManager.internal_init();
          this.layoutManager.internal_init();
          this.pageViewManager.internal_init();
          this.centerManager.internal_init();
          this.scrollManager.internal_init();
          this.modelManager.internal_init();
        };
        _proto.lateUpdate = function lateUpdate(deltaTime) {
          this.scrollManager.internal_lateUpdate(deltaTime);
          this.viewManager.internal_lateUpdate(deltaTime);
          this.layoutManager.internal_lateUpdate(deltaTime);
          this.releaseManager.internal_lateUpdate(deltaTime);
        };
        _createClass(ScrollAdapter, [{
          key: "isVertical",
          get: function get() {
            return this.scrollManager.orientation == Orientation.Vertical;
          }
          /**  */
        }, {
          key: "isHorizontal",
          get: function get() {
            return this.scrollManager.orientation == Orientation.Horizontal;
          }
          /**  */
        }, {
          key: "isArrangeAxisStart",
          get: function get() {
            return this.viewManager.arrangeAxis == ArrangeAxis.Start;
          }
          /**  | key */
        }, {
          key: "mainAxis",
          get: function get() {
            return this.isVertical ? "y" : "x";
          }
          /**  | key */
        }, {
          key: "crossAxis",
          get: function get() {
            return this.isVertical ? "x" : "y";
          }
          /**  */
        }, {
          key: "mainAxisAnchorPoint",
          get: function get() {
            var point = this.isVertical ? 1 : 0;
            return this.isArrangeAxisStart ? point : 1 - point;
          }
          /**  */
        }, {
          key: "mainAxisSize",
          get: function get() {
            return this.scrollManager.view.contentSize[this.mainAxis];
          }
          /**  */
        }, {
          key: "crossAxisSize",
          get: function get() {
            return this.scrollManager.view.contentSize[this.crossAxis];
          }
          /**  */
        }, {
          key: "multiplier",
          get: function get() {
            var multiplier = this.isVertical ? -1 : 1;
            return this.isArrangeAxisStart ? -multiplier : multiplier;
          }
          /**  Header  padding */
        }, {
          key: "paddingHeader",
          get: function get() {
            if (this.isHorizontal) {
              return this.isArrangeAxisStart ? this.viewManager.left : this.viewManager.right;
            } else {
              return this.isArrangeAxisStart ? this.viewManager.top : this.viewManager.bottom;
            }
          }
          /**  Footer  padding */
        }, {
          key: "paddingFooter",
          get: function get() {
            if (this.isHorizontal) {
              return this.isArrangeAxisStart ? this.viewManager.right : this.viewManager.left;
            } else {
              return this.isArrangeAxisStart ? this.viewManager.bottom : this.viewManager.top;
            }
          }
          /**  padding  */
        }, {
          key: "mainAxisPadding",
          get: function get() {
            if (this.isHorizontal) {
              return this.viewManager.left + this.viewManager.right;
            } else {
              return this.viewManager.top + this.viewManager.bottom;
            }
          }
        }]);
        return ScrollAdapter;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "scrollManager", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new ScrollManager();
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "viewManager", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new ViewManager();
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "layoutManager", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new LayoutManager();
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "pageViewManager", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new PageViewManager();
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "releaseManager", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new ReleaseManager();
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "centerManager", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new CenterManager();
        }
      })), _class2)) || _class));
      /** 
       * View 
       * this.adapter.node 
       *  view view holder
       *  view  holder  IElement
       */
      var DefaultView = /*#__PURE__*/function (_View) {
        _inheritsLoose(DefaultView, _View);
        function DefaultView() {
          return _View.apply(this, arguments) || this;
        }
        var _proto2 = DefaultView.prototype;
        /** view */
        _proto2.onVisible = function onVisible() {
          this.adapter.node.emit(ViewEvent.VISIBLE, this);
        }
        /** view */;
        _proto2.onDisable = function onDisable() {
          this.adapter.node.emit(ViewEvent.DISABLE, this);
        };
        return DefaultView;
      }(View);
      /** 
       * Holder  
       * itemthis.node
      */
      var DefaultHolder = /*#__PURE__*/function (_Holder) {
        _inheritsLoose(DefaultHolder, _Holder);
        function DefaultHolder() {
          return _Holder.apply(this, arguments) || this;
        }
        var _proto3 = DefaultHolder.prototype;
        _proto3.onCreated = function onCreated() {
          this.node.emit(HolderEvent.CREATED, this);
        };
        _proto3.onVisible = function onVisible() {
          this.node.emit(HolderEvent.VISIBLE, this);
        };
        _proto3.onDisable = function onDisable() {
          this.node.emit(HolderEvent.DISABLE, this);
        };
        return DefaultHolder;
      }(Holder);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/Scrollbar.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ScrollAdapter.ts', './enum.ts', './helper.ts', './ScrollManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Color, Sprite, SpriteFrame, Node, v3, UITransform, Component, Vec2, ScrollAdapter, ScrollbarDirection, Transition, Orientation, Helper, ScrollManager, ADAPTER;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Color = module.Color;
      Sprite = module.Sprite;
      SpriteFrame = module.SpriteFrame;
      Node = module.Node;
      v3 = module.v3;
      UITransform = module.UITransform;
      Component = module.Component;
      Vec2 = module.Vec2;
    }, function (module) {
      ScrollAdapter = module.ScrollAdapter;
    }, function (module) {
      ScrollbarDirection = module.ScrollbarDirection;
      Transition = module.Transition;
      Orientation = module.Orientation;
    }, function (module) {
      Helper = module.Helper;
    }, function (module) {
      ScrollManager = module.ScrollManager;
      ADAPTER = module.ADAPTER;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18;
      cclegacy._RF.push({}, "67fa5ko0UJAJpbCzgGfagdw", "Scrollbar", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var MIN_SIZE_PERCENTAGE = 0.01;
      var _tempColor = new Color();
      var Scrollbar = exports('Scrollbar', (_dec = ccclass('Scrollbar'), _dec2 = property(ScrollAdapter), _dec3 = property(Sprite), _dec4 = property({
        type: ScrollbarDirection,
        tooltip: ""
      }), _dec5 = property({
        tooltip: ""
      }), _dec6 = property({
        range: [0, 1],
        slide: true,
        step: 0.001,
        visible: function visible() {
          return this.interactable;
        },
        tooltip: "=0,,item,"
      }), _dec7 = property({
        range: [0, 1],
        slide: true,
        step: 0.001,
        visible: function visible() {
          return this.interactable;
        },
        tooltip: "=1,,item,"
      }), _dec8 = property({
        type: Transition
      }), _dec9 = property({
        type: Transition,
        visible: function visible() {
          return this.interactable;
        }
      }), _dec10 = property({
        type: Sprite,
        visible: function visible() {
          return this.transition != Transition.None && this.interactable;
        }
      }), _dec11 = property({
        type: SpriteFrame,
        visible: function visible() {
          return this.transition == Transition.SpriteSwap && this.interactable;
        }
      }), _dec12 = property({
        type: SpriteFrame,
        visible: function visible() {
          return this.transition == Transition.SpriteSwap && this.interactable;
        }
      }), _dec13 = property({
        visible: function visible() {
          return this.transition == Transition.ColorTint && this.interactable;
        }
      }), _dec14 = property({
        visible: function visible() {
          return this.transition == Transition.ColorTint && this.interactable;
        }
      }), _dec15 = property({
        visible: function visible() {
          return this.transition == Transition.Scale && this.interactable;
        }
      }), _dec16 = property({
        visible: function visible() {
          return this.transition == Transition.Scale && this.interactable;
        }
      }), _dec17 = property({
        visible: function visible() {
          return this.transition == Transition.Scale || this.transition == Transition.ColorTint && this.interactable;
        }
      }), _dec18 = property({
        range: [0, 11],
        slide: true,
        step: 1,
        tooltip: " < 2 "
      }), _dec19 = property({
        tooltip: ""
      }), _dec20 = property({
        visible: function visible() {
          return this.enableAutoHide;
        },
        tooltip: ""
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(Scrollbar, _Component);
        function Scrollbar() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "adapter", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "handle", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "direction", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "interactable", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "dragMinLimit", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "dragMaxLimit", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "_transition", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "targetGraphic", _descriptor8, _assertThisInitialized(_this));
          //#region Sprite Transition
          _initializerDefineProperty(_this, "hoverSprite", _descriptor9, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "pressedSprite", _descriptor10, _assertThisInitialized(_this));
          //#endregion
          //#region Color Transition
          _initializerDefineProperty(_this, "hoverColor", _descriptor11, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "pressedColor", _descriptor12, _assertThisInitialized(_this));
          //#endregion
          //#region Scale Transition
          _initializerDefineProperty(_this, "hoverScale", _descriptor13, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "pressedScale", _descriptor14, _assertThisInitialized(_this));
          //#endregion
          _initializerDefineProperty(_this, "transitionDuration", _descriptor15, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "numberOfSteps", _descriptor16, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "enableAutoHide", _descriptor17, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "autoHideTime", _descriptor18, _assertThisInitialized(_this));
          _this._transitionInfo = void 0;
          _this._targetEnter = void 0;
          _this._targetStart = void 0;
          _this._isDirty = false;
          _this._transform = void 0;
          _this._handleTransform = void 0;
          _this._size = 0;
          _this._value = -1;
          _this._pointerEvent = void 0;
          _this._offset = void 0;
          _this._isHide = void 0;
          _this._opacity = 255;
          _this._autoHideRemainingTime = void 0;
          _this._rawTargetScale = void 0;
          _this._rawTargetFrame = void 0;
          _this._rawTargetColor = void 0;
          return _this;
        }
        var _proto = Scrollbar.prototype;
        _proto.__preload = function __preload() {
          this.transform.setAnchorPoint(0.5, 0.5);
          this.handleTransform.setAnchorPoint(0.5, 0.5);
          this.handle.node.setPosition(0, 0);
          if (this.adapter) {
            this.adapter.scrollManager.on(ScrollManager.Event.ON_UPDATE_PERCENTAGE, this._onUpdateScrollbar, this);
            this._updateVisuals();
          }
          if (this.targetGraphic) {
            this._rawTargetScale = this.targetGraphic.node.getScale().clone();
            this._rawTargetFrame = this.targetGraphic.spriteFrame;
            this._rawTargetColor = this.targetGraphic.color.clone();
          }
          this._openAutoHide(true);
        };
        _proto.onEnable = function onEnable() {
          var renderComp = this.node.getComponent(Sprite);
          if (renderComp) {
            this._opacity = renderComp.color.a;
          }
          if (this.adapter) {
            this.node[ADAPTER] = true;
            this.node.on(Node.EventType.TOUCH_START, this._onTouchStart, this);
            this.node.on(Node.EventType.TOUCH_MOVE, this._onTouchMove, this);
            this.node.on(Node.EventType.TOUCH_END, this._onTouchEnd, this);
            this.node.on(Node.EventType.TOUCH_CANCEL, this._onTouchEnd, this);
            this.node.on(Node.EventType.MOUSE_ENTER, this._mouseEnter, this);
            this.node.on(Node.EventType.MOUSE_LEAVE, this._mouseLeave, this);
            if (this.targetGraphic) {
              this.targetGraphic.node.on(Node.EventType.MOUSE_ENTER, this._targetMouseEnter, this);
              this.targetGraphic.node.on(Node.EventType.MOUSE_LEAVE, this._targetMouseLeave, this);
            }
          }
        };
        _proto.onDisable = function onDisable() {
          this.node.off(Node.EventType.TOUCH_START, this._onTouchStart, this);
          this.node.off(Node.EventType.TOUCH_MOVE, this._onTouchMove, this);
          this.node.off(Node.EventType.TOUCH_END, this._onTouchEnd, this);
          this.node.off(Node.EventType.TOUCH_CANCEL, this._onTouchEnd, this);
          this.node.off(Node.EventType.MOUSE_ENTER, this._mouseEnter, this);
          this.node.off(Node.EventType.MOUSE_LEAVE, this._mouseLeave, this);
          if (this.targetGraphic) {
            this.targetGraphic.node.off(Node.EventType.MOUSE_ENTER, this._targetMouseEnter, this);
            this.targetGraphic.node.off(Node.EventType.MOUSE_LEAVE, this._targetMouseLeave, this);
          }
        };
        _proto._targetMouseEnter = function _targetMouseEnter() {
          this._targetEnter = true;
          this._openAutoHide(false);
          switch (this.transition) {
            case Transition.Scale:
              this._transitionScale(this._targetStart ? this.pressedScale : this.hoverScale);
              break;
            case Transition.SpriteSwap:
              this._transitionSprite(this._targetStart ? this.pressedSprite : this.hoverSprite);
              break;
            case Transition.ColorTint:
              this._transitionColor(this._targetStart ? this.pressedColor : this.hoverColor);
              break;
          }
        };
        _proto._targetMouseLeave = function _targetMouseLeave() {
          this._targetEnter = false;
          this._openAutoHide(true);
          switch (this.transition) {
            case Transition.Scale:
              this._transitionScale(this._targetStart ? this.pressedScale : this._rawTargetScale);
              break;
            case Transition.SpriteSwap:
              this._transitionSprite(this._targetStart ? this.pressedSprite : this._rawTargetFrame);
              break;
            case Transition.ColorTint:
              this._transitionColor(this._targetStart ? this.pressedColor : this._rawTargetColor);
              break;
          }
        };
        _proto._transitionScale = function _transitionScale(to) {
          if (!to || !this.targetGraphic) return;
          this._transitionInfo = {
            time: 0,
            from: this.targetGraphic.node.getScale().clone(),
            to: to
          };
        };
        _proto._transitionColor = function _transitionColor(to) {
          if (!to || !this.targetGraphic) return;
          this._transitionInfo = {
            time: 0,
            from: this.targetGraphic.color,
            to: to
          };
        };
        _proto._transitionSprite = function _transitionSprite(to) {
          if (!to || !this.targetGraphic) return;
          this.targetGraphic.spriteFrame = to;
        };
        _proto._mouseEnter = function _mouseEnter(event) {
          if (!this.interactable) return;
          this._openAutoHide(false);
        };
        _proto._mouseLeave = function _mouseLeave(event) {
          if (!this.interactable) return;
          this._openAutoHide(true);
        };
        _proto._openAutoHide = function _openAutoHide(open) {
          if (!this.enableAutoHide) return;
          this._autoHideRemainingTime = this.autoHideTime;
          this._isHide = open;
          if (!open) {
            this._setOpacity(this._opacity);
          }
        };
        _proto._onTouchStart = function _onTouchStart(event) {
          if (!this.interactable || this.size == 1 || this.size == 0) return;
          this._openAutoHide(false);
          this._pointerEvent = null;
          this._targetStart = true;
          var startCursor = event.getUIStartLocation();
          this._offset = this.handleTransform.convertToNodeSpaceAR(v3(startCursor.x, startCursor.y));
          if (Math.abs(this._offset[this.xy]) > this.handleTransform[this.wh] * 0.5) {
            this._offset = null;
            this._pointerEvent = event;
            var percentage = this._calcPercentage(event);
            this._setPercentage(percentage);
          }
          if (this.transition == Transition.Scale) {
            this._transitionScale(this.pressedScale);
          } else if (this.transition == Transition.SpriteSwap) {
            this._transitionSprite(this.pressedSprite);
          } else if (this.transition == Transition.ColorTint) {
            this._transitionColor(this.pressedColor);
          }
        };
        _proto._onTouchMove = function _onTouchMove(event) {
          if (!this.interactable || this.size == 1 || this.size == 0) return;
          if (this._offset) {
            var percentage = this._calcPercentage(event, this._offset[this.xy]);
            this._setPercentage(percentage);
          }
        };
        _proto._onTouchEnd = function _onTouchEnd(event) {
          if (!this.interactable || this.size == 1 || this.size == 0) return;
          this._offset = null;
          this._pointerEvent = null;
          this._targetStart = false;
          switch (this.transition) {
            case Transition.Scale:
              this._transitionScale(this._targetEnter ? this.hoverScale : this._rawTargetScale);
              break;
            case Transition.SpriteSwap:
              this._transitionSprite(this._targetEnter ? this.hoverSprite : this._rawTargetFrame);
              break;
            case Transition.ColorTint:
              this._transitionColor(this._targetEnter ? this.hoverColor : this._rawTargetColor);
              break;
          }
          this.adapter.centerManager.scrollToCenter();
        };
        _proto._setPercentage = function _setPercentage(percentage) {
          this.adapter.scrollManager.stopScroll();
          this.adapter.scrollManager.setPercentage(percentage);
        };
        _proto._calcPercentage = function _calcPercentage(event, offset) {
          if (offset === void 0) {
            offset = 0;
          }
          var parentSize = this.axis == Orientation.Horizontal ? this.transform.width : this.transform.height;
          var remainingSize = parentSize * (1 - this.size);
          var localCursor = event.getUILocation();
          var pos = this.transform.convertToNodeSpaceAR(v3(localCursor.x, localCursor.y));
          var handleCorner = pos[this.xy] - offset - -this.transform[this.wh] * 0.5;
          handleCorner -= this.handleTransform[this.wh] * 0.5;
          var percentage = this.adapter.scrollManager.percentage;
          switch (this.direction) {
            case ScrollbarDirection.Right_To_Left:
            case ScrollbarDirection.Top_To_Bottom:
              percentage = Helper.clamp(1 - handleCorner / remainingSize, this.dragMinLimit, this.dragMaxLimit);
              break;
            case ScrollbarDirection.Left_To_Right:
            case ScrollbarDirection.Bottom_To_Top:
              percentage = Helper.clamp(handleCorner / remainingSize, this.dragMinLimit, this.dragMaxLimit);
              break;
          }
          return this.getSteps(percentage);
        };
        _proto._onUpdateScrollbar = function _onUpdateScrollbar(percentage, offset) {
          var size = 0;
          var value = 0;
          if (this.adapter.viewManager.virtualSize > 0) {
            if (this.adapter.viewManager.virtualSize >= this.adapter.mainAxisSize) {
              size = Helper.clamp01((this.adapter.mainAxisSize - Math.abs(offset)) / this.adapter.viewManager.virtualSize);
            } else {
              size = 1;
            }
          }
          value = percentage;
          this.size = size;
          if (this.numberOfSteps > 1) {
            value = Math.round(value * (this.numberOfSteps - 1)) / (this.numberOfSteps - 1);
            value = Helper.clamp01(value);
          }
          this.value = value;
          this._autoHideRemainingTime = this.autoHideTime;
          this._setOpacity(this._opacity);
        };
        _proto._updateVisuals = function _updateVisuals() {
          if (!this.handleTransform || !this.adapter) return;
          var min = {
            x: 0,
            y: 0
          };
          var max = {
            x: 0,
            y: 0
          };
          var mainAxis = this.adapter.mainAxis;
          var movement = Helper.clamp01(this.value) * (1 - this.size);
          min[mainAxis] = movement;
          max[mainAxis] = movement + this.size;
          var header = this.transform.contentSize[this.wh] - max[mainAxis] * this.transform.contentSize[this.wh];
          var footer = min[mainAxis] * this.transform.contentSize[this.wh];
          var pos = this.handle.node.getPosition();
          switch (this.direction) {
            case ScrollbarDirection.Bottom_To_Top:
            case ScrollbarDirection.Left_To_Right:
              pos[this.xy] = (footer - header) * 0.5;
              break;
            case ScrollbarDirection.Top_To_Bottom:
            case ScrollbarDirection.Right_To_Left:
              pos[this.xy] = (header - footer) * 0.5;
              break;
          }
          this.handleTransform[this.wh] = this.transform.contentSize[this.wh] - header - footer;
          this.handle.node.setPosition(pos);
        };
        _proto.update = function update(deltaTime) {
          this._clearDirty();
          this._autoHide(deltaTime);
          this._tranitionHandler(deltaTime);
        };
        _proto._clearDirty = function _clearDirty() {
          if (this._isDirty) {
            this._isDirty = false;
            this._updateVisuals();
            if (this._pointerEvent) {
              var startCursor = this._pointerEvent.getUILocation();
              this._offset = this.handleTransform.convertToNodeSpaceAR(v3(startCursor.x, startCursor.y));
              this._pointerEvent = null;
            }
          }
        };
        _proto._autoHide = function _autoHide(deltaTime) {
          if (!this.enableAutoHide) return;
          if (!this._isHide || this._autoHideRemainingTime <= 0) return;
          this._autoHideRemainingTime -= deltaTime;
          if (this._autoHideRemainingTime <= this.autoHideTime) {
            this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
            var opacity = this._opacity * (this._autoHideRemainingTime / this.autoHideTime);
            this._setOpacity(opacity);
          }
        };
        _proto._tranitionHandler = function _tranitionHandler(deltaTime) {
          var target = this.targetGraphic;
          if (this.transition == Transition.None || !target || !this._transitionInfo) return;
          this._transitionInfo.time += deltaTime;
          var ratio = 1.0;
          if (this.transitionDuration > 0) {
            ratio = this._transitionInfo.time / this.transitionDuration;
          }
          if (ratio >= 1) {
            ratio = 1;
          }
          if (this.transition == Transition.Scale) {
            this._transitionInfo.current = target.node.getScale();
            var from = this._transitionInfo.from;
            var to = this._transitionInfo.to;
            this._transitionInfo.current.x = Helper.lerp(from.x, to.x, ratio);
            this._transitionInfo.current.y = Helper.lerp(from.y, to.y, ratio);
            target.node.setScale(this._transitionInfo.current);
          } else if (this.transition == Transition.ColorTint) {
            var _from = this._transitionInfo.from;
            var _to = this._transitionInfo.to;
            Color.lerp(_tempColor, _from, _to, ratio);
            target.color = _tempColor;
          }
          if (ratio === 1) {
            this._transitionInfo = null;
          }
        };
        _proto._setOpacity = function _setOpacity(opacity) {
          if (!this.handle) return;
          var handler = function handler(comp) {
            if (comp) {
              _tempColor.set(comp.color);
              _tempColor.a = opacity;
              comp.color = _tempColor;
            }
          };
          handler(this.node.getComponent(Sprite));
          handler(this.handle.getComponent(Sprite));
        };
        _proto.getSteps = function getSteps(percentage) {
          if (this.numberOfSteps > 1) {
            percentage = Math.round(percentage * (this.numberOfSteps - 1)) / (this.numberOfSteps - 1);
            percentage = Helper.clamp(percentage, this.dragMinLimit, this.dragMaxLimit);
          }
          return percentage;
        };
        _createClass(Scrollbar, [{
          key: "transition",
          get: function get() {
            return this._transition;
          },
          set: function set(value) {
            if (value == this._transition) return;
            this._transition = value;
            if (value != Transition.None) {
              if (!this.targetGraphic) {
                this.targetGraphic = this.handle;
              }
            }
          }
        }, {
          key: "size",
          get: function get() {
            return this._size;
          },
          set: function set(v) {
            if (v != this._size) {
              this._size = Helper.clamp(v, MIN_SIZE_PERCENTAGE, 1);
              this._isDirty = true;
            }
          }
        }, {
          key: "value",
          get: function get() {
            return this._value;
          },
          set: function set(v) {
            if (v != this._value) {
              this._value = this.getSteps(v);
              this._isDirty = true;
            }
          }
        }, {
          key: "stepSize",
          get: function get() {
            return this.numberOfSteps > 1 ? 1 / (this.numberOfSteps - 1) : 0.1;
          }
        }, {
          key: "transform",
          get: function get() {
            if (!this._transform) {
              this._transform = this.node.getComponent(UITransform);
            }
            return this._transform;
          }
        }, {
          key: "handleTransform",
          get: function get() {
            if (!this.handle) return null;
            if (!this._handleTransform) {
              this._handleTransform = this.handle.node.getComponent(UITransform);
            }
            return this._handleTransform;
          }
        }, {
          key: "xy",
          get: function get() {
            return this.axis == Orientation.Horizontal ? "x" : "y";
          }
        }, {
          key: "wh",
          get: function get() {
            return this.axis == Orientation.Horizontal ? "width" : "height";
          }
        }, {
          key: "axis",
          get: function get() {
            return this.direction == ScrollbarDirection.Left_To_Right || this.direction == ScrollbarDirection.Right_To_Left ? Orientation.Horizontal : Orientation.Vertical;
          }
        }]);
        return Scrollbar;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "adapter", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "handle", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "direction", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ScrollbarDirection.Top_To_Bottom;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "interactable", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "dragMinLimit", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "dragMaxLimit", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "_transition", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Transition.None;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "transition", [_dec9], Object.getOwnPropertyDescriptor(_class2.prototype, "transition"), _class2.prototype), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "targetGraphic", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "hoverSprite", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "pressedSprite", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "hoverColor", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Color.WHITE.clone();
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "pressedColor", [_dec14], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(211, 211, 211, 255);
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "hoverScale", [_dec15], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec2(1, 1);
        }
      }), _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, "pressedScale", [_dec16], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Vec2(1.2, 1.2);
        }
      }), _descriptor15 = _applyDecoratedDescriptor(_class2.prototype, "transitionDuration", [_dec17], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.2;
        }
      }), _descriptor16 = _applyDecoratedDescriptor(_class2.prototype, "numberOfSteps", [_dec18], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor17 = _applyDecoratedDescriptor(_class2.prototype, "enableAutoHide", [_dec19], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor18 = _applyDecoratedDescriptor(_class2.prototype, "autoHideTime", [_dec20], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ScrollManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Manager.ts', './debug.ts', './enum.ts', './helper.ts', './ViewManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Vec3, UITransform, Node, Widget, EventTouch, macro, easing, Manager, Orientation, TouchMode, MovementType, NestedDirection, ScrollDirection, Layer, Helper, ViewManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Vec3 = module.Vec3;
      UITransform = module.UITransform;
      Node = module.Node;
      Widget = module.Widget;
      EventTouch = module.EventTouch;
      macro = module.macro;
      easing = module.easing;
    }, function (module) {
      Manager = module.Manager;
    }, null, function (module) {
      Orientation = module.Orientation;
      TouchMode = module.TouchMode;
      MovementType = module.MovementType;
      NestedDirection = module.NestedDirection;
      ScrollDirection = module.ScrollDirection;
      Layer = module.Layer;
    }, function (module) {
      Helper = module.Helper;
    }, function (module) {
      ViewManager = module.ViewManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _class3;
      cclegacy._RF.push({}, "38125A9jl5DlJflB6yBKrYI", "ScrollManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var _tempPosition = new Vec3();
      var ADAPTER = exports('ADAPTER', '__ADAPTER__');
      var Event = /*#__PURE__*/function (Event) {
        Event[Event["ON_SCROLL"] = 0] = "ON_SCROLL";
        Event[Event["ON_UPDATE_PERCENTAGE"] = 1] = "ON_UPDATE_PERCENTAGE";
        Event[Event["ON_VIEW_SIZE_CHANGED"] = 2] = "ON_VIEW_SIZE_CHANGED";
        Event[Event["ON_ABOUT_TO_STOP"] = 3] = "ON_ABOUT_TO_STOP";
        Event[Event["ON_SCROLL_START"] = 4] = "ON_SCROLL_START";
        Event[Event["ON_SCROLL_END"] = 5] = "ON_SCROLL_END";
        Event[Event["ON_SCROLL_CANCEL"] = 6] = "ON_SCROLL_CANCEL";
        Event[Event["ON_CHANGED_ORIENTATION"] = 7] = "ON_CHANGED_ORIENTATION";
        Event[Event["ON_SCROLL_TO_GROUPINDEX_BEFOR"] = 8] = "ON_SCROLL_TO_GROUPINDEX_BEFOR";
        Event[Event["ON_SCROLL_TO_GROUPINDEX_AFTER"] = 9] = "ON_SCROLL_TO_GROUPINDEX_AFTER";
        Event[Event["ON_SCROLL_TO_MODELINDEX_BEFOR"] = 10] = "ON_SCROLL_TO_MODELINDEX_BEFOR";
        Event[Event["ON_SCROLL_TO_MODELINDEX_AFTER"] = 11] = "ON_SCROLL_TO_MODELINDEX_AFTER";
        return Event;
      }(Event || {});
      var ScrollManager = exports('ScrollManager', (_dec = ccclass('ScrollManager'), _dec2 = property(UITransform), _dec3 = property(UITransform), _dec4 = property(UITransform), _dec5 = property(UITransform), _dec6 = property({
        type: Orientation
      }), _dec7 = property({
        type: Orientation
      }), _dec8 = property({
        type: TouchMode,
        tooltip: "Auto: \u5F53\u5185\u5BB9\u6491\u6EE1\u53EF\u89C6\u533A\u57DF\u6216\u5F00\u542FReleaseManager\u65F6\u5141\u8BB8\u62D6\u52A8\n        AlwaysAllow: \u4EFB\u4F55\u60C5\u51B5\u4E0B\u90FD\u53EF\u4EE5\u62D6\u52A8\uFF0C\u5373\u4F7F\u6CA1\u6709\u4EFB\u4F55\u5143\u7D20\n        Disabled: \u4EFB\u4F55\u60C5\u51B5\u4E0B\u90FD\u7981\u7528\u62D6\u52A8\n        "
      }), _dec9 = property({
        type: MovementType
      }), _dec10 = property({
        range: [0, 1],
        slide: true,
        step: 0.001,
        visible: function visible() {
          return this.movementType == MovementType.Elastic;
        }
      }), _dec11 = property({
        range: [0, 1],
        slide: true,
        step: 0.001,
        visible: function visible() {
          return this.inertia;
        }
      }), _dec12 = property({
        tooltip: "ON_ABOUT_TO_STOP"
      }), _dec13 = property({
        tooltip: "Button"
      }), _dec14 = property({
        range: [0, 0.5],
        slide: true,
        step: 0.001,
        visible: function visible() {
          return this.inertia;
        },
        tooltip: "\u5D4C\u5957\u65F6\uFF0C\u5F53\u5B50\u5143\u7D20\u7684ScrollView\u62D6\u52A8\u65B9\u5411\u548C\u5F53\u524D\u62D6\u52A8\u65B9\u5411\u76F8\u540C\u65F6\uFF0C\u4F7F\u7528\u5F53\u524D\u9608\u503C\u8FDB\u884C\u8BA1\u7B97\u7531\u8C01\u6765\u5904\u7406\u62D6\u52A8\n        \u65E0\u7279\u6B8A\u9700\u6C42\u65F6\uFF0C\u9ED8\u8BA4\u503C\u5373\u53EF"
      }), _dec15 = property({
        range: [0.5, 1],
        slide: true,
        step: 0.001,
        visible: function visible() {
          return this.inertia;
        },
        tooltip: "\u5D4C\u5957\u65F6\uFF0C\u5F53\u5B50\u5143\u7D20\u7684ScrollView\u62D6\u52A8\u65B9\u5411\u548C\u5F53\u524D\u62D6\u52A8\u65B9\u5411\u76F8\u540C\u65F6\uFF0C\u4F7F\u7528\u5F53\u524D\u9608\u503C\u8FDB\u884C\u8BA1\u7B97\u7531\u8C01\u6765\u5904\u7406\u62D6\u52A8\n        \u65E0\u7279\u6B8A\u9700\u6C42\u65F6\uFF0C\u9ED8\u8BA4\u503C\u5373\u53EF"
      }), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Manager) {
        _inheritsLoose(ScrollManager, _Manager);
        function ScrollManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Manager.call.apply(_Manager, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "_view", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "_content", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "_orientation", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "touchMode", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "movementType", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "elasticity", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "inertia", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "decelerationRate", _descriptor8, _assertThisInitialized(_this));
          // TODO 
          // @property scrollSensitivity: number = 0.01 
          _initializerDefineProperty(_this, "aboutToStopVelocity", _descriptor9, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor10, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "nestedMinThreshold", _descriptor11, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "nestedMaxThreshold", _descriptor12, _assertThisInitialized(_this));
          _this.__debug_graphics = void 0;
          _this._boundaryOffset = 0;
          _this._viewWidget = null;
          _this._parentAdapter = void 0;
          _this._layerLowest = void 0;
          _this._layerMedium = void 0;
          _this._layerHighest = void 0;
          _this._percentage = 0;
          _this._velocity = 0;
          _this._dragging = false;
          _this._scrolling = false;
          _this._isCanceledEvent = false;
          _this._contentStartPosition = new Vec3();
          _this._prevContentPosition = new Vec3();
          _this._nestedDirection = NestedDirection.Both;
          _this._parentTouch = false;
          _this._stopCheckNested = false;
          _this._scrollHandlePercentage = null;
          _this._scrollHandlePosition = null;
          _this._isEmitAboutToStop = false;
          _this._isMyEventAndMoved = false;
          _this._scrollDirection = ScrollDirection.None;
          _this._laseScrollDirection = ScrollDirection.None;
          _this._touchEvent = null;
          _this.test = false;
          return _this;
        }
        var _proto = ScrollManager.prototype;
        _proto.onInit = function onInit() {
          var _this2 = this;
          this._initView();
          this._initContent();
          this._parentAdapter = this.adapter.getParentAdapter(this.adapter.node.parent);
          this.view.node[ADAPTER] = true;
          this.adapter.viewManager.on(ViewManager.Event.ON_UPDATE_VIEWS, this._onUpdateViews, this);
          this.adapter.viewManager.on(ViewManager.Event.ON_CHANGED_VIRTUALSIZE, this._onChangedVirtualSize, this);
          this.adapter.viewManager.on(ViewManager.Event.ON_CHANGED_OVERFLOWHEADER, this._onChangedOverflowHeader, this);
          this.adapter.viewManager.on(ViewManager.Event.ON_RESET_ALL_STATE, this._onResetAllState, this);
          this.adapter.viewManager.on(ViewManager.Event.ON_CLEARVIEWS, this._onResetAllState, this);
          this.adapter.node.on(Node.EventType.SIZE_CHANGED, this._onAdapterSizeChanged, this);
          this.view.node.on(Node.EventType.SIZE_CHANGED, this._onViewSizeChanged, this);
          this._registerTouchEvent();
          this.__createDebug();
          this.view.scheduleOnce(function () {
            _this2._updatePercentage();
          });
        };
        _proto._initView = function _initView() {
          if (!this.view) {
            throw Error("ScrollManager view ");
          }
          var anchorPoint = {
            x: 0.5,
            y: 0.5
          };
          anchorPoint[this.adapter.mainAxis] = this.adapter.mainAxisAnchorPoint;
          this.view.setAnchorPoint(anchorPoint.x, anchorPoint.y);
          var widget = this.view.getComponent(Widget);
          if (!widget) {
            widget = this.view.addComponent(Widget);
            widget.isAlignLeft = widget.isAlignRight = widget.isAlignTop = widget.isAlignBottom = true;
            widget.left = widget.right = widget.top = widget.bottom = 0;
          }
          widget.updateAlignment();
          this._viewWidget = widget;
        };
        _proto.__createDebug = function __createDebug() {};
        _proto.__drawDebug = function __drawDebug() {
          if (!this.__debug_graphics) return;
          this.__debug_graphics.clear();
          var mainAxis = this.adapter.mainAxis;
          var crossAxis = this.adapter.crossAxis;
          var multiplier = this.adapter.multiplier;
          var position = {
            x: 0,
            y: 0
          };
          var size = {
            x: 0,
            y: 0
          };
          size[mainAxis] = this.adapter.viewManager.virtualSize;
          size[crossAxis] = this.adapter.crossAxisSize;
          position[mainAxis] = this.contentPosition - size[mainAxis] * this.content.anchorPoint[mainAxis] * multiplier;
          position[mainAxis] += this.adapter.viewManager.overflowHeader;
          position[crossAxis] -= size[crossAxis] * this.view.anchorPoint[crossAxis];
          this.__debug_graphics.fillRect(position.x, position.y, size.x, size.y);
          this.__debug_graphics.stroke();
        };
        _proto._initContent = function _initContent() {
          if (!this.content) {
            throw Error("ScrollManager content ");
          }
          this.content.setAnchorPoint(this.view.anchorPoint);
          var size = {
            x: 0,
            y: 0
          };
          size[this.adapter.crossAxis] = this.view.contentSize[this.adapter.crossAxis];
          this.content.setContentSize(size.x, size.y);
          if (!this._layerLowest) {
            this._layerLowest = new Node("_layerLowest");
            this._layerMedium = new Node("_layerMedium");
            this._layerHighest = new Node("_layerHighest");
            this.content.node.addChild(this._layerLowest);
            this.content.node.addChild(this._layerMedium);
            this.content.node.addChild(this._layerHighest);
          }
          this._updateContentPosition({
            x: 0,
            y: 0
          });
        };
        _proto._registerTouchEvent = function _registerTouchEvent() {
          this.view.node.on(Node.EventType.TOUCH_START, this._onTouchStart, this, true);
          this.view.node.on(Node.EventType.TOUCH_END, this._onTouchEnd, this, true);
          this.view.node.on(Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this, true);
          this.view.node.on(Node.EventType.TOUCH_MOVE, this._onTouchMove, this, true);
        };
        _proto._bubbleToParent = function _bubbleToParent(event) {
          if (!this._parentAdapter) return;
          this._parentAdapter.scrollManager.view.node.dispatchEvent(event);
        };
        _proto._emitCancelEvent = function _emitCancelEvent(event) {
          if (this._isCanceledEvent) return;
          var deltaMove = event.getUILocation();
          deltaMove.subtract(event.getUIStartLocation());
          if (this.cancelInnerEvents && deltaMove.length() > 7) {
            if (event.target !== this.view.node) {
              this._simulateEvent(event, Node.EventType.MOUSE_LEAVE);
              this._simulateEvent(event, Node.EventType.TOUCH_CANCEL);
              this._isCanceledEvent = true;
            }
          }
        };
        _proto._simulateEvent = function _simulateEvent(event, type, isSimulate) {
          if (isSimulate === void 0) {
            isSimulate = true;
          }
          if (!event) return;
          var _event = new EventTouch(event.getTouches(), event.bubbles);
          var target = event.target;
          _event.type = type;
          _event.touch = event.touch;
          _event.simulate = isSimulate;
          target.dispatchEvent(_event);
        };
        _proto._onUpdateViews = function _onUpdateViews() {
          this._velocity = 0;
          this._updatePercentage();
        };
        _proto._onChangedVirtualSize = function _onChangedVirtualSize() {
          this._updatePercentage();
          if (this._scrollHandlePosition != null && this._scrollHandlePosition.change != null) {
            this._scrollHandlePosition.change();
          }
        };
        _proto._onChangedOverflowHeader = function _onChangedOverflowHeader(overflowHeader) {
          this.__drawDebug();
        };
        _proto._onResetAllState = function _onResetAllState() {
          this._velocity = 0;
          this._scrolling = false;
          this._dragging = false;
          this._isMyEventAndMoved = false;
          this._scrollDirection = ScrollDirection.None;
          this._percentage = 0;
          this._isEmitAboutToStop = false;
          this._boundaryOffset = 0;
          this._isCanceledEvent = false;
          this._parentTouch = false;
          this._stopCheckNested = false;
          this._scrollDirection = ScrollDirection.None;
          this._touchEvent = null;
          this.stopScroll();
          this._initView();
          this._initContent();
        }
        /** adapter  view  Widget ...  */;
        _proto._onAdapterSizeChanged = function _onAdapterSizeChanged() {
          this._viewWidget.updateAlignment();
        }
        /** view */;
        _proto._onViewSizeChanged = function _onViewSizeChanged() {
          this.emit(Event.ON_VIEW_SIZE_CHANGED);
        }
        /**  */;
        _proto._isMyEvent = function _isMyEvent(event, useCaptures) {
          if (event.eventPhase == EventTouch.AT_TARGET || !useCaptures || useCaptures[0] == this.view.node && !event.target[ADAPTER]) {
            return true;
          }
          return false;
        };
        _proto._onTouchStart = function _onTouchStart(event) {
          this._velocity = 0;
          this._dragging = true;
          this._isMyEventAndMoved = false;
          this._isCanceledEvent = false;
          this._parentTouch = false;
          this._stopCheckNested = false;
          this._isEmitAboutToStop = false;
          this._scrollDirection = ScrollDirection.None;
          this._contentStartPosition.set(this.content.node.position);
          this._touchEvent = event;
          this.stopScroll();
          this._calcNestedDirection();
          this.emit(Event.ON_SCROLL_START);
        };
        _proto._onTouchEnd = function _onTouchEnd(event, useCaptures) {
          this._dragging = false;
          this._touchEvent = null;
          this.emit(Event.ON_SCROLL_END, event);
        };
        _proto._onTouchCancel = function _onTouchCancel(event, useCaptures) {
          if (event.simulate) {
            return;
          }
          this._dragging = false;
          this._touchEvent = null;
          this.emit(Event.ON_SCROLL_CANCEL, event);
        };
        _proto._onTouchMove = function _onTouchMove(event, useCaptures) {
          if (!this._isMyEvent(event, useCaptures)) {
            return;
          }
          // Button
          this._emitCancelEvent(event);
          // 
          if (this._parentTouch || !this.canTouch) {
            return this._bubbleToParent(event);
          }
          // if (!this._touchEvent && this.adapter.centerManager.enabled) return
          if (!this._touchEvent) return;
          var mainAxis = this.adapter.mainAxis;
          var location = event.getUILocation();
          var startLocation = event.getUIStartLocation();
          var pointerDelta = location.subtract(startLocation);
          if (pointerDelta.equals2f(0, 0)) {
            return;
          }
          var position = {
            x: 0,
            y: 0
          };
          position[mainAxis] = this._contentStartPosition[mainAxis] + pointerDelta[mainAxis];
          var delta = position[mainAxis] - this.contentPosition;
          var offset = this.calcOffset(delta);
          var axis = this.adapter.isHorizontal ? -1 : 1;
          position[mainAxis] += axis * offset;
          if (this.movementType == MovementType.Elastic && offset != 0) {
            position[mainAxis] -= axis * this._rubberDelta(offset, this.adapter.mainAxisSize);
          }
          //   
          this._checkNested(event, position, this._parentAdapter);
          if (this._parentTouch) {
            this._bubbleToParent(event);
          } else {
            this._isMyEventAndMoved = true;
            this._updateContentPosition(position);
          }
        };
        _proto._calcNestedDirection = function _calcNestedDirection() {
          if (!this._parentAdapter) return;
          if (this.percentage <= this.nestedMinThreshold && !this.adapter.viewManager.loopHeader) {
            this._nestedDirection = this.adapter.multiplier == 1 ? NestedDirection.Footer : NestedDirection.Header;
          } else if (this.percentage >= this.nestedMaxThreshold && !this.adapter.viewManager.loopFooter) {
            this._nestedDirection = this.adapter.multiplier == 1 ? NestedDirection.Header : NestedDirection.Footer;
          } else {
            this._nestedDirection = NestedDirection.Both;
          }
        }
        /**     Adapter */;
        _proto._checkNested = function _checkNested(event, position, adapter) {
          if (!adapter || this._stopCheckNested) return;
          // 
          if (this.orientation == adapter.scrollManager.orientation) {
            var offset = position[this.adapter.mainAxis] - this._contentStartPosition[this.adapter.mainAxis];
            if (Math.abs(offset) <= 0.1) {
              return;
            }
            if (this._nestedDirection == NestedDirection.Footer) {
              if (offset < 0) {
                this._parentTouch = true;
              }
            } else if (this._nestedDirection == NestedDirection.Header) {
              if (offset > 0) {
                this._parentTouch = true;
              }
            }
          } else {
            // 
            var xOffset = 0,
              yOffset = 0;
            if (event instanceof EventTouch) {
              var start = event.getUIStartLocation();
              var curre = event.getUILocation();
              xOffset = Math.abs(start.x - curre.x);
              yOffset = Math.abs(start.y - curre.y);
            } else {
              xOffset = Math.abs(event.getScrollX());
              yOffset = Math.abs(event.getScrollY());
            }
            if (xOffset == yOffset) return;
            if (xOffset > yOffset) {
              if (this.adapter.isVertical) {
                this._parentTouch = true;
              }
            } else if (yOffset > xOffset) {
              if (this.adapter.isHorizontal) {
                this._parentTouch = true;
              }
            }
          }
          if (!this._parentTouch && adapter.scrollManager.parentAdapter) {
            return this._checkNested(event, position, adapter.scrollManager.parentAdapter);
          }
          this._stopCheckNested = true;
        }
        /** content */;
        _proto._updateContentPosition = function _updateContentPosition(position, updatePercentage) {
          if (updatePercentage === void 0) {
            updatePercentage = true;
          }
          this._updateScrollDirection(position);
          this.content.node.setPosition(position.x, position.y);
          this.emit(Event.ON_SCROLL, this._scrollDirection);
          //    this._calcOffset 
          if (updatePercentage) {
            this._updatePercentage();
          } else {
            this.__drawDebug();
          }
        }
        /** content */;
        _proto._updatePrevContentPosition = function _updatePrevContentPosition() {
          this._prevContentPosition.set(this.content.node.position);
        }
        /**
         * 
         */;
        _proto._calcPercentage = function _calcPercentage(contentPosition, offset) {
          var hiddenSize = this.internal_getHiddenSize();
          var loopHeader = this.adapter.viewManager.loopHeader;
          var loopFooter = this.adapter.viewManager.loopFooter;
          var multiplier = this.adapter.multiplier;
          var overflowHeader = this.adapter.viewManager.overflowHeader;
          var position = contentPosition * multiplier;
          if (this.adapter.isHorizontal) {
            position -= offset * multiplier;
          } else {
            position += offset * multiplier;
          }
          if (loopFooter) {
            hiddenSize += this.adapter.viewManager.spacing;
            position += (overflowHeader + hiddenSize * multiplier) * multiplier;
            if (this.adapter.centerManager.enabled) {
              position += this.adapter.centerManager.getContainerOffset();
            } else {
              position += this.adapter.paddingHeader;
            }
            position += 1;
            position = position % hiddenSize;
          } else if (loopHeader) {
            position += this.adapter.mainAxisSize - 1;
            if (this.adapter.centerManager.enabled) {
              position -= this.adapter.centerManager.getContainerOffset();
            } else {
              position -= this.adapter.paddingFooter;
            }
            position += (overflowHeader + hiddenSize * multiplier) * multiplier;
            var ok = contentPosition * -multiplier > overflowHeader * multiplier;
            if (ok) {
              position += this.adapter.viewManager.spacing;
            }
            position = position % hiddenSize;
          } else {
            position += overflowHeader * multiplier;
            if (this.adapter.centerManager.enabled) {
              position += this.adapter.centerManager.getContainerOffset();
            } else {
              position += this.adapter.paddingHeader;
            }
            if (position > hiddenSize) {
              position = hiddenSize;
            }
          }
          return position / hiddenSize;
        };
        _proto._updatePercentage = function _updatePercentage() {
          var offset = this.calcOffset();
          if (this.adapter.viewManager.virtualSize <= this.adapter.mainAxisSize) {
            this._percentage = 0;
          } else {
            this._percentage = this._calcPercentage(this.contentPosition, offset);
          }
          this.emit(Event.ON_UPDATE_PERCENTAGE, this._percentage, offset);
          this.__drawDebug();
        }
        /** @deprecated  */;
        _proto.internal_disableTouchTarget = function internal_disableTouchTarget(node) {
          // if (this.adapter.pageViewManager.enabled) return
          if (this._touchEvent && this._touchEvent.target == node) {
            var event = this._touchEvent;
            this._simulateEvent(event, Node.EventType.TOUCH_CANCEL, false);
            this._simulateEvent(event, Node.EventType.MOUSE_LEAVE, false);
            this._touchEvent = null;
          }
        }
        /** @deprecated  */;
        _proto.internal_getHiddenSize = function internal_getHiddenSize() {
          var loopHeader = this.adapter.viewManager.loopHeader;
          var loopFooter = this.adapter.viewManager.loopFooter;
          var hiddenSize = this.adapter.viewManager.virtualSize;
          if (!loopHeader && !loopFooter && !this.adapter.centerManager.enabled) {
            hiddenSize -= this.adapter.mainAxisSize;
            hiddenSize += this.adapter.mainAxisPadding;
          }
          return hiddenSize;
        };
        _proto._getContentMinBoundaryOffset = function _getContentMinBoundaryOffset(delta, position) {
          if (!this.adapter.viewManager.header || !this.adapter.centerManager.enabled && this.adapter.viewManager.virtualSize <= this.adapter.mainAxisSize) {
            if (this.adapter.isHorizontal) {
              return position + this._defaultMax + delta;
            } else {
              return position + this._defaultMin + delta;
            }
          }
          return this.adapter.viewManager.min + delta;
        };
        _proto._getContentMaxBoundaryOffset = function _getContentMaxBoundaryOffset(delta, position) {
          if (!this.adapter.viewManager.header || !this.adapter.centerManager.enabled && this.adapter.viewManager.virtualSize <= this.adapter.mainAxisSize) {
            if (this.adapter.isHorizontal) {
              return position + this._defaultMin + delta;
            } else {
              return position + this._defaultMax + delta;
            }
          }
          return this.adapter.viewManager.max + delta;
        };
        _proto._getMaxBoundaryOffset = function _getMaxBoundaryOffset(max) {
          var viewMax = this._viewMax;
          if (this.adapter.isHorizontal) {
            return this.adapter.isArrangeAxisStart ? max : viewMax + max;
          } else {
            return this.adapter.isArrangeAxisStart ? -max : viewMax - max;
          }
        };
        _proto._getMinBoundaryOffset = function _getMinBoundaryOffset(min) {
          var viewMin = this._viewMin;
          if (this.adapter.isHorizontal) {
            return this.adapter.isArrangeAxisStart ? viewMin + min : min;
          } else {
            return this.adapter.isArrangeAxisStart ? viewMin - min : -min;
          }
        };
        _proto._rubberDelta = function _rubberDelta(overStretching, viewSize) {
          return (1 - 1 / (Math.abs(overStretching) * 0.55 / viewSize + 1)) * viewSize * Math.sign(overStretching);
        };
        _proto._calcElastic = function _calcElastic(deltaTime, offset, out) {
          var mainAxis = this.adapter.mainAxis;
          var smoothTime = this.elasticity;
          if (this._scrolling) {
            smoothTime *= 3;
          }
          var axis = this.adapter.isHorizontal ? -1 : 1;
          var _Helper$smoothDamp = Helper.smoothDamp(this.contentPosition, this.contentPosition + axis * offset, this._velocity, smoothTime, Helper.Infinity, deltaTime),
            velocity = _Helper$smoothDamp.velocity,
            position = _Helper$smoothDamp.position;
          if (Math.abs(velocity) < 1) {
            velocity = 0;
          }
          this._velocity = velocity;
          out[mainAxis] = position;
        };
        _proto._calcInertia = function _calcInertia(deltaTime, out) {
          this._velocity *= Math.pow(this.decelerationRate, deltaTime);
          if (Math.abs(this._velocity) < 1) {
            this._velocity = 0;
          }
          out[this.adapter.mainAxis] += this._velocity * deltaTime;
        };
        _proto._calcClamped = function _calcClamped(out) {
          var mainAxis = this.adapter.mainAxis;
          var boundary = out[mainAxis] - this.contentPosition;
          var offset = this.calcOffset(boundary);
          if (this.adapter.isHorizontal) {
            out[mainAxis] -= offset;
          } else {
            out[mainAxis] += offset;
          }
        };
        _proto._updateScrollDirection = function _updateScrollDirection(position) {
          var delta = position[this.adapter.mainAxis] - this.contentPosition;
          if (delta == 0) {
            this._scrollDirection = ScrollDirection.None;
            return;
          }
          if (this.adapter.isHorizontal) {
            this._scrollDirection = delta > 0 ? ScrollDirection.Right : ScrollDirection.Left;
          } else {
            this._scrollDirection = delta > 0 ? ScrollDirection.Up : ScrollDirection.Down;
          }
          this._laseScrollDirection = this._scrollDirection;
        }
        /** @deprecated  */;
        _proto.internal_setContentPosition = function internal_setContentPosition(mainPosition, updatePercentage) {
          if (updatePercentage === void 0) {
            updatePercentage = true;
          }
          var position = {
            x: 0,
            y: 0
          };
          position[this.adapter.mainAxis] = mainPosition;
          this._updateContentPosition(position, updatePercentage);
        };
        /** @deprecated  */
        _proto.internal_lateUpdate = function internal_lateUpdate(deltaTime) {
          if (this.test) return;
          this._autoScrolling(deltaTime);
          this._scrollHandler(deltaTime, this._scrollHandlePosition, this._scrollPositionHandler.bind(this));
          this._scrollHandler(deltaTime, this._scrollHandlePercentage, this._scrollPercentageHandler.bind(this));
        };
        _proto._autoScrolling = function _autoScrolling(deltaTime) {
          var offset = this.calcOffset();
          this._boundaryOffset = offset;
          if (!this._dragging && (offset != 0 || this._velocity != 0)) {
            this.content.node.getPosition(_tempPosition);
            if (this.movementType == MovementType.Elastic && offset != 0) {
              this._calcElastic(deltaTime, offset, _tempPosition);
            } else if (this.inertia) {
              this._calcInertia(deltaTime, _tempPosition);
            } else {
              this._velocity = 0;
            }
            if (this.movementType == MovementType.Clamped) {
              this._calcClamped(_tempPosition);
            }
            this._updateContentPosition(_tempPosition);
          }
          if (this._dragging && this.inertia) {
            var newVelocity = (this.contentPosition - this._prevContentPosition[this.adapter.mainAxis]) / deltaTime;
            this._velocity = Helper.lerp(this._velocity, newVelocity, deltaTime * 10);
          }
          if (!this._prevContentPosition.equals(this.content.node.position)) {
            this._updatePrevContentPosition();
          }
          if (!this._isEmitAboutToStop && !this._dragging && Math.abs(this._velocity) <= this.aboutToStopVelocity) {
            if (!this._scrollHandlePercentage && !this._scrollHandlePosition) {
              this.emit(Event.ON_ABOUT_TO_STOP, this._velocity);
              this._isEmitAboutToStop = true;
            }
          }
          this._scrolling = false;
        };
        _proto._scrollHandler = function _scrollHandler(deltaTime, info, handler) {
          if (info == null) return;
          info.deltaTime += deltaTime;
          var time = info.deltaTime / (info.duration > macro.FLT_EPSILON ? info.duration : macro.FLT_EPSILON);
          time = Helper.clamp01(time);
          var easingTime = easing.quintOut(time);
          info.current = Helper.progress(info.from, info.to, info.current, easingTime);
          handler(info, time);
        };
        _proto._scrollPercentageHandler = function _scrollPercentageHandler(info, time) {
          var old = this.percentage;
          this.setPercentage(info.current);
          if (time == 1 || old == this.percentage) {
            var stop = true;
            if (this._scrollHandlePercentage.stop) {
              stop = this._scrollHandlePercentage.stop();
            }
            if (stop) {
              this._scrollHandlePercentage = null;
            }
          }
        };
        _proto._scrollPositionHandler = function _scrollPositionHandler(info, time) {
          var position = {
            x: 0,
            y: 0
          };
          position[this.adapter.mainAxis] = info.current;
          this._setAutoScroll(position);
          if (time == 1 || Math.abs(this.contentPosition - info.to) <= 0.0001) {
            if (this._scrollHandlePosition.stop) {
              this._scrollHandlePosition.stop();
            }
            this._scrollHandlePosition = null;
          }
        };
        _proto._setAutoScroll = function _setAutoScroll(position) {
          var _this3 = this;
          var handler = function handler(target) {
            _this3._updateContentPosition(target);
            _this3._updatePrevContentPosition();
            _this3._velocity = 0;
          };
          handler(position);
          var offset = this.calcOffset();
          if (offset != 0) {
            var direction = this.adapter.isHorizontal ? -1 : 1;
            position[this.adapter.mainAxis] += offset * direction;
            handler(position);
            return false;
          }
          return true;
        };
        _proto._scrollToPosition = function _scrollToPosition(duration, getPosition, onStop) {
          var _this4 = this;
          if (!this.canAutoScroll) {
            return false;
          }
          var position = getPosition();
          if (position == null || Math.abs(this.contentPosition - position) < macro.FLT_EPSILON) {
            return false;
          }
          this._scrollHandlePercentage = null;
          this._scrollHandlePosition = {
            current: 0,
            from: this.contentPosition,
            to: position,
            deltaTime: 0,
            duration: Math.max(0, duration),
            change: function change() {
              position = getPosition();
              _this4._scrollHandlePosition.to = position;
            },
            stop: function stop() {
              onStop();
            }
          };
          return true;
        }
        // public 
        ;

        _proto.getLayerNode = function getLayerNode(layer) {
          switch (layer) {
            case Layer.Medium:
              return this._layerMedium;
            case Layer.Highest:
              return this._layerHighest;
            default:
              return this._layerLowest;
          }
        }
        /**
         *    
         * @param duration 
         * @param index 
         * @param alwaysScroll  AlwaysScroll.Auto
         */;
        _proto.scrollToModelIndex = function scrollToModelIndex(duration, index, alwaysScroll) {
          var _this5 = this;
          var groupIndex = this.adapter.viewManager.getGroupIndexByModelIndex(index);
          if (-1 == groupIndex) return;
          var priorityCheckExists = false;
          var ok = this._scrollToPosition(duration, function () {
            var position = _this5.adapter.centerManager.getPositionByGroupIndex(groupIndex, alwaysScroll, priorityCheckExists);
            priorityCheckExists = true;
            return position;
          }, function () {
            _this5.emit(Event.ON_SCROLL_TO_MODELINDEX_AFTER, index);
          });
          if (ok) {
            this.emit(Event.ON_SCROLL_TO_MODELINDEX_BEFOR, index);
          }
        }
        /**
         * 
         * @param duration 
         * @param index 
         * @param alwaysScroll  AlwaysScroll.Auto
         */;
        _proto.scrollToGroupIndex = function scrollToGroupIndex(duration, index, alwaysScroll) {
          var _this6 = this;
          var priorityCheckExists = false;
          var ok = this._scrollToPosition(duration, function () {
            var position = _this6.adapter.centerManager.getPositionByGroupIndex(index, alwaysScroll, priorityCheckExists);
            priorityCheckExists = true;
            return position;
          }, function () {
            _this6.emit(Event.ON_SCROLL_TO_GROUPINDEX_AFTER, index);
          });
          if (ok) {
            this.emit(Event.ON_SCROLL_TO_GROUPINDEX_BEFOR, index);
          }
        }
        /**
         * 
         * @param duration 
         */;
        _proto.scrollToHeader = function scrollToHeader(duration) {
          this.scrollToGroupIndex(duration, 0);
        }
        /**
         * 
         * @param duration  
         */;
        _proto.scrollToFooter = function scrollToFooter(duration) {
          this.scrollToGroupIndex(duration, this.adapter.viewManager.groupLength - 1);
        }
        /**
         * 
         * item scrollToGroupIndex
         * 
         * item
         * @param duration 
         * @param percentage  0-1
         */;
        _proto.scrollToPercentage = function scrollToPercentage(duration, percentage) {
          if (!this.canAutoScroll) {
            return false;
          }
          if (Math.abs(this._percentage - percentage) < 0.001) {
            return;
          }
          percentage = Helper.clamp01(percentage);
          duration = Math.max(0, duration);
          this._scrollHandlePercentage = null;
          this._scrollHandlePercentage = {
            deltaTime: 0,
            duration: duration,
            current: 0,
            from: this._percentage,
            to: percentage
          };
        };
        _proto.stopVelocity = function stopVelocity() {
          this._velocity = 0;
        };
        _proto.setVelocity = function setVelocity(value) {
          this._velocity = value;
        }

        /**  */;
        _proto.stopScroll = function stopScroll() {
          this._scrollHandlePosition = null;
          this._scrollHandlePercentage = null;
          this.stopVelocity();
        };
        _proto.setPercentage = function setPercentage(percentage) {
          var hiddenSize = this.internal_getHiddenSize();
          var position = {
            x: 0,
            y: 0
          };
          var total = 0;
          var old = null;
          // TODO 100 
          while ( /** true **/total < 100) {
            total++;
            var cross = this._percentage - percentage;
            if (old != null && this._percentage === old) {
              break;
            }
            if (Math.abs(cross) < macro.FLT_EPSILON) {
              break;
            }
            old = this._percentage;
            var target = this.contentPosition - cross * this.adapter.multiplier * hiddenSize;
            position[this.adapter.mainAxis] = target;
            var ok = this._setAutoScroll(position);
            if (!ok) {
              break;
            }
          }
          if (total == 100) {
            console.warn("S vng lp  t n gi tr ti a. C gng khng sa i kch thc thng xuyn trong qu trnh cun.");
          }
        }
        /** overflow */;
        _proto.calcOffset = function calcOffset(delta, position) {
          if (delta === void 0) {
            delta = 0;
          }
          if (position === void 0) {
            position = this.contentPosition;
          }
          var offset = 0;
          if (this.movementType == MovementType.Unrestricted) {
            return offset;
          }
          var max = this._getContentMaxBoundaryOffset(delta, position);
          var min = this._getContentMinBoundaryOffset(delta, position);
          var maxOffset = this._getMaxBoundaryOffset(max);
          var minOffset = this._getMinBoundaryOffset(min);
          if (!this.adapter.centerManager.enabled && this.adapter.viewManager.virtualSize > this.adapter.mainAxisSize) {
            if (this.adapter.isVertical) {
              maxOffset -= this.adapter.viewManager.top;
              minOffset += this.adapter.viewManager.bottom;
            } else {
              maxOffset -= this.adapter.viewManager.left;
              minOffset += this.adapter.viewManager.right;
            }
          }
          var minExpand = 0,
            maxExpand = 0;
          if (this.adapter.centerManager.enabled && this.adapter.viewManager.groupLength > 0) {
            maxExpand = this.adapter.centerManager.max;
            minExpand = this.adapter.centerManager.min;
          } else {
            var magneticOffset = this.adapter.viewManager.getMagneticOffset();
            maxOffset -= magneticOffset;
            minOffset -= magneticOffset;
          }
          if (this.adapter.releaseManager.enabled) {
            maxExpand = Math.max(maxExpand, this.adapter.releaseManager.max);
            minExpand = Math.max(minExpand, this.adapter.releaseManager.min);
          }
          maxOffset -= maxExpand;
          minOffset += minExpand;
          if (minOffset < -0.001) {
            offset = minOffset;
          } else if (maxOffset > 0.001) {
            offset = maxOffset;
          }
          return offset;
        };
        _createClass(ScrollManager, [{
          key: "view",
          get: function get() {
            return this._view;
          },
          set: function set(value) {
            this._view = value;
          }
        }, {
          key: "content",
          get: function get() {
            return this._content;
          },
          set: function set(value) {
            this._content = value;
          }
        }, {
          key: "orientation",
          get: function get() {
            return this._orientation;
          },
          set: function set(value) {
            if (value == this._orientation) return;
            this._orientation = value;
            this.emit(Event.ON_CHANGED_ORIENTATION);
          }
        }, {
          key: "_viewMin",
          get: function get() {
            return -this.adapter.mainAxisSize;
          }
        }, {
          key: "_viewMax",
          get: function get() {
            return this.adapter.mainAxisSize;
          }
        }, {
          key: "_defaultMin",
          get: function get() {
            return this.adapter.multiplier == 1 ? -this.adapter.mainAxisSize : 0;
          }
        }, {
          key: "_defaultMax",
          get: function get() {
            return this.adapter.multiplier == 1 ? 0 : this.adapter.mainAxisSize;
          }
        }, {
          key: "isMyEventAndMoved",
          get: function get() {
            return this._isMyEventAndMoved;
          }
        }, {
          key: "velocity",
          get: function get() {
            return this._velocity;
          }
        }, {
          key: "scrollDirection",
          get: function get() {
            return this._scrollDirection;
          }
        }, {
          key: "laseScrollDirection",
          get: function get() {
            return this._laseScrollDirection;
          }
        }, {
          key: "percentage",
          get: function get() {
            return this._percentage;
          }
        }, {
          key: "dragging",
          get: function get() {
            return this._dragging;
          }
        }, {
          key: "boundaryOffset",
          get: function get() {
            return this._boundaryOffset;
          }
        }, {
          key: "parentAdapter",
          get: function get() {
            return this._parentAdapter;
          }
        }, {
          key: "canAutoScroll",
          get: function get() {
            return !this.dragging && this.adapter.viewManager.virtualSize > this.adapter.mainAxisSize;
          }
        }, {
          key: "canTouch",
          get: function get() {
            if (this.touchMode == TouchMode.AlwaysAllow) {
              return true;
            }
            if (this.touchMode == TouchMode.Disabled) {
              return false;
            }
            if (this.adapter.centerManager.enabled) {
              return true;
            }
            if (this.adapter.releaseManager.enabled) {
              return true;
            }
            return this.adapter.viewManager.virtualSize > this.adapter.mainAxisSize;
          }
        }, {
          key: "contentPosition",
          get: function get() {
            return this.content.node.position[this.adapter.mainAxis];
          }
        }]);
        return ScrollManager;
      }(Manager), _class3.Event = Event, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "_view", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "view", [_dec3], Object.getOwnPropertyDescriptor(_class2.prototype, "view"), _class2.prototype), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_content", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "content", [_dec5], Object.getOwnPropertyDescriptor(_class2.prototype, "content"), _class2.prototype), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_orientation", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return Orientation.Vertical;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "orientation", [_dec7], Object.getOwnPropertyDescriptor(_class2.prototype, "orientation"), _class2.prototype), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "touchMode", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return TouchMode.Auto;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "movementType", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return MovementType.Elastic;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "elasticity", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "inertia", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "decelerationRate", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.135;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "aboutToStopVelocity", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 100;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "cancelInnerEvents", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return true;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "nestedMinThreshold", [_dec14], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.001;
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "nestedMaxThreshold", [_dec15], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.999;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ScrollViewBase.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ScrollViewBaseLine.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Node, Prefab, instantiate, Component, ScrollViewBaseLine;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Prefab = module.Prefab;
      instantiate = module.instantiate;
      Component = module.Component;
    }, function (module) {
      ScrollViewBaseLine = module.ScrollViewBaseLine;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "c6578BkEldD6Ymz3t6pB6h0", "ScrollViewBase", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var ScrollViewBase = exports('ScrollViewBase', (_dec = ccclass('ScrollViewBase'), _dec2 = property(Node), _dec3 = property(Prefab), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(ScrollViewBase, _Component);
        function ScrollViewBase() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "content", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "prefabLine", _descriptor2, _assertThisInitialized(_this));
          _this.onSelectedItem = void 0;
          _this.onCreatedItem = void 0;
          _this.itemPerLine = 0;
          _this.firstLine = null;
          _this.lines = [];
          _this.items = [];
          return _this;
        }
        var _proto = ScrollViewBase.prototype;
        _proto.init = function init(items) {
          if (items.length <= 0) return;
          this.items = items;
          this.createFristLine();
          this.createLines();
          this.setLineData();
        };
        _proto.createLines = function createLines() {
          var needPage = Math.ceil(this.items.length / this.itemPerLine);
          for (var i = this.lines.length; i < needPage; i++) {
            this.createLine();
          }
        };
        _proto.setLineData = function setLineData() {
          var _this2 = this;
          if (this.lines.length <= 0) return;
          var lineIndex = 0;
          var itemIndex = 0;
          var initLine = function initLine(line, data) {
            line.node.active = true;
            line.onSelectItem = _this2.onLineSelectItem.bind(_this2);
            line.onCreatedItem = _this2.onLineCreateItem.bind(_this2);
            line.init(data);
          };
          for (var i = 0; i < this.items.length; i += this.itemPerLine) {
            var breakItems = this.items.slice(i, i + this.itemPerLine);
            initLine(this.lines[lineIndex], breakItems);
            itemIndex = i + breakItems.length;
            lineIndex++;
          }

          //last page
          if (itemIndex < this.items.length - 1) {
            var lastItems = this.items.slice(itemIndex, this.items.length);
            initLine(this.lines[lineIndex], lastItems);
          }

          //disable redundant page
          lineIndex++;
          for (var _i = lineIndex; _i < this.lines.length; _i++) {
            this.lines[_i].node.active = false;
          }
        };
        _proto.createFristLine = function createFristLine() {
          var _this$firstLine;
          if (this.firstLine != null) return;
          this.firstLine = this.createLine();
          this.itemPerLine = (_this$firstLine = this.firstLine) == null ? void 0 : _this$firstLine.getChildNumber();
        };
        _proto.createLine = function createLine() {
          var obj = instantiate(this.prefabLine);
          obj.parent = this.content;
          var script = obj.getComponent(ScrollViewBaseLine);
          this.lines.push(script);
          return script;
        };
        _proto.onLineCreateItem = function onLineCreateItem(item) {
          var _this$onCreatedItem;
          (_this$onCreatedItem = this.onCreatedItem) == null || _this$onCreatedItem.call(this, item);
        };
        _proto.onLineSelectItem = function onLineSelectItem(item) {
          var _this$onSelectedItem;
          (_this$onSelectedItem = this.onSelectedItem) == null || _this$onSelectedItem.call(this, item);
        };
        return ScrollViewBase;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "content", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "prefabLine", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ScrollViewBaseItem.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, Component;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "24d73F5z1hKK5U8r6924kDc", "ScrollViewBaseItem", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var ScrollViewBaseItem = exports('ScrollViewBaseItem', (_dec = ccclass('ScrollViewBaseItem'), _dec(_class = /*#__PURE__*/function (_Component) {
        _inheritsLoose(ScrollViewBaseItem, _Component);
        function ScrollViewBaseItem() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this.onSelected = void 0;
          return _this;
        }
        var _proto = ScrollViewBaseItem.prototype;
        _proto.init = function init(data, onSelected) {
          this.onSelected = onSelected;
          //depend on data get sprite from tile controller
        };

        _proto.onTouch_Main = function onTouch_Main() {
          var _this$onSelected;
          (_this$onSelected = this.onSelected) == null || _this$onSelected.call(this, this);
        };
        return ScrollViewBaseItem;
      }(Component)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ScrollViewBaseLine.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ScrollViewBaseItem.ts'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, Component, ScrollViewBaseItem;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
    }, function (module) {
      ScrollViewBaseItem = module.ScrollViewBaseItem;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "4fd8fTpdO9H04vVXP8RzKRM", "ScrollViewBaseLine", undefined);
      var ccclass = _decorator.ccclass;
      var ScrollViewBaseLine = exports('ScrollViewBaseLine', (_dec = ccclass('ScrollViewBaseLine'), _dec(_class = /*#__PURE__*/function (_Component) {
        _inheritsLoose(ScrollViewBaseLine, _Component);
        function ScrollViewBaseLine() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this.items = [];
          _this.itemData = [];
          _this.onSelectItem = void 0;
          _this.onCreatedItem = void 0;
          return _this;
        }
        var _proto = ScrollViewBaseLine.prototype;
        _proto.onLoad = function onLoad() {
          this.getChilds();
        };
        _proto.getChildNumber = function getChildNumber() {
          if (this.items.length > 0) this.items.length;
          this.getChilds();
          return this.items.length;
        };
        _proto.getChilds = function getChilds() {
          if (this.items.length > 0) return;
          this.items = this.getComponentsInChildren(ScrollViewBaseItem);
        };
        _proto.init = function init(items) {
          var _this2 = this;
          this.getChilds();
          this.itemData = items;
          for (var i = 0; i < this.items.length; i++) {
            var _item = this.items[i];
            var isActive = i < items.length;
            if (isActive) {
              isActive = items[0] != null;
            }
            _item.node.active = isActive;
            if (isActive) {
              var _this$onCreatedItem;
              var data = items[i];
              _item.init(data, function (item) {
                _this2.onSelectItem == null || _this2.onSelectItem(item);
              });
              (_this$onCreatedItem = this.onCreatedItem) == null || _this$onCreatedItem.call(this, _item);
            }
          }
        };
        return ScrollViewBaseLine;
      }(Component)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/shadergraph.ts", ['cc'], function () {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      // import { ShaderPropery, ShaderNode, ShaderEdge, resetGlobalShaderSlotID } from "./base";
      cclegacy._RF.push({}, "c03d0yZbI5CPJyIvpnia5dO", "shadergraph", undefined);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/sign.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "48af6KxjgJDrLG+h1577MoC", "sign", undefined);
      var Sign = exports('default', (_dec = register({
        menu: 'Math/Round/Sign',
        title: 'Sign'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Sign, _ShaderNode);
        function Sign() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Sign.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = sign(" + input0 + ");\n        ";
        };
        return Sign;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/simple-noise.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec2, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec2 = module.Vec2;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "35746vutFFE/Y01CS8ARMHq", "simple-noise", undefined);
      var SimpleNoise = exports('default', (_dec = register({
        menu: 'Procedural/Noise/SimpleNoise',
        title: 'SimpleNoise'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(SimpleNoise, _ShaderNode);
        function SimpleNoise() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.depChunks = ['noise'];
          _this.data = {
            inputs: [slot('uv', Vec2.ZERO, 'vec2', 'vector'), slot('scale', 0, 'float', 'vector')],
            outputs: [slot('Out', 0, 'float', 'vector')]
          };
          return _this;
        }
        var _proto = SimpleNoise.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          if (!this.inputs[0].connectSlot) {
            input0 = 'v_uv.xy';
          }
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return output0 + " = SimpleNoise(" + input0 + ", " + input1 + ");";
        };
        return SimpleNoise;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/sine.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "203ea3iMklAUK9FzJeavWJF", "sine", undefined);
      var Sine = exports('default', (_dec = register({
        menu: 'Math/Trigonometry/Sine',
        title: 'Sine'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Sine, _ShaderNode);
        function Sine() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Sine.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = sin(" + input0 + ");\n        ";
        };
        return Sine;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/slider.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, _createClass, cclegacy, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "263a8VilSVCp4Eyo8YtLJnX", "slider", undefined);
      var Slider = exports('default', (_dec = register({
        menu: 'Input/Basic/Slider',
        title: 'Slider'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Slider, _ShaderNode);
        function Slider() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.data = {
            inputs: [slot('In', 0, 'float', 'vector')],
            outputs: [slot('Out', 0, 'float', 'vector')]
          };
          return _this;
        }
        var _proto = Slider.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = " + input0 + ";\n        ";
        };
        _createClass(Slider, [{
          key: "type",
          get: function get() {
            return 'Slider';
          }
        }]);
        return Slider;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/slot.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './utils.ts', './context.ts'], function (exports) {
  var _createClass, cclegacy, ValueType, getPrecisionName, getValueElementStr, getFloatString, getValueConcretePrecision, shaderContext;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      ValueType = module.ValueType;
    }, function (module) {
      getPrecisionName = module.getPrecisionName;
      getValueElementStr = module.getValueElementStr;
      getFloatString = module.getFloatString;
      getValueConcretePrecision = module.getValueConcretePrecision;
    }, function (module) {
      shaderContext = module.shaderContext;
    }],
    execute: function () {
      exports('resetGlobalShaderSlotID', resetGlobalShaderSlotID);
      cclegacy._RF.push({}, "37bc8lcJkpAuZFrukwcAg+H", "slot", undefined);
      var _GlobalShaderSlotID_ = 0;
      function resetGlobalShaderSlotID() {
        _GlobalShaderSlotID_ = 0;
      }
      var ShaderSlotType = exports('ShaderSlotType', /*#__PURE__*/function (ShaderSlotType) {
        ShaderSlotType[ShaderSlotType["Input"] = 0] = "Input";
        ShaderSlotType[ShaderSlotType["Output"] = 1] = "Output";
        return ShaderSlotType;
      }({}));
      var ShaderSlot = exports('ShaderSlot', /*#__PURE__*/function () {
        // otherNode: ShaderNode | undefined = undefined;

        function ShaderSlot(data, node) {
          // typeInfo = {};
          this.data = void 0;
          this.globalID = 0;
          // serialized
          this.id = 0;
          this.displayName = '';
          this.type = ShaderSlotType.Input;
          this.defaultValue = void 0;
          this.value = void 0;
          this.connectSlots = [];
          this.node = undefined;
          this._concretePrecision = -1;
          this.displayName = data.display;
          this.defaultValue = data["default"];
          if (data["default"] instanceof ValueType) {
            this.value = data["default"].clone();
          } else {
            this.value = data["default"];
          }
          this.data = data;
          this.node = node;

          // console.log(`Slot ID ${this.displayName} : ${_GlobalShaderSlotID_}`)

          this.globalID = _GlobalShaderSlotID_++;
        }

        // deserialize (obj: any, node: ShaderNode) {
        //     this.typeInfo = obj.typeInfo;
        //     this.data = getJsonObject(obj.JSONnodeData);

        //     this.type = this.data.m_SlotType as ShaderSlotType;

        //     this.node = node;

        //     this.id = this.data.m_Id;
        //     this.globalID = _GlobalShaderSlotID_++;
        //     this.displayName = this.data.m_DisplayName;
        //     this.defaultValue = this.data.m_DefaultValue;
        //     this.value = this.data.m_Value;
        // }
        _createClass(ShaderSlot, [{
          key: "connectSlot",
          get: function get() {
            var slot = this.connectSlots[0];
            if (slot && shaderContext.getLocalVars.includes(slot.node)) {
              var v = shaderContext.localVars.find(function (v) {
                return v.name === slot.node.name;
              });
              return v.inputs[0].connectSlot;
            }
            return this.connectSlots[0];
          },
          set: function set(v) {
            this.connectSlots.length = 0;
            if (v) {
              this.connectSlots[0] = v;
            }
          }
        }, {
          key: "connectNode",
          get: function get() {
            return this.connectSlot && this.connectSlot.node;
          }
        }, {
          key: "varName",
          get: function get() {
            var _this$node;
            if ((_this$node = this.node) != null && _this$node.isPropertyNode) {
              return this.node.name;
            }
            return 'var_' + this.globalID;
          }
        }, {
          key: "varDefine",
          get: function get() {
            var name = getPrecisionName(this.concretePrecision, this.data.type);
            if (name) {
              name += ' ';
            }
            return name + this.varName;
          }
        }, {
          key: "precisionName",
          get: function get() {
            return getPrecisionName(this.concretePrecision, this.data.type);
          }

          // get defaultValueStr () {
          //     let defaultValue = this.defaultValue;

          //     let x = getFloatString(defaultValue.x);
          //     let y = getFloatString(defaultValue.y);
          //     let z = getFloatString(defaultValue.z);
          //     let w = getFloatString(defaultValue.w);

          //     let result = getFloatString(defaultValue);
          //     if (typeof defaultValue === 'object') {
          //         if (defaultValue.w !== undefined) {
          //             result = `vec4(${x}, ${y}, ${z}, ${w})`;
          //         }
          //         else if (defaultValue.z !== undefined) {
          //             result = `vec3(${x}, ${y}, ${z})`;
          //         }
          //         else if (defaultValue.y !== undefined) {
          //             result = `vec2(${x}, ${y})`;
          //         }
          //     }

          //     return result;
          // }
        }, {
          key: "isVector",
          get: function get() {
            return this.data.connectType === 'vector';
          }
        }, {
          key: "slotValue",
          get: function get() {
            var valueConretePresition = this.defaultConcretePrecision;
            var selfConcretePresition = this.concretePrecision;
            var valueStr = '';
            if (!this.connectSlot) {
              var value = this.value;
              if (!this.isVector) {
                valueStr = value;
              } else {
                var x = getValueElementStr(value, 0);
                var y = getValueElementStr(value, 1);
                var z = getValueElementStr(value, 2);
                var w = getValueElementStr(value, 3);
                if (typeof value !== 'object') {
                  x = getFloatString(value);
                }
                valueConretePresition = getValueConcretePrecision(value);
                var values = [x, y, z, w];
                var concreteValues = [];
                for (var i = 0; i < selfConcretePresition; i++) {
                  concreteValues.push(values[i] === undefined ? 0 : values[i]);
                }
                valueStr = concreteValues.join(', ');
              }
            } else {
              valueConretePresition = this.connectSlot.concretePrecision;
              valueStr = this.connectSlot.varName;
              if (this.isVector && selfConcretePresition !== valueConretePresition) {
                if (selfConcretePresition < valueConretePresition) {
                  if (selfConcretePresition === 1) {
                    valueStr += '.x';
                  } else if (selfConcretePresition === 2) {
                    valueStr += '.xy';
                  } else if (selfConcretePresition === 3) {
                    valueStr += '.xyz';
                  }
                } else {
                  if (valueConretePresition !== 1) {
                    var dif = selfConcretePresition - valueConretePresition;
                    var difValues = [];
                    for (var _i = 0; _i < dif; _i++) {
                      difValues.push('0.');
                    }
                    valueStr += ', ' + difValues.join(', ');
                  }
                }
              }
            }
            var result = "" + valueStr;
            if (this.isVector) {
              if (selfConcretePresition === 2) {
                result = "vec2(" + valueStr + ")";
              } else if (selfConcretePresition === 3) {
                result = "vec3(" + valueStr + ")";
              } else if (selfConcretePresition === 4) {
                result = "vec4(" + valueStr + ")";
              }
            }
            return result;
          }
        }, {
          key: "defaultConcretePrecision",
          get: function get() {
            var concretePrecision = 1;
            var value = this.defaultValue;
            if (typeof value === 'object') {
              if (value.w !== undefined) {
                concretePrecision = 4;
              } else if (value.z !== undefined) {
                concretePrecision = 3;
              } else if (value.y !== undefined) {
                concretePrecision = 2;
              }
            }
            return concretePrecision;
          }
        }, {
          key: "concretePrecision",
          get: function get() {
            if (this._concretePrecision === -1) {
              var value = this.defaultValue;
              if (value === undefined) {
                var _this$node2;
                if ((_this$node2 = this.node) != null && _this$node2.isPropertyNode) {
                  value = this.node.property.value;
                }
              }
              if (value === undefined) {
                console.error('Slot Value is undefined, concrete precision maybe wrong.');
              }
              this._concretePrecision = getValueConcretePrecision(value);
            }
            return this._concretePrecision;
          }
        }]);
        return ShaderSlot;
      }());
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/smoothstep.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "d4d9cMuNpBHKICVJVXTyXRO", "smoothstep", undefined);
      var Smoothstep = exports('default', (_dec = register({
        menu: 'Math/Interpolation/Smoothstep',
        title: 'Smoothstep'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Smoothstep, _ShaderNode);
        function Smoothstep() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('Edge1', Vec4.ZERO, 'vec4', 'vector'), slot('Edge2', Vec4.ZERO, 'vec4', 'vector'), slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Smoothstep.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var input2 = this.getInputValue(2);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = smoothstep(" + input0 + ", " + input1 + ", " + input2 + ");\n        ";
        };
        return Smoothstep;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/SocketEventDefines.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "f75e0dYk2hItL6AtoKH1J3L", "SocketEventDefines", undefined);
      var SOCKET_EVENT = exports('SOCKET_EVENT', /*#__PURE__*/function (SOCKET_EVENT) {
        SOCKET_EVENT["CONNECT"] = "connect";
        SOCKET_EVENT["DISCONNECT"] = "disconnect";
        SOCKET_EVENT["CONNECT_ERROR"] = "connect_error";
        SOCKET_EVENT["CUSTOM_ERROR"] = "custom_error";
        return SOCKET_EVENT;
      }({}));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/SongData.ts", ['cc'], function () {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "9be2aMianZDILhLauesx1FQ", "SongData", undefined);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/SongSelectionManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './BeatmapManager.ts', './AudioManager2.ts', './GameplayManager.ts', './MTUIManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _asyncToGenerator, _regeneratorRuntime, cclegacy, _decorator, ScrollView, Prefab, Node, ToggleContainer, ProgressBar, Label, Sprite, Button, Layout, instantiate, Vec3, tween, Component, BeatmapManager, MagicTilesAudioManager, GameplayManager, MTUIManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _asyncToGenerator = module.asyncToGenerator;
      _regeneratorRuntime = module.regeneratorRuntime;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      ScrollView = module.ScrollView;
      Prefab = module.Prefab;
      Node = module.Node;
      ToggleContainer = module.ToggleContainer;
      ProgressBar = module.ProgressBar;
      Label = module.Label;
      Sprite = module.Sprite;
      Button = module.Button;
      Layout = module.Layout;
      instantiate = module.instantiate;
      Vec3 = module.Vec3;
      tween = module.tween;
      Component = module.Component;
    }, function (module) {
      BeatmapManager = module.BeatmapManager;
    }, function (module) {
      MagicTilesAudioManager = module.MagicTilesAudioManager;
    }, function (module) {
      GameplayManager = module.GameplayManager;
    }, function (module) {
      MTUIManager = module.MTUIManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17;
      cclegacy._RF.push({}, "799d06L3O1HXqAs90sgfX8H", "SongSelectionManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Sorting methods for the song list
       */
      var SortMethod = /*#__PURE__*/function (SortMethod) {
        SortMethod[SortMethod["ALPHABETICAL"] = 0] = "ALPHABETICAL";
        SortMethod[SortMethod["DIFFICULTY"] = 1] = "DIFFICULTY";
        SortMethod[SortMethod["NEWEST"] = 2] = "NEWEST";
        SortMethod[SortMethod["POPULARITY"] = 3] = "POPULARITY";
        return SortMethod;
      }(SortMethod || {});
      /**
       * Difficulty level filter
       */
      var DifficultyFilter = /*#__PURE__*/function (DifficultyFilter) {
        DifficultyFilter[DifficultyFilter["ALL"] = 0] = "ALL";
        DifficultyFilter[DifficultyFilter["EASY"] = 1] = "EASY";
        DifficultyFilter[DifficultyFilter["MEDIUM"] = 2] = "MEDIUM";
        DifficultyFilter[DifficultyFilter["HARD"] = 3] = "HARD";
        DifficultyFilter[DifficultyFilter["EXTREME"] = 4] = "EXTREME";
        return DifficultyFilter;
      }(DifficultyFilter || {});
      /**
       * SongSelectionManager for Magic Tiles 3
       * Handles song list display, filtering, sorting, and song preview
       */
      var SongSelectionManager = exports('SongSelectionManager', (_dec = ccclass('SongSelectionManager'), _dec2 = property(ScrollView), _dec3 = property(Prefab), _dec4 = property(Node), _dec5 = property(Node), _dec6 = property(ToggleContainer), _dec7 = property(ToggleContainer), _dec8 = property(ProgressBar), _dec9 = property(Node), _dec10 = property(Label), _dec11 = property(Sprite), _dec12 = property(Label), _dec13 = property(Label), _dec14 = property(Label), _dec15 = property(Label), _dec16 = property(Label), _dec17 = property(Button), _dec18 = property(Button), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(SongSelectionManager, _Component);
        function SongSelectionManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // UI Components
          _initializerDefineProperty(_this, "songListScrollView", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songItemPrefab", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songItemContainer", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songDetailsPanel", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "difficultyToggles", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "sortMethodToggles", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "previewProgressBar", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "noSongsMessage", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "searchResultsLabel", _descriptor9, _assertThisInitialized(_this));
          // Song Details elements
          _initializerDefineProperty(_this, "songCoverImage", _descriptor10, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songTitleLabel", _descriptor11, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songArtistLabel", _descriptor12, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songBPMLabel", _descriptor13, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songDifficultyLabel", _descriptor14, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "songDurationLabel", _descriptor15, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "playButton", _descriptor16, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "previewButton", _descriptor17, _assertThisInitialized(_this));
          // Manager references
          _this.beatmapManager = null;
          _this.audioManager = null;
          _this.gameplayManager = null;
          // State variables
          _this.loadedBeatmaps = [];
          _this.filteredBeatmaps = [];
          _this.selectedBeatmapId = '';
          _this.previewAudioId = '';
          _this.previewAS = null;
          _this.isPreviewPlaying = false;
          _this.previewUpdateTimer = null;
          // Filter and sort settings
          _this.currentSortMethod = SortMethod.ALPHABETICAL;
          _this.currentDifficultyFilter = DifficultyFilter.ALL;
          _this.searchText = '';
          return _this;
        }
        var _proto = SongSelectionManager.prototype;
        _proto.onLoad = function onLoad() {
          // Get references to managers
          this.beatmapManager = BeatmapManager.instance;
          this.audioManager = MagicTilesAudioManager.instance;

          // Initialize UI
          this.initializeUI();

          // Load beatmap index
          this.loadBeatmaps();
        };
        _proto.onDestroy = function onDestroy() {
          // Stop any playing preview
          this.stopPreview();

          // Clear update timer
          if (this.previewUpdateTimer !== null) {
            clearInterval(this.previewUpdateTimer);
            this.previewUpdateTimer = null;
          }
        }

        /**
         * Initialize UI components
         */;
        _proto.initializeUI = function initializeUI() {
          // Hide song details panel initially
          if (this.songDetailsPanel) {
            this.songDetailsPanel.active = false;
          }

          // Set up sort toggles
          if (this.sortMethodToggles) ;

          // Set up difficulty toggles
          if (this.difficultyToggles) ;

          // Initialize no songs message
          if (this.noSongsMessage) {
            this.noSongsMessage.active = false;
          }

          // Initialize search results label
          if (this.searchResultsLabel) {
            this.searchResultsLabel.node.active = false;
          }
        }

        /**
         * Load all available beatmaps
         */;
        _proto.loadBeatmaps = /*#__PURE__*/
        function () {
          var _loadBeatmaps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  // Show loading indicator
                  MTUIManager.instance.showLoadingScreen(true);

                  // Load beatmap index
                  _context.next = 4;
                  return this.beatmapManager.loadBeatmapIndex();
                case 4:
                  this.loadedBeatmaps = _context.sent;
                  // Apply current filters and sorting
                  this.applyFiltersAndSort();

                  // Hide loading indicator
                  MTUIManager.instance.showLoadingScreen(false);
                  _context.next = 14;
                  break;
                case 9:
                  _context.prev = 9;
                  _context.t0 = _context["catch"](0);
                  console.error("Failed to load beatmaps:", _context.t0);

                  // Hide loading indicator
                  MTUIManager.instance.showLoadingScreen(false);

                  // Show error message
                  MTUIManager.instance.showPopup("Failed to load song list. Please try again later.", "Error");
                case 14:
                case "end":
                  return _context.stop();
              }
            }, _callee, this, [[0, 9]]);
          }));
          function loadBeatmaps() {
            return _loadBeatmaps.apply(this, arguments);
          }
          return loadBeatmaps;
        }()
        /**
         * Refresh the song list UI with current data
         */;

        _proto.refreshSongList = function refreshSongList() {
          var _this2 = this;
          // Clear existing song items
          if (this.songItemContainer) {
            this.songItemContainer.removeAllChildren();
          }

          // Show no songs message if list is empty
          if (this.filteredBeatmaps.length === 0) {
            if (this.noSongsMessage) {
              this.noSongsMessage.active = true;
            }
            return;
          } else {
            if (this.noSongsMessage) {
              this.noSongsMessage.active = false;
            }
          }

          // Show search results count if searching
          if (this.searchText && this.searchResultsLabel) {
            this.searchResultsLabel.string = "Found " + this.filteredBeatmaps.length + " results for \"" + this.searchText + "\"";
            this.searchResultsLabel.node.active = true;
          } else if (this.searchResultsLabel) {
            this.searchResultsLabel.node.active = false;
          }

          // Create song item for each beatmap
          this.filteredBeatmaps.forEach(function (beatmap, index) {
            _this2.createSongItem(beatmap, index);
          });

          // Update layout
          var layout = this.songItemContainer.getComponent(Layout);
          if (layout) {
            layout.updateLayout();
          }
        }

        /**
         * Create a song item in the list
         */;
        _proto.createSongItem = function createSongItem(beatmap, index) {
          var _songItem$getChildByN,
            _songItem$getChildByN2,
            _songItem$getChildByN3,
            _songItem$getChildByN4,
            _this3 = this;
          if (!this.songItemPrefab || !this.songItemContainer) return;

          // Create item from prefab
          var songItem = instantiate(this.songItemPrefab);
          songItem.parent = this.songItemContainer;

          // Set item data
          var titleLabel = (_songItem$getChildByN = songItem.getChildByName("TitleLabel")) == null ? void 0 : _songItem$getChildByN.getComponent(Label);
          var artistLabel = (_songItem$getChildByN2 = songItem.getChildByName("ArtistLabel")) == null ? void 0 : _songItem$getChildByN2.getComponent(Label);
          var difficultyLabel = (_songItem$getChildByN3 = songItem.getChildByName("DifficultyLabel")) == null ? void 0 : _songItem$getChildByN3.getComponent(Label);
          var coverImage = (_songItem$getChildByN4 = songItem.getChildByName("CoverImage")) == null ? void 0 : _songItem$getChildByN4.getComponent(Sprite);
          if (titleLabel) {
            titleLabel.string = beatmap.title;
          }
          if (artistLabel) {
            artistLabel.string = beatmap.artist;
          }
          if (difficultyLabel) {
            difficultyLabel.string = beatmap.difficultyName + " (Lv." + beatmap.level + ")";
          }
          if (coverImage && beatmap.coverImage) ;

          // Highlight if this is the selected song
          if (beatmap.id === this.selectedBeatmapId) {
            var _songItem$getChildByN5;
            var background = (_songItem$getChildByN5 = songItem.getChildByName("Background")) == null ? void 0 : _songItem$getChildByN5.getComponent(Sprite);
            if (background) {
              background.color.set(200, 200, 255, 255);
            }
          }

          // Add click event
          songItem.on(Node.EventType.TOUCH_END, function () {
            _this3.onSongItemClicked(beatmap.id);
          });

          // Stagger animation
          songItem.scale = new Vec3(0.9, 0.9, 1);
          tween(songItem).delay(index * 0.05).to(0.2, {
            scale: new Vec3(1, 1, 1)
          }).start();
        }

        /**
         * Handle song item click
         */;
        _proto.onSongItemClicked = function onSongItemClicked(beatmapId) {
          // Stop any playing preview
          this.stopPreview();

          // Select this beatmap
          this.selectedBeatmapId = beatmapId;

          // Show song details
          this.showSongDetails(beatmapId);

          // Update list to reflect selection
          this.refreshSongList();
        }

        /**
         * Show song details in the details panel
         */;
        _proto.showSongDetails = /*#__PURE__*/
        function () {
          var _showSongDetails = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(beatmapId) {
            var beatmap, totalSeconds, minutes, seconds;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  if (this.songDetailsPanel) {
                    _context2.next = 2;
                    break;
                  }
                  return _context2.abrupt("return");
                case 2:
                  _context2.next = 4;
                  return this.beatmapManager.loadBeatmapInfo(beatmapId);
                case 4:
                  beatmap = _context2.sent;
                  if (beatmap) {
                    _context2.next = 8;
                    break;
                  }
                  console.error("Failed to load beatmap details for ID: " + beatmapId);
                  return _context2.abrupt("return");
                case 8:
                  // Show the details panel
                  this.songDetailsPanel.active = true;

                  // Set details
                  if (this.songTitleLabel) {
                    this.songTitleLabel.string = beatmap.metadata.title;
                  }
                  if (this.songArtistLabel) {
                    this.songArtistLabel.string = beatmap.metadata.artist;
                  }
                  if (this.songBPMLabel) {
                    this.songBPMLabel.string = beatmap.metadata.bpm + " BPM";
                  }
                  if (this.songDifficultyLabel) {
                    this.songDifficultyLabel.string = beatmap.metadata.difficultyName + " (Lv." + beatmap.metadata.level + ")";
                  }
                  if (this.songDurationLabel) {
                    // Format duration as MM:SS
                    totalSeconds = beatmap.notes.length > 0 ? beatmap.notes[beatmap.notes.length - 1].time : 0;
                    minutes = Math.floor(totalSeconds / 60);
                    seconds = Math.floor(totalSeconds % 60); // Use string formatting instead of padStart which may not be available
                    this.songDurationLabel.string = minutes + ":" + (seconds < 10 ? '0' + seconds : seconds);
                  }
                  if (this.songCoverImage && beatmap.metadata.coverImage) ;

                  // Enable play button
                  if (this.playButton) {
                    this.playButton.interactable = true;
                  }

                  // Enable preview button
                  if (this.previewButton) {
                    this.previewButton.interactable = true;
                  }

                  // Animation
                  this.songDetailsPanel.scale = new Vec3(0.9, 0.9, 1);
                  tween(this.songDetailsPanel).to(0.2, {
                    scale: new Vec3(1, 1, 1)
                  }).start();
                case 19:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this);
          }));
          function showSongDetails(_x) {
            return _showSongDetails.apply(this, arguments);
          }
          return showSongDetails;
        }()
        /**
         * Start song preview
         */;

        _proto.startPreview = function startPreview() {
          var _beatmap$metadata$pre,
            _this4 = this;
          if (!this.selectedBeatmapId) return;

          // Get selected beatmap
          var beatmap = this.beatmapManager.getActiveBeatmap();
          if (!beatmap) return;

          // Stop any existing preview
          this.stopPreview();

          // Start preview from preview section
          var previewStart = ((_beatmap$metadata$pre = beatmap.metadata.preview) == null ? void 0 : _beatmap$metadata$pre.start) || 0;
          this.previewAS = this.audioManager.playSound(beatmap.metadata.audioPath, 0.8);

          // Set as playing
          this.isPreviewPlaying = true;

          // Update button state
          if (this.previewButton) {
            var _this$previewButton$n;
            var buttonLabel = (_this$previewButton$n = this.previewButton.node.getChildByName("Label")) == null ? void 0 : _this$previewButton$n.getComponent(Label);
            if (buttonLabel) {
              buttonLabel.string = "Stop";
            }
          }

          // Start progress update
          this.previewUpdateTimer = setInterval(function () {
            _this4.updatePreviewProgress();
          }, 100);
        }

        /**
         * Stop song preview
         */;
        _proto.stopPreview = function stopPreview() {
          if (this.previewAudioId && this.isPreviewPlaying) {
            this.previewAS.stop();
            this.isPreviewPlaying = false;

            // Update button state
            if (this.previewButton) {
              var _this$previewButton$n2;
              var buttonLabel = (_this$previewButton$n2 = this.previewButton.node.getChildByName("Label")) == null ? void 0 : _this$previewButton$n2.getComponent(Label);
              if (buttonLabel) {
                buttonLabel.string = "Preview";
              }
            }

            // Clear update timer
            if (this.previewUpdateTimer !== null) {
              clearInterval(this.previewUpdateTimer);
              this.previewUpdateTimer = null;
            }

            // Reset progress bar
            if (this.previewProgressBar) {
              this.previewProgressBar.progress = 0;
            }
          }
        }

        /**
         * Toggle preview play/stop
         */;
        _proto.togglePreview = function togglePreview() {
          if (this.isPreviewPlaying) {
            this.stopPreview();
          } else {
            this.startPreview();
          }
        }

        /**
         * Update preview progress bar
         */;
        _proto.updatePreviewProgress = function updatePreviewProgress() {
          if (!this.isPreviewPlaying || !this.previewProgressBar) return;

          // Get audio source and update progress
          var audioSource = this.previewAS;
          if (audioSource) {
            var duration = audioSource.duration;
            var currentTime = audioSource.currentTime;
            if (duration > 0) {
              this.previewProgressBar.progress = currentTime / duration;
            }

            // Check if preview finished
            if (currentTime >= duration) {
              this.stopPreview();
            }
          }
        }

        /**
         * Apply filters and sorting to the beatmap list
         */;
        _proto.applyFiltersAndSort = function applyFiltersAndSort() {
          var _this5 = this;
          if (!this.loadedBeatmaps.length) return;

          // Start with all beatmaps
          this.filteredBeatmaps = [].concat(this.loadedBeatmaps);

          // Apply difficulty filter
          if (this.currentDifficultyFilter !== DifficultyFilter.ALL) {
            this.filteredBeatmaps = this.filteredBeatmaps.filter(function (beatmap) {
              // Map difficulty level to filter
              var level = beatmap.level;
              switch (_this5.currentDifficultyFilter) {
                case DifficultyFilter.EASY:
                  return level <= 3;
                case DifficultyFilter.MEDIUM:
                  return level > 3 && level <= 6;
                case DifficultyFilter.HARD:
                  return level > 6 && level <= 9;
                case DifficultyFilter.EXTREME:
                  return level > 9;
                default:
                  return true;
              }
            });
          }

          // Apply search filter
          if (this.searchText) {
            var searchLower = this.searchText.toLowerCase();
            this.filteredBeatmaps = this.filteredBeatmaps.filter(function (beatmap) {
              return beatmap.title.toLowerCase().includes(searchLower) || beatmap.artist.toLowerCase().includes(searchLower);
            });
          }

          // Apply sorting
          switch (this.currentSortMethod) {
            case SortMethod.ALPHABETICAL:
              this.filteredBeatmaps.sort(function (a, b) {
                return a.title.localeCompare(b.title);
              });
              break;
            case SortMethod.DIFFICULTY:
              this.filteredBeatmaps.sort(function (a, b) {
                return a.level - b.level;
              });
              break;
            case SortMethod.NEWEST:
              // Assuming newer songs have higher IDs for now
              this.filteredBeatmaps.sort(function (a, b) {
                return b.id.localeCompare(a.id);
              });
              break;
            case SortMethod.POPULARITY:
              // TODO: Implement popularity sorting when we have play count data
              break;
          }

          // Refresh the UI
          this.refreshSongList();
        }

        /**
         * Set the current sorting method
         */;
        _proto.setSortMethod = function setSortMethod(method) {
          this.currentSortMethod = method;
          this.applyFiltersAndSort();
        }

        /**
         * Set the current difficulty filter
         */;
        _proto.setDifficultyFilter = function setDifficultyFilter(filter) {
          this.currentDifficultyFilter = filter;
          this.applyFiltersAndSort();
        }

        /**
         * Set search text
         */;
        _proto.setSearchText = function setSearchText(text) {
          this.searchText = text;
          this.applyFiltersAndSort();
        }

        /**
         * Start playing the selected song
         */;
        _proto.playSong = function playSong() {
          if (!this.selectedBeatmapId) return;

          // Stop any preview
          this.stopPreview();

          // Get gameplay manager
          if (!this.gameplayManager) {
            var _this$node$parent;
            var gameplayManagerNode = (_this$node$parent = this.node.parent) == null ? void 0 : _this$node$parent.getChildByName("GameplayManager");
            if (gameplayManagerNode) {
              this.gameplayManager = gameplayManagerNode.getComponent(GameplayManager);
            }
          }
          if (!this.gameplayManager) {
            console.error("GameplayManager not found");
            return;
          }

          // Start the game with selected beatmap
          this.gameplayManager.LoadBeatMap(this.selectedBeatmapId);
        };
        return SongSelectionManager;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "songListScrollView", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "songItemPrefab", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "songItemContainer", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "songDetailsPanel", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "difficultyToggles", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "sortMethodToggles", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "previewProgressBar", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "noSongsMessage", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "searchResultsLabel", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "songCoverImage", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "songTitleLabel", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "songArtistLabel", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "songBPMLabel", [_dec14], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, "songDifficultyLabel", [_dec15], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor15 = _applyDecoratedDescriptor(_class2.prototype, "songDurationLabel", [_dec16], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor16 = _applyDecoratedDescriptor(_class2.prototype, "playButton", [_dec17], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor17 = _applyDecoratedDescriptor(_class2.prototype, "previewButton", [_dec18], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/sphere-mask.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "2fd4cAU0iRIFbD4p8meWHjx", "sphere-mask", undefined);
      var SphereMask = exports('default', (_dec = register({
        menu: 'Math/Vector/SphereMask',
        title: 'SphereMask'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(SphereMask, _ShaderNode);
        function SphereMask() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('Coords', Vec4.ZERO, 'vec4', 'vector'), slot('Center', Vec4.ZERO, 'vec4', 'vector'), slot('Radius', 0, 'float', 'vector'), slot('Hardness', 0, 'float', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = SphereMask.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var input2 = this.getInputValue(2);
          var input3 = this.getInputValue(3);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = 1 - saturate((distance(" + input0 + ", " + input1 + ") - " + input2 + ") / (1 - " + input3 + "));\n        ";
        };
        return SphereMask;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/split.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './index3.ts', './base.ts', './type.ts', './utils.ts', './register.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, ShaderNode, ConcretePrecisionType, slot, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, null, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "3da06y4hU1Ow4fHMuaVh9Ox", "split", undefined);
      var SplitNode = exports('default', (_dec = register({
        menu: 'Channel/Split',
        title: 'Split'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(SplitNode, _ShaderNode);
        function SplitNode() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.data = {
            inputs: [slot('Vector', new Vec4(), 'vec4', 'vector')],
            outputs: [slot('R', 0, 'float', 'vector'), slot('G', 0, 'float', 'vector'), slot('B', 0, 'float', 'vector'), slot('A', 0, 'float', 'vector')]
          };
          return _this;
        }
        var _proto = SplitNode.prototype;
        _proto.generateCode = function generateCode() {
          var _this2 = this;
          var Value = this.getInputValue(0);
          var codes = [];
          this.data.outputs.forEach(function (o) {
            var slot = _this2.getOutputSlotWithSlotName(o.display);
            if (slot && slot.connectSlot) {
              codes.push("float " + (slot == null ? void 0 : slot.varName) + " = " + Value + "." + o.display.toLowerCase() + ";");
            }
          });
          return codes.join('\n');
        };
        return SplitNode;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/square-wave.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "d9905hEvfVIh6Iwo+//rZfV", "square-wave", undefined);
      var SquareWave = exports('default', (_dec = register({
        menu: 'Math/Wave/SquareWave',
        title: 'SquareWave'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(SquareWave, _ShaderNode);
        function SquareWave() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = SquareWave.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = 1.0 - 2.0 * round(frac(" + input0 + "));\n        ";
        };
        return SquareWave;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/square.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "861eejAxE9Kk5MHkzbOdXlI", "square", undefined);
      var Square = exports('default', (_dec = register({
        menu: 'Math/Basic/Square',
        title: 'Square'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Square, _ShaderNode);
        function Square() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Square.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = sqrt(" + input0 + ");\n        ";
        };
        return Square;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/step.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "2b4cb9lBRBMqrQTPqc1e+XN", "step", undefined);
      var Step = exports('default', (_dec = register({
        menu: 'Math/Round/Step',
        title: 'Step'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Step, _ShaderNode);
        function Step() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('Edge', Vec4.ZERO, 'vec4', 'vector'), slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Step.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = step(" + input0 + ", " + input1 + ");\n        ";
        };
        return Step;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/storageManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Utils2.ts'], function (exports) {
  var _createClass, cclegacy, _decorator, sys, native, log, Utils;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      sys = module.sys;
      native = module.native;
      log = module.log;
    }, function (module) {
      Utils = module.Utils;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "5e557ZxbcNFsbXuz8xq4hnD", "storageManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var StorageManager = exports('StorageManager', (_dec = ccclass("StorageManager"), _dec(_class = (_class2 = /*#__PURE__*/function () {
        function StorageManager() {
          this._jsonData = {};
          this._path = null;
          this.KEY_CONFIG = 'coindfo';
          this._markSave = false;
          this._saveTimer = -1;
        }
        var _proto = StorageManager.prototype;
        _proto.start = function start() {
          this._jsonData = {
            "userId": ""
          };
          this._path = this._getConfigPath();
          var content;
          if (sys.isNative) {
            var valueObject = native.fileUtils.getValueMapFromFile(this._path);
            content = valueObject[this.KEY_CONFIG];
          } else {
            content = sys.localStorage.getItem(this.KEY_CONFIG);
          }
          if (content && content.length) {
            if (content.startsWith('@')) {
              content = content.substring(1);
              content = Utils.decrypt(content);
            }
            try {
              var jsonData = JSON.parse(content);
              this._jsonData = jsonData;
            } catch (excepaiton) {}
          }

          // this._saveTimer = setInterval(() => {
          //     this.scheduleSave();
          // }, 5000);
        }

        /**
         * @param {string}key  
         * @param {any}value  
         */;
        _proto.setConfigDataWithoutSave = function setConfigDataWithoutSave(key, value) {
          var account = this._jsonData.userId;
          if (this._jsonData[account]) {
            this._jsonData[account][key] = value;
          } else {
            console.error("no account can not save");
          }
        }

        /**
           * @param {string}key  
           * @param {any}value  
           */;
        _proto.setConfigData = function setConfigData(key, value) {
          this.setConfigDataWithoutSave(key, value);
          this._markSave = true;
        }

        /**
         * @param {string} key 
         * @returns 
         */;
        _proto.getConfigData = function getConfigData(key) {
          var account = this._jsonData.userId;
          if (this._jsonData[account]) {
            var value = this._jsonData[account][key];
            return value ? value : "";
          } else {
            log("no account can not load");
            return "";
          }
        }

        //remove global data
        ;

        _proto.removeGlobalData = function removeGlobalData(input) {
          delete this._jsonData[input];
          return;
        }

        /**
         * @param {string} key 
         * @param {any}value  
         * @returns 
         */;
        _proto.setGlobalData = function setGlobalData(key, value) {
          this._jsonData[key] = value;
          this.save();
        }

        /**
         * 
         * @param {string} key 
         * @returns 
         */;
        _proto.getGlobalData = function getGlobalData(key) {
          return this._jsonData[key];
        }

        /**
         * @param {string} userId 
         * @returns 
         */;
        _proto.setUserId = function setUserId(userId) {
          this._jsonData.userId = userId;
          if (!this._jsonData[userId]) {
            this._jsonData[userId] = {};
          }
          this.save();
        }

        /**
         * @returns {string}
         */;
        _proto.getUserId = function getUserId() {
          return this._jsonData.userId;
        }

        /**
         * @returns 
         */;
        _proto.scheduleSave = function scheduleSave() {
          if (!this._markSave) {
            return;
          }
          this.save();
        };
        _proto.markModified = function markModified() {
          this._markSave = true;
        };
        _proto.save = function save() {
          var str = JSON.stringify(this._jsonData);
          var zipStr = '@' + Utils.encrypt(str);
          this._markSave = false;
          if (!sys.isNative) {
            var ls = sys.localStorage;
            ls.setItem(this.KEY_CONFIG, zipStr);
            return;
          }
          var valueObj = {};
          valueObj[this.KEY_CONFIG] = zipStr;
          native.fileUtils.writeValueMapToFile(valueObj, this._getConfigPath());
        }

        /**
         * @returns 
         */;
        _proto._getConfigPath = function _getConfigPath() {
          var platform = sys.platform;
          var path = "";
          if (platform === sys.OS.WINDOWS) {
            path = "src/conf";
          } else if (platform === sys.OS.LINUX) {
            path = "./conf";
          } else {
            if (sys.isNative) {
              path = native.fileUtils.getWritablePath();
              path = path + "conf";
            } else {
              path = "src/conf";
            }
          }
          return path;
        };
        _createClass(StorageManager, null, [{
          key: "instance",
          get: function get() {
            if (this._instance) {
              return this._instance;
            }
            this._instance = new StorageManager();
            this._instance.start();
            return this._instance;
          }
        }]);
        return StorageManager;
      }(), _class2._instance = void 0, _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/SubGraphNode.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './base.ts', './index3.ts', './utils.ts', './register.ts'], function (exports) {
  var _inheritsLoose, cclegacy, ShaderNode, slot, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, null, function (module) {
      slot = module.slot;
    }, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "159abqfjclCYp0gqjzKIy69", "SubGraphNode", undefined);
      var SubGraphNode = exports('default', (_dec = register({
        style: {
          headerColor: '#757575'
        }
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(SubGraphNode, _ShaderNode);
        function SubGraphNode() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', 0, 'any', 'any')],
            outputs: [slot('Out', 0, 'any', 'any')]
          };
          return _this;
        } // nodes: ShaderNode[] = []
        // nodeMap: Map<string, ShaderNode> = new Map
        // properties: ShaderPropery[] = []
        //
        // subgraphOutNode: SubGraphOutputNode | null = null;
        //
        // concretePrecisionType = ConcretePrecisionType.Fixed;
        //
        // constructor (data) {
        //     super(data)
        //
        //     let name = this.data.m_Name;
        //     let subgraphPath = path.join(ShaderGraph.subgraphPath, `**/${name}.*`).replace(/\\/g, '/');
        //     let paths = globby.sync(subgraphPath)
        //     paths = paths.filter(p => path.extname(p).toLowerCase() === '.shadersubgraph')
        //     if (!paths[0]) {
        //         console.error(`Can not find sub graph with name [${name}]`)
        //         return;
        //     }
        //
        //     let res = ShaderGraph.searchNodes(paths[0]);
        //     if (!res) {
        //         return;
        //     }
        //
        //     let { properties, nodeMap, nodes, edges } = res;
        //
        //     this.nodes = nodes;
        //     this.nodeMap = nodeMap;
        //     this.properties = properties;
        //
        //     let subgraphOutNode = nodes.find(n => n instanceof SubGraphOutputNode)
        //     if (!subgraphOutNode) {
        //         console.error(`Can not find SubGraphOutputNode for [${name}]`)
        //         return;
        //     }
        //
        //     this.subgraphOutNode = subgraphOutNode;
        //
        // }
        //
        // excahngeSubGraphOutNode (outputEdgeSlot: ShaderEdgeSlot) {
        //     let outputNode = this as ShaderNode;
        //
        //     let outputSlot = this.slotsMap.get(outputEdgeSlot.id);
        //     let subgraphSlot = this.subgraphOutNode?.getSlotWithSlotName(outputSlot?.displayName);
        //
        //     if (subgraphSlot && subgraphSlot.connectSlot) {
        //         //@ts-ignore
        //         outputNode = subgraphSlot.connectSlot.node;
        //         outputEdgeSlot.id = subgraphSlot.connectSlot.id;
        //         //@ts-ignore
        //         outputEdgeSlot.nodeUuid = subgraphSlot.connectSlot.node?.uuid;
        //         if (outputNode && subgraphSlot) {
        //             subgraphSlot.connectSlots.length = 0;
        //         }
        //     }
        //
        //     return outputNode;
        // }
        //
        // exchangeSubGraphInputNodes () {
        //     let inputSlots = this.inputSlots;
        //
        //     let propertyNodes = this.nodes.filter(n => n instanceof PropertyNode);
        //     propertyNodes.forEach(node => {
        //         let propertySlot = node.outputSlots[0];
        //         let propertyName = propertySlot.displayName;
        //
        //         let inputSlot = inputSlots.find(slot => slot.displayName === propertyName);
        //
        //         if (inputSlot) {
        //             let outputSlot = inputSlot.connectSlot;
        //             if (outputSlot) {
        //                 propertySlot.connectSlots.forEach(inputSlotInSubGraph => {
        //                     inputSlotInSubGraph.connectSlot = outputSlot;
        //                     outputSlot.connectSlots = outputSlot.connectSlots.filter(slot => slot === inputSlot);
        //
        //                     if (outputSlot.node) {
        //                         inputSlotInSubGraph.node?.addDependency(outputSlot.node);
        //                         //@ts-ignore
        //                         outputSlot.node.setPriority(inputSlotInSubGraph.node.priority + 1);
        //                     }
        //                 })
        //
        //                 //@ts-ignore
        //                 inputSlot.connectSlot = null;
        //             }
        //             else {
        //                 propertySlot.connectSlots.forEach(inputSlotInSubGraph => {
        //                     inputSlotInSubGraph.connectSlot = inputSlot!;
        //                     // inputSlot.connectSlots.push(inputSlotInSubGraph);
        //
        //                     if (inputSlot!.node) {
        //                         inputSlotInSubGraph.node?.addDependency(this);
        //                         //@ts-ignore
        //                         this.setPriority(inputSlotInSubGraph.node.priority + 1);
        //                     }
        //                 });
        //             }
        //         }
        //
        //     })
        // }
        //
        // generateCode () {
        //     let code = '';
        //     let inputSlots = this.inputSlots;
        //     for (let i = 0; i < inputSlots.length; i++) {
        //         // if (!inputSlots[i].connectSlot) continue;
        //         code += `${inputSlots[i].varDefine} = ${inputSlots[i].defaultValueStr};\n`;
        //     }
        //     return code;
        // }
        return SubGraphNode;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/SubGraphOutputNode.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './base.ts', './index3.ts', './utils.ts', './register.ts'], function (exports) {
  var _inheritsLoose, cclegacy, ShaderNode, slot, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, null, function (module) {
      slot = module.slot;
    }, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "a7a1dWl92NFI7N6B5WUHBcO", "SubGraphOutputNode", undefined);
      var SubGraphOutputNode = exports('default', (_dec = register({
        title: 'Output',
        master: true,
        style: {
          headerColor: '#81ff2f'
        }
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(SubGraphOutputNode, _ShaderNode);
        function SubGraphOutputNode() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('Out', 0, 'any', 'any')]
          };
          return _this;
        }
        return SubGraphOutputNode;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/substract.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "5fbb9DNFjJODZFHdbDe+csv", "substract", undefined);
      var Substract = exports('default', (_dec = register({
        menu: 'Math/Basic/Substract',
        title: 'Substract'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Substract, _ShaderNode);
        function Substract() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Max;
          _this.data = {
            inputs: [slot('A', Vec4.ZERO, 'vec4', 'vector'), slot('B', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Substract.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = " + input0 + " - " + input1 + ";\n        ";
        };
        return Substract;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/SurfaceMasterNode.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './MasterNode.ts', './utils.ts', './index3.ts', './context.ts', './register.ts'], function (exports) {
  var _inheritsLoose, _createClass, cclegacy, Vec3, Vec4, MasterNode, MasterSlotType, slot, path, shaderContext, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec3 = module.Vec3;
      Vec4 = module.Vec4;
    }, function (module) {
      MasterNode = module.default;
      MasterSlotType = module.MasterSlotType;
    }, function (module) {
      slot = module.slot;
      path = module.path;
    }, null, function (module) {
      shaderContext = module.shaderContext;
    }, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "3dc0bllbkxAsKzvUgvzcrgb", "SurfaceMasterNode", undefined);
      var SurfaceMasterNode = exports('default', (_dec = register({
        title: 'Surface',
        master: true
      }), _dec(_class = /*#__PURE__*/function (_MasterNode) {
        _inheritsLoose(SurfaceMasterNode, _MasterNode);
        function SurfaceMasterNode() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _MasterNode.call.apply(_MasterNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('Vertex Position', Vec3.ZERO, 'vec3', 'vector', {
              slotType: MasterSlotType.Vertex,
              codeChunk: 0
            }), slot('Vertex Normal', Vec3.ZERO, 'vec3', 'vector', {
              slotType: MasterSlotType.Vertex,
              codeChunk: 0
            }), slot('Vertex Tangent', Vec3.ZERO, 'vec3', 'vector', {
              slotType: MasterSlotType.Vertex,
              codeChunk: 0
            }), slot('Albedo', new Vec4(0.5, 0.5, 0.5, 0.5), 'color', 'vector', {
              slotType: MasterSlotType.Fragment,
              codeChunk: 3
            }), slot('Normal', Vec3.ZERO, 'vec3', 'vector', {
              slotType: MasterSlotType.Fragment,
              codeChunk: 3
            }), slot('Emission', Vec3.ZERO, 'vec3', 'vector', {
              slotType: MasterSlotType.Fragment,
              codeChunk: 3
            }), slot('Metallic', 0.6, 'float', 'vector', {
              slotType: MasterSlotType.Fragment,
              codeChunk: 3
            }), slot('Roughness', 0.5, 'float', 'vector', {
              slotType: MasterSlotType.Fragment,
              codeChunk: 3
            }), slot('Occlusion', 1, 'float', 'vector', {
              slotType: MasterSlotType.Fragment,
              codeChunk: 3
            }), slot('SpecularIntensity', 0.5, 'float', 'vector', {
              slotType: MasterSlotType.Fragment,
              codeChunk: 3
            }), slot('Alpha', 1, 'float', 'vector', {
              slotType: MasterSlotType.Fragment,
              codeChunk: 3
            }), slot('AlphaClipThreshold', 0.5, 'float', 'vector', {
              slotType: MasterSlotType.Fragment,
              codeChunk: 3
            }), slot('AnisotropyRotation', 0, 'float', 'vector', {
              slotType: MasterSlotType.Fragment,
              codeChunk: 3
            }), slot('AnisotropyShape', 1, 'float', 'vector', {
              slotType: MasterSlotType.Fragment,
              codeChunk: 3
            })]
          };
          return _this;
        }
        var _proto = SurfaceMasterNode.prototype;
        _proto.generateCode = function generateCode() {
          var _this$getSlotWithSlot, _this$getSlotWithSlot2;
          var AnisotropyRotationConnected = (_this$getSlotWithSlot = this.getSlotWithSlotName('AnisotropyRotation')) == null ? void 0 : _this$getSlotWithSlot.connectSlot;
          var AnisotropyShapeConnected = (_this$getSlotWithSlot2 = this.getSlotWithSlotName('AnisotropyShape')) == null ? void 0 : _this$getSlotWithSlot2.connectSlot;

          // if (AnisotropyRotationConnected || AnisotropyShapeConnected) {
          //     this.defines = [
          //         '#define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY',
          //         '#define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 15',
          //     ];
          // }

          return _MasterNode.prototype.generateCode.call(this);
        };
        _createClass(SurfaceMasterNode, [{
          key: "templatePath",
          get: function get() {
            return path.join(shaderContext.shaderTemplatesDir, 'master/SurfaceMasterNode.effect');
          }
        }]);
        return SurfaceMasterNode;
      }(MasterNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/tangent.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "adcb4trf/1C6627yz7YeTXn", "tangent", undefined);
      var Tangent = exports('default', (_dec = register({
        menu: 'Math/Trigonometry/Tangent',
        title: 'Tangent'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Tangent, _ShaderNode);
        function Tangent() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Tangent.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = tan(" + input0 + ");\n        ";
        };
        return Tangent;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/TapValidator.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Tile.ts', './BeatmapManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Component, HitRating, BeatmapManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
    }, function (module) {
      HitRating = module.HitRating;
    }, function (module) {
      BeatmapManager = module.BeatmapManager;
    }],
    execute: function () {
      var _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;
      cclegacy._RF.push({}, "7032aoU25dAwZKrnbS2Peig", "TapValidator", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * Interface for combo data
       */

      /**
       * TapValidator for Magic Tiles 3
       * Validates tap timing accuracy and manages combos
       */
      var TapValidator = exports('TapValidator', (_dec = ccclass('TapValidator'), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(TapValidator, _Component);
        function TapValidator() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Audio offset (milliseconds) - to adjust for audio latency
          _initializerDefineProperty(_this, "audioOffset", _descriptor, _assertThisInitialized(_this));
          // Perfect hit window (seconds)
          _initializerDefineProperty(_this, "perfectWindow", _descriptor2, _assertThisInitialized(_this));
          // 50ms
          // Good hit window (seconds)
          _initializerDefineProperty(_this, "goodWindow", _descriptor3, _assertThisInitialized(_this));
          // 100ms
          // OK hit window (seconds)
          _initializerDefineProperty(_this, "okWindow", _descriptor4, _assertThisInitialized(_this));
          // 150ms
          // Reference to beatmap manager
          _this.beatmapManager = null;
          // Combo data
          _this.combo = {
            count: 0,
            maxCount: 0,
            lastRating: HitRating.MISS,
            perfectCount: 0,
            goodCount: 0,
            okCount: 0,
            missCount: 0
          };
          // Callback for combo change events
          _this.onComboChangeCallbacks = [];
          // Callback for rating events
          _this.onRatingCallbacks = [];
          return _this;
        }
        var _proto = TapValidator.prototype;
        _proto.onLoad = function onLoad() {
          this.resetCombo();
          this.beatmapManager = BeatmapManager.instance;
        }

        /**
         * Validate a tap at a specific time
         * @param lane The lane that was tapped
         * @param tapTime The time of the tap
         * @param rating The hit rating from the tile manager
         * @returns The hit rating for the tap
         */;
        _proto.validateTap = function validateTap(lane, tapTime, rating) {
          // Update combo based on rating
          this.updateCombo(rating);
          console.log("combo", this.combo);

          // Notify listeners of the rating
          this.onRatingCallbacks.forEach(function (callback) {
            return callback(lane, rating);
          });
          return rating;
        }

        /**
         * Update the combo based on the hit rating
         * @param rating The hit rating
         */;
        _proto.updateCombo = function updateCombo(rating) {
          var _this2 = this;
          // Update rating counts
          switch (rating) {
            case HitRating.PERFECT:
              this.combo.perfectCount++;
              this.combo.count++;
              break;
            case HitRating.GREAT:
              this.combo.goodCount++;
              this.combo.count = 0; // Reset combo on miss
              break;
            case HitRating.COOL:
              this.combo.okCount++;
              this.combo.count = 0; // Reset combo on miss
              break;
            case HitRating.MISS:
              this.combo.missCount++;
              this.combo.count = 0; // Reset combo on miss
              break;
          }

          // Update max combo
          if (this.combo.count > this.combo.maxCount) {
            this.combo.maxCount = this.combo.count;
          }

          // Store last rating
          this.combo.lastRating = rating;

          // Notify combo change listeners
          this.onComboChangeCallbacks.forEach(function (callback) {
            return callback(_this2.combo.count);
          });
        }

        /**
         * Reset the combo and statistics
         */;
        _proto.resetCombo = function resetCombo() {
          this.combo = {
            count: 0,
            maxCount: 0,
            lastRating: HitRating.MISS,
            perfectCount: 0,
            goodCount: 0,
            okCount: 0,
            missCount: 0
          };

          // Notify combo change listeners
          this.onComboChangeCallbacks.forEach(function (callback) {
            return callback(0);
          });
        }

        /**
         * Get the current combo
         */;
        _proto.getCombo = function getCombo() {
          return this.combo.count;
        }

        /**
         * Get the max combo
         */;
        _proto.getMaxCombo = function getMaxCombo() {
          return this.combo.maxCount;
        }

        /**
         * Get the accuracy percentage
         * @returns Accuracy as a percentage (0-100)
         */;
        _proto.getAccuracy = function getAccuracy() {
          var totalNotes = this.combo.perfectCount + this.combo.goodCount + this.combo.okCount + this.combo.missCount;
          if (totalNotes === 0) return 100; // No notes hit yet

          // Weight different ratings
          var weightedSum = this.combo.perfectCount * 100 + this.combo.goodCount * 80 + this.combo.okCount * 50;
          return Math.round(weightedSum / (totalNotes * 100) * 100);
        }

        /**
         * Get the counts of each rating
         */;
        _proto.getRatingCounts = function getRatingCounts() {
          return {
            perfect: this.combo.perfectCount,
            good: this.combo.goodCount,
            ok: this.combo.okCount,
            miss: this.combo.missCount
          };
        }

        /**
         * Get the total number of notes hit
         */;
        _proto.getTotalNotes = function getTotalNotes() {
          return this.combo.perfectCount + this.combo.goodCount + this.combo.okCount + this.combo.missCount;
        }

        /**
         * Register a callback for combo changes
         * @param callback Function to call when the combo changes
         */;
        _proto.onComboChange = function onComboChange(callback) {
          this.onComboChangeCallbacks.push(callback);
        }

        /**
         * Remove a combo change callback
         * @param callback The callback to remove
         */;
        _proto.offComboChange = function offComboChange(callback) {
          var index = this.onComboChangeCallbacks.indexOf(callback);
          if (index !== -1) {
            this.onComboChangeCallbacks.splice(index, 1);
          }
        }

        /**
         * Register a callback for rating events
         * @param callback Function to call when a rating is determined
         */;
        _proto.onRating = function onRating(callback) {
          this.onRatingCallbacks.push(callback);
        }

        /**
         * Remove a rating callback
         * @param callback The callback to remove
         */;
        _proto.offRating = function offRating(callback) {
          var index = this.onRatingCallbacks.indexOf(callback);
          if (index !== -1) {
            this.onRatingCallbacks.splice(index, 1);
          }
        }

        /**
         * Set the audio offset
         * @param offsetMs Offset in milliseconds
         */;
        _proto.setAudioOffset = function setAudioOffset(offsetMs) {
          this.audioOffset = offsetMs;
        }

        /**
         * Get the audio offset
         * @returns Offset in milliseconds
         */;
        _proto.getAudioOffset = function getAudioOffset() {
          return this.audioOffset;
        }

        /**
         * Set the hit windows
         * @param perfect Perfect hit window in seconds
         * @param good Good hit window in seconds
         * @param ok OK hit window in seconds
         */;
        _proto.setHitWindows = function setHitWindows(perfect, good, ok) {
          this.perfectWindow = perfect;
          this.goodWindow = good;
          this.okWindow = ok;
        }

        /**
         * Check if a combo milestone has been reached
         * @param milestone The milestone to check (e.g., 50, 100, 200)
         * @returns Whether the milestone was just reached
         */;
        _proto.isComboMilestone = function isComboMilestone(milestone) {
          return this.combo.count === milestone;
        }

        /**
         * Calculate a score based on performance
         * @returns Score value
         */;
        _proto.calculateScore = function calculateScore() {
          var comboBonus = Math.min(this.combo.maxCount / 10, 100); // Cap at 100
          var accuracyBonus = this.getAccuracy();

          // Calculate base score from rating counts
          var baseScore = this.combo.perfectCount * 1000 + this.combo.goodCount * 500 + this.combo.okCount * 100;

          // Apply bonuses
          return Math.round(baseScore * (1 + comboBonus / 100 + accuracyBonus / 100));
        };
        return TapValidator;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "audioOffset", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "perfectWindow", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.05;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "goodWindow", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.1;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "okWindow", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.15;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/texture-asset.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './base.ts', './type.ts'], function (exports) {
  var _inheritsLoose, cclegacy, ShaderNode, ConcretePrecisionType;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }],
    execute: function () {
      cclegacy._RF.push({}, "ae6c5dYR/dM3qMNrhlBY9Hs", "texture-asset", undefined);
      var TextureAsset = exports('default', /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(TextureAsset, _ShaderNode);
        function TextureAsset() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Texture;
          return _this;
        }
        return TextureAsset;
      }(ShaderNode));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/texture2d-asset.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './texture-asset.ts'], function (exports) {
  var _inheritsLoose, cclegacy, TextureAsset;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      TextureAsset = module.default;
    }],
    execute: function () {
      cclegacy._RF.push({}, "1e7d5h/dpNKOKPycPdVfiDZ", "texture2d-asset", undefined);
      var Texture2DAsset = exports('default', /*#__PURE__*/function (_TextureAssetNode) {
        _inheritsLoose(Texture2DAsset, _TextureAssetNode);
        function Texture2DAsset() {
          return _TextureAssetNode.apply(this, arguments) || this;
        }
        var _proto = Texture2DAsset.prototype;
        _proto.generateCode = function generateCode() {
          return "sampler2D " + this.getOutputVarName(0) + " = " + this.getInputValue(0) + ";";
        };
        return Texture2DAsset;
      }(TextureAsset));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/Tile.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './MTDefines.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Sprite, UITransform, UIOpacity, Node, Vec3, Size, game, tween, Component, Color, NoteType;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Sprite = module.Sprite;
      UITransform = module.UITransform;
      UIOpacity = module.UIOpacity;
      Node = module.Node;
      Vec3 = module.Vec3;
      Size = module.Size;
      game = module.game;
      tween = module.tween;
      Component = module.Component;
      Color = module.Color;
    }, function (module) {
      NoteType = module.NoteType;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _class3;
      cclegacy._RF.push({}, "0693cAdL+JB3Jn4GXrhDvzS", "Tile", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      // Status of a tile
      var TileStatus = exports('TileStatus', /*#__PURE__*/function (TileStatus) {
        TileStatus[TileStatus["WAITING"] = 0] = "WAITING";
        TileStatus[TileStatus["ACTIVE"] = 1] = "ACTIVE";
        TileStatus[TileStatus["HOLDING"] = 2] = "HOLDING";
        TileStatus[TileStatus["HIT"] = 3] = "HIT";
        TileStatus[TileStatus["MISSED"] = 4] = "MISSED";
        TileStatus[TileStatus["EXPIRED"] = 5] = "EXPIRED";
        return TileStatus;
      }({}));

      // Performance rating for a hit
      var HitRating = exports('HitRating', /*#__PURE__*/function (HitRating) {
        HitRating[HitRating["PERFECT"] = 0] = "PERFECT";
        HitRating[HitRating["GREAT"] = 1] = "GREAT";
        HitRating[HitRating["COOL"] = 2] = "COOL";
        HitRating[HitRating["MISS"] = 3] = "MISS";
        return HitRating;
      }({}));

      /**
       * Tile component for Magic Tiles 3
       * Represents an individual tile in the game
       */
      var Tile = exports('Tile', (_dec = ccclass('Tile'), _dec2 = property(Sprite), _dec3 = property(UITransform), _dec4 = property(UIOpacity), _dec5 = property(Node), _dec6 = property({
        type: Node,
        group: {
          name: 'Long Press'
        }
      }), _dec7 = property({
        type: Node,
        group: {
          name: 'Long Press'
        }
      }), _dec8 = property({
        type: UITransform,
        group: {
          name: 'Long Press'
        }
      }), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(Tile, _Component);
        function Tile() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "background", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "transform", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "opacity", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "bufferHeight", _descriptor4, _assertThisInitialized(_this));
          //perfect timming will higher than bottom by this amount
          _initializerDefineProperty(_this, "nodeBeginning", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "nodeLongPress", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "nodeHoldEffect", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "holdEffectTransform", _descriptor8, _assertThisInitialized(_this));
          // Colors for different tile states
          _initializerDefineProperty(_this, "normalColor", _descriptor9, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "holdColor", _descriptor10, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "slideColor", _descriptor11, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "hitColor", _descriptor12, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "missColor", _descriptor13, _assertThisInitialized(_this));
          // Reference to the beatmap note data
          _this.noteData = null;
          // Current status of the tile
          _this.status = TileStatus.WAITING;
          // Position data
          _this.startY = 0;
          _this.targetY = 0;
          _this.lane = 0;
          _this.scrollSpeed = 0;
          // Timing data
          _this.spawnTime = 0;
          _this.hitTime = 0;
          _this.touchStartTime = 0;
          _this.touchEndTime = 0;
          // State flags
          _this.isTouching = false;
          _this.isLongPress = false;
          _this.isSliding = false;
          // UI animation tweens
          _this.moveTween = null;
          _this.scaleTween = null;
          _this.opacityTween = null;
          _this.holdRating = HitRating.MISS;
          // New properties for direct movement
          _this.movementStartTime = 0;
          _this.movementDuration = 0;
          _this.movementStartY = 0;
          _this.movementTargetY = 0;
          _this.isMovementActive = false;
          // Reusable Vec3 object to reduce allocations
          _this.tempVec3 = new Vec3();
          // Add properties for frame skipping
          _this.updatePriority = 0;
          // 0=every frame, 1=every other frame, etc.
          _this.frameCounter = 0;
          _this.holdRange = 0;
          return _this;
        }
        var _proto = Tile.prototype;
        _proto.onLoad = function onLoad() {
          // Initialize Sprite and Transform references if not set in the inspector
          if (!this.background) {
            this.background = this.getComponent(Sprite);
          }
          if (!this.transform) {
            this.transform = this.getComponent(UITransform);
          }
          if (!this.opacity) {
            this.opacity = this.getComponent(UIOpacity);
          }
          if (this.nodeHoldEffect && !this.holdEffectTransform) {
            this.holdEffectTransform = this.nodeHoldEffect.getComponent(UITransform);
          }
        }

        /**
         * Initialize the tile with note data
         * @param note The beatmap note data for this tile
         * @param lane The lane (column) this tile belongs to
         * @param startY The starting Y position for the tile
         * @param targetY The ending Y position for the tile
         */;
        _proto.init = function init(note, lane, startY, targetY, width, scrollSpeed, minHeight) {
          this.noteData = note;
          this.lane = lane;
          this.startY = startY;
          this.targetY = targetY;
          this.scrollSpeed = scrollSpeed;
          this.status = TileStatus.WAITING;
          this.holdRange = 0;

          // Reset state
          this.isTouching = false;
          this.touchStartTime = 0;
          this.touchEndTime = 0;

          // Position the tile
          this.node.position = new Vec3(0, startY, 0);

          // Set the correct color based on note type
          // this.updateVisualByType();

          // Reset tweens
          if (this.moveTween) {
            this.moveTween.stop();
            this.moveTween = null;
          }
          if (this.scaleTween) {
            this.scaleTween.stop();
            this.scaleTween = null;
          }
          if (this.opacityTween) {
            this.opacityTween.stop();
            this.opacityTween = null;
          }

          // Reset opacity
          this.opacity.opacity = 255;
          var noteHeight = note.duration * scrollSpeed;
          // Set a minimum height to ensure visibility
          this.transform.contentSize = new Size(width, Math.max(noteHeight, minHeight));
          this.transform.node.position = new Vec3(0, -this.bufferHeight, 0);
          this.nodeBeginning.active = false;
          // Set the height based on note duration for hold notes
          if (note.type === NoteType.HOLD && note.duration > 0) {
            this.isLongPress = true;
            this.setLongPressNodeActive(true);
            if (this.nodeHoldEffect) {
              this.nodeHoldEffect.active = false;
            }
            if (this.holdEffectTransform) {
              this.holdEffectTransform.height = 0;
            }
            // Calculate height based on duration and scroll speed
          } else {
            this.isLongPress = false;
            this.setLongPressNodeActive(false);

            // Reset height to default (square) for regular notes
          }

          if (note.type === NoteType.SLIDE) {
            this.isSliding = true;
          } else {
            this.isSliding = false;
          }

          // Make the node active
          this.node.active = true;
        };
        _proto.setBeginningNodeActive = function setBeginningNodeActive(active) {
          this.nodeBeginning.active = active;
        };
        _proto.setLongPressNodeActive = function setLongPressNodeActive(active) {
          this.nodeLongPress.active = active;
        };
        _proto.getTileHeight = function getTileHeight() {
          return this.transform.contentSize.height;
        };
        _proto.setBufferHeight = function setBufferHeight(height) {
          this.bufferHeight = height;
          this.transform.node.position = new Vec3(0, -this.bufferHeight, 0);
        }

        /**
         * Start the tile's movement using direct position updates
         * @param duration How long the movement should take in seconds
         * @param gameTime Current game time
         */;
        _proto.startMovement = function startMovement(duration, gameTime) {
          this.status = TileStatus.ACTIVE;
          this.spawnTime = Date.now() / 1000;

          // Calculate a position that's beyond the target position
          var targetPosY = this.targetY - (duration * this.scrollSpeed - (this.startY - this.targetY));

          // Store movement parameters for direct updates
          this.movementStartTime = gameTime;
          this.movementDuration = duration;
          this.movementStartY = this.node.position.y;
          this.movementTargetY = targetPosY;
          this.isMovementActive = true;

          // Stop any existing tween
          if (this.moveTween) {
            this.moveTween.stop();
            this.moveTween = null;
          }
        }

        /**
         * Set the update priority based on distance from target
         * @param priority 0=update every frame, 1=every other frame, etc.
         */;
        _proto.setUpdatePriority = function setUpdatePriority(priority) {
          this.updatePriority = priority;
        }

        /**
         * Built-in update method that will be called every frame
         */;
        _proto.update = function update(dt) {
          // Skip updates based on priority
          if (this.updatePriority > 0) {
            this.frameCounter = (this.frameCounter + 1) % (this.updatePriority + 1);
            if (this.frameCounter !== 0) return;
          }

          // Handle direct movement if active
          if (this.isMovementActive) {
            this.updateTileMovement();
          }

          // Update hold effect if holding
          if (this.status === TileStatus.HOLDING && this.isLongPress && this.nodeHoldEffect) {
            this.updateHoldEffect(dt);
          }
        }

        /**
         * Update the tile position directly
         * @returns The calculated new Y position
         */;
        _proto.updateTileMovement = function updateTileMovement() {
          // Get current game time from audio manager
          var currentTime = this.calculateCurrentTime();
          var elapsedTime = currentTime - this.movementStartTime;
          var progress = Math.min(1.0, elapsedTime / this.movementDuration);

          // Linear interpolation for position
          var newY = this.movementStartY + (this.movementTargetY - this.movementStartY) * progress;

          // Reuse Vec3 object to reduce garbage collection
          this.tempVec3.set(0, newY, 0);
          this.node.position = this.tempVec3;

          // If movement complete, stop updates
          if (progress >= 1.0) {
            this.isMovementActive = false;
          }
          return newY;
        }

        /**
         * Get the current time for movement calculations
         * In a real implementation, this would use a reference to the audio manager
         */;
        _proto.calculateCurrentTime = function calculateCurrentTime() {
          // In a real implementation, get this from the audio manager
          // For now, we'll use a simple approximation
          return Date.now() / 1000 - this.spawnTime + this.movementStartTime;
        }

        /**
         * Update the tile's visual appearance based on its type
         */
        // private updateVisualByType() {
        //     if (!this.noteData) return;

        //     switch (this.noteData.type) {
        //         case NoteType.TAP:
        //             this.background.color = this.normalColor;
        //             break;
        //         case NoteType.HOLD:
        //             this.background.color = this.holdColor;
        //             break;
        //         case NoteType.SLIDE:
        //             this.background.color = this.slideColor;
        //             break;
        //     }
        // }

        /**
         * Handle the tile being tapped
         * @param time The current game time
         * @returns The hit rating for this tap
         */;
        _proto.tap = function tap(time) {
          if (!this.noteData || this.status !== TileStatus.ACTIVE) {
            return HitRating.MISS;
          }

          // Record the touch start time
          this.touchStartTime = time;
          this.isTouching = true;

          // Calculate accuracy
          var expectedTime = this.noteData.time;
          var timeDiff = Math.abs(time - expectedTime);

          // Get framerate compensation factor from director
          // This helps adjust timing windows for low FPS devices
          var dt = game.deltaTime;
          var targetFrameTime = 1 / 60; // Target is 60fps

          // Calculate a compensation factor based on current frame time vs target frame time
          // Cap the compensation to avoid extreme values
          var fpsCompensationFactor = Math.min(Math.max(dt / targetFrameTime, 1.0), 3.0);

          // Apply compensation to timing windows
          var perfectWindow = 0.1 * fpsCompensationFactor;
          var greatWindow = 0.3 * fpsCompensationFactor;
          var coolWindow = 0.5 * fpsCompensationFactor;
          var rating;

          // Determine hit rating based on timing accuracy with adjusted windows
          if (timeDiff < perfectWindow) {
            // Perfect window adjusted for fps
            rating = HitRating.PERFECT;
          } else if (timeDiff < greatWindow) {
            // Great window adjusted for fps
            rating = HitRating.GREAT;
          } else if (timeDiff < coolWindow) {
            // Cool window adjusted for fps
            rating = HitRating.COOL;
          } else {
            rating = HitRating.MISS;
          }

          // If this is a regular tap note or we missed, finish the hit process
          if (this.noteData.type === NoteType.TAP) {
            this.completeHit(rating);
          } else if (this.noteData.type === NoteType.HOLD) {
            this.triggerLongPress(rating);
          }
          return rating;
        }

        /**
         * Handle the tile being released (for hold notes)
         * @param time The current game time
         * @returns The hit rating after release
         */;
        _proto.release = function release(time) {
          if (!this.isTouching || !this.isLongPress || !this.noteData) {
            return HitRating.MISS;
          }
          this.touchEndTime = time;
          this.isTouching = false;

          // For hold notes, check if held for the correct duration
          if (this.noteData.type === NoteType.HOLD) {
            var expectedDuration = this.noteData.duration;
            var actualDuration = this.touchEndTime - this.touchStartTime;

            // Get framerate compensation factor from director
            var dt = game.deltaTime;
            var targetFrameTime = 1 / 60; // Target is 60fps
            var fpsCompensationFactor = Math.min(Math.max(dt / targetFrameTime, 1.0), 2.0);
            var rating = HitRating.COOL;

            // Determine rating based on how closely the hold duration matches expected
            // Adjust thresholds based on FPS compensation factor
            var durationRatio = actualDuration / expectedDuration;
            var perfectThreshold = 0.95 / fpsCompensationFactor;
            var greatThreshold = 0.8 / fpsCompensationFactor;
            if (durationRatio >= perfectThreshold) {
              rating = HitRating.PERFECT;
            } else if (durationRatio >= greatThreshold) {
              rating = HitRating.GREAT;
            }
            this.completeHit(rating);
            return rating;
          }
          return HitRating.MISS;
        }

        /**
         * Complete the hit process with the given rating
         * @param rating The hit rating to apply
         */;
        _proto.completeHit = function completeHit(rating) {
          if (rating === HitRating.MISS) {
            this.miss();
            return;
          }

          // Update status
          this.status = TileStatus.HIT;

          // // Stop the movement tween
          // if (this.moveTween) {
          //     this.moveTween.stop();
          // }

          // Play hit animation
          this.playHitAnimation();
        };
        _proto.triggerLongPress = function triggerLongPress(rating) {
          if (rating === HitRating.MISS) {
            this.miss();
            return;
          }
          this.status = TileStatus.HOLDING;
          this.holdRating = rating;
          // Set holdRange based on the distance between current position and target position
          this.holdRange = Math.abs(this.node.position.y - this.targetY);

          // Initialize hold effect
          if (this.nodeHoldEffect) {
            this.nodeHoldEffect.active = true;
            if (this.holdEffectTransform) {
              var currentSize = this.holdEffectTransform.contentSize;
              this.holdEffectTransform.contentSize = new Size(currentSize.width, 0);
            }
          }
          this.background.color = this.holdColor;
        }

        /**
         * Play the animation for a successful hit
         */;
        _proto.playHitAnimation = function playHitAnimation() {
          // Change color to hit color
          this.background.color = this.normalColor;
          this.opacity.opacity = 100;
          // this.background.color = this.hitColor;

          // Scale and fade out
          // this.scaleTween = tween(this.node.scale)
          //     .to(0.1, new Vec3(1.2, 1.2, 1.2))
          //     .to(0.1, new Vec3(1.0, 1.0, 1.0))
          //     .start();

          // this.opacityTween = tween(this.opacity)
          //     .to(0.1, { opacity: 100 })
          //     // .call(() => {
          //     //     this.node.active = false;
          //     // })
          //     .start();
        }

        /**
         * Handle a missed tile
         */;
        _proto.miss = function miss() {
          var _this2 = this;
          this.status = TileStatus.MISSED;
          Tile.missCount++;

          // Change color to miss color
          this.background.color = this.missColor;

          // Fade out
          this.opacityTween = tween(this.opacity).to(0.3, {
            opacity: 100
          }).call(function () {
            _this2.node.active = false;
          }).start();
        }

        /**
         * Get the current note data
         */;
        _proto.getNote = function getNote() {
          return this.noteData;
        }

        /**
         * Get the current status of the tile
         */;
        _proto.getStatus = function getStatus() {
          return this.status;
        }

        /**
         * Get the lane this tile is in
         */;
        _proto.getLane = function getLane() {
          return this.lane;
        }

        /**
         * Check if this tile is a long press type
         */;
        _proto.isLongPressType = function isLongPressType() {
          return this.isLongPress;
        }

        /**
         * Check if this tile is a slide type
         */;
        _proto.isSlideType = function isSlideType() {
          return this.isSliding;
        }

        /**
         * Reset and recycle the tile
         */;
        _proto.recycle = function recycle() {
          // Stop all tweens
          if (this.moveTween) {
            this.moveTween.stop();
            this.moveTween = null;
          }
          if (this.scaleTween) {
            this.scaleTween.stop();
            this.scaleTween = null;
          }
          if (this.opacityTween) {
            this.opacityTween.stop();
            this.opacityTween = null;
          }

          // Reset properties
          this.status = TileStatus.WAITING;
          this.noteData = null;
          this.isTouching = false;
          this.isLongPress = false;
          this.isSliding = false;
          this.holdRange = 0;

          // Hide nodes
          if (this.nodeHoldEffect) {
            this.nodeHoldEffect.active = false;
          }

          // Clean up direct movement
          this.isMovementActive = false;

          // Hide the node
          this.node.active = false;
        }

        /**
         * Update the hold effect position and size
         * @param dt Delta time
         */;
        _proto.updateHoldEffect = function updateHoldEffect(dt) {
          if (!this.isTouching) return;

          // Increase holdRange by scrollSpeed
          this.holdRange = Math.min(this.holdRange + this.scrollSpeed * dt, this.transform.contentSize.height - this.bufferHeight);

          // Activate hold effect node if not already active
          if (!this.nodeHoldEffect.active) {
            this.nodeHoldEffect.active = true;
          }

          // Update hold effect position
          var effectPos = this.nodeHoldEffect.position;
          var finalHoldPosition = this.holdRange + this.bufferHeight;
          // Create a new Vec3 instead of modifying the y property directly
          this.nodeHoldEffect.position = new Vec3(effectPos.x, finalHoldPosition, effectPos.z);

          // Update hold effect height
          if (this.holdEffectTransform) {
            var currentSize = this.holdEffectTransform.contentSize;
            this.holdEffectTransform.contentSize = new Size(currentSize.width, finalHoldPosition);
          }
        };
        return Tile;
      }(Component), _class3.missCount = 0, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "background", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "transform", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "opacity", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "bufferHeight", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 200;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "nodeBeginning", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "nodeLongPress", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "nodeHoldEffect", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "holdEffectTransform", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "normalColor", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(0, 0, 0, 255);
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "holdColor", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(50, 50, 200, 255);
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "slideColor", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(50, 200, 50, 255);
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "hitColor", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(200, 200, 200, 255);
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "missColor", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return new Color(200, 50, 50, 255);
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/TileManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './BeatmapManager.ts', './Tile.ts', './AudioManager2.ts', './MTUIManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createForOfIteratorHelperLoose, cclegacy, _decorator, Prefab, Node, Vec3, instantiate, UITransform, director, Component, BeatmapManager, Tile, TileStatus, HitRating, MagicTilesAudioManager, MTUIManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createForOfIteratorHelperLoose = module.createForOfIteratorHelperLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Prefab = module.Prefab;
      Node = module.Node;
      Vec3 = module.Vec3;
      instantiate = module.instantiate;
      UITransform = module.UITransform;
      director = module.director;
      Component = module.Component;
    }, function (module) {
      BeatmapManager = module.BeatmapManager;
    }, function (module) {
      Tile = module.Tile;
      TileStatus = module.TileStatus;
      HitRating = module.HitRating;
    }, function (module) {
      MagicTilesAudioManager = module.MagicTilesAudioManager;
    }, function (module) {
      MTUIManager = module.MTUIManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11;
      cclegacy._RF.push({}, "bf871T6LV9LXZ2T/yZkKnKK", "TileManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;

      /**
       * TileManager for Magic Tiles 3
       * Manages the spawning, movement, and destruction of tiles
       */
      var TileManager = exports('TileManager', (_dec = ccclass('TileManager'), _dec2 = property(Prefab), _dec3 = property([Node]), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(TileManager, _Component);
        function TileManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          // Reference to the tile prefab
          _initializerDefineProperty(_this, "tilePrefab", _descriptor, _assertThisInitialized(_this));
          // Lane container nodes
          _initializerDefineProperty(_this, "laneContainers", _descriptor2, _assertThisInitialized(_this));
          // Minimum height for tiles to ensure visibility
          // Tile spawn position (Y coordinate)
          _initializerDefineProperty(_this, "spawnPositionY", _descriptor3, _assertThisInitialized(_this));
          // Tile target position (Y coordinate - the hit zone)
          _initializerDefineProperty(_this, "targetPositionY", _descriptor4, _assertThisInitialized(_this));
          // Position where tiles should be recycled regardless of their state
          _initializerDefineProperty(_this, "recyclePositionY", _descriptor5, _assertThisInitialized(_this));
          // How many seconds ahead to spawn tiles
          _initializerDefineProperty(_this, "lookAheadTime", _descriptor6, _assertThisInitialized(_this));
          // Default scroll speed (pixels per second)s    
          _initializerDefineProperty(_this, "defaultScrollSpeed", _descriptor7, _assertThisInitialized(_this));
          // Current scroll speed
          _this.scrollSpeed = 600;
          // Width of a lane
          _initializerDefineProperty(_this, "laneWidth", _descriptor8, _assertThisInitialized(_this));
          // Maximum number of tiles to pool
          _initializerDefineProperty(_this, "maxPoolSize", _descriptor9, _assertThisInitialized(_this));
          // Reference to managers
          _this.beatmapManager = null;
          _this.audioManager = null;
          // Tile object pool
          _this.tilePool = [];
          // Active tiles
          _this.activeTiles = [];
          // Track the next note to spawn
          _this.nextNoteIndex = 0;
          // Track the current game time
          _this.gameTime = 0;
          // Change isPlaying to a game state enum
          _this.gameState = 'stopped';
          // Track if update is scheduled
          _this._updateScheduled = false;
          // Add autoplay flag
          _initializerDefineProperty(_this, "isAutoplay", _descriptor10, _assertThisInitialized(_this));
          // Add bottom position threshold where tiles will be considered missed
          _initializerDefineProperty(_this, "missThreshold", _descriptor11, _assertThisInitialized(_this));
          // Slightly below the target position
          // Track touched tiles
          _this.touchedTiles = new Map();
          _this.minTileHeight = 300.0;
          // Add time tracking properties
          _this.lastAudioTimeCheck = 0;
          _this.cachedAudioTime = 0;
          _this.audioTimeCheckInterval = 0.05;
          // Check every 50ms
          _this.timeSinceLastAudioCheck = 0;
          // Replace Map with direct arrays for lane tiles
          _this.laneArrays = [];
          // Reusable Vector3 objects to minimize garbage collection
          _this.tempVec3 = new Vec3();
          _this.lanePositionVec3 = new Vec3();
          // Use typed arrays for better performance and memory layout
          _this.tilePositionsY = null;
          _this.tileIndices = new Map();
          _this.nextTileIndex = 0;
          // Add properties for load balancing
          _this.updateBudgetPerFrame = 20;
          // Maximum tiles to fully update per frame
          _this.updateQueue = [];
          // Add properties for performance monitoring
          _this.fpsHistory = [];
          _this.lastFrameTime = 0;
          _this.frameCounter = 0;
          _this.performanceLevel = 'high';
          return _this;
        }
        var _proto = TileManager.prototype;
        /**
         * Initialize the TileManager with dependencies
         * This allows for dependency injection rather than direct singleton usage
         * @param beatmapManager The beatmap manager instance
         * @param audioManager The audio manager instance
         */
        _proto.initialize = function initialize(beatmapManager, audioManager) {
          this.beatmapManager = beatmapManager;
          this.audioManager = audioManager;
          this.initTilePool();
        };
        _proto.onLoad = function onLoad() {
          // Get references to managers - still use singletons for backward compatibility
          // but prefer using the initialize method for new code
          if (!this.beatmapManager) {
            this.beatmapManager = BeatmapManager.instance;
          }
          if (!this.audioManager) {
            this.audioManager = MagicTilesAudioManager.instance;
          }

          // Initialize the object pool
          this.initTilePool();
        };
        _proto.start = function start() {
          // Ensure we have the correct number of lane containers
          this.ensureLaneContainers();
        }

        /**
         * Initialize the tile object pool
         */;
        _proto.initTilePool = function initTilePool() {
          var _this$beatmapManager;
          // Clear any existing tiles
          this.tilePool = [];

          // Estimate optimal pool size based on note density and screen size
          var notes = (_this$beatmapManager = this.beatmapManager) == null ? void 0 : _this$beatmapManager.getNotes();
          if (notes && notes.length > 0) {
            var visibleDistance = this.spawnPositionY - this.recyclePositionY;
            var noteTimeSpan = notes[notes.length - 1].time - notes[0].time;
            // Prevent division by zero
            var scrollSpeedToUse = this.scrollSpeed || this.defaultScrollSpeed;
            var estimatedVisibleNotes = Math.ceil(notes.length * (visibleDistance / (scrollSpeedToUse * Math.max(0.1, noteTimeSpan))));
            this.maxPoolSize = Math.max(this.maxPoolSize, estimatedVisibleNotes + 10); // Add buffer
            console.log("Dynamic pool size calculated: " + this.maxPoolSize + " (estimated visible: " + estimatedVisibleNotes + ")");
          }

          // Create the initial pool of tiles
          for (var i = 0; i < this.maxPoolSize; i++) {
            var tileNode = instantiate(this.tilePrefab);
            var tile = tileNode.getComponent(Tile);

            // Initialize and hide the tile
            tileNode.active = false;

            // Add to pool
            this.tilePool.push(tile);
          }

          // Initialize typed arrays for position data
          this.tilePositionsY = new Float32Array(this.maxPoolSize);
          this.tileIndices = new Map();
          this.nextTileIndex = 0;

          // Initialize lane arrays
          this.initLaneArrays();
        }

        /**
         * Initialize lane arrays for faster lookups
         */;
        _proto.initLaneArrays = function initLaneArrays() {
          var laneCount = Math.max(4, this.laneContainers.length);
          this.laneArrays = new Array(laneCount);
          for (var i = 0; i < laneCount; i++) {
            this.laneArrays[i] = [];
          }
        }

        /**
         * Ensure we have the correct number of lane containers
         */;
        _proto.ensureLaneContainers = function ensureLaneContainers() {
          var requiredLanes = 4; // Magic Tiles typically has 4 lanes

          if (this.laneContainers.length < requiredLanes) {
            console.warn("TileManager needs " + requiredLanes + " lane containers, but only " + this.laneContainers.length + " were provided.");

            // Create missing lane containers
            for (var i = this.laneContainers.length; i < requiredLanes; i++) {
              var laneNode = new Node("Lane_" + i);
              laneNode.parent = this.node;

              // Position the lane using reusable Vec3
              this.lanePositionVec3.set((i - requiredLanes / 2 + 0.5) * this.laneWidth, 0, 0);
              laneNode.position = this.lanePositionVec3;

              // Add to lane containers
              this.laneContainers.push(laneNode);
            }
          }

          //init lands
          this.laneWidth = this.laneContainers[0].getComponent(UITransform).width;

          // Initialize lane arrays
          this.initLaneArrays();
        };
        _proto.initGame = function initGame() {
          this.clearActiveTiles();

          // Reset state
          this.nextNoteIndex = 0;
          this.gameTime = 0.0;
          this.activeTiles = [];
          this.touchedTiles.clear();

          // Reset lane arrays
          for (var i = 0; i < this.laneArrays.length; i++) {
            this.laneArrays[i].length = 0;
          }
          // Calculate optimal scroll speed based on note data
          this.calculateDynamicScrollSpeed();
          // Clear any active tiles
        }

        /**
         * Start spawning tiles based on the current beatmap
         */;
        _proto.startGame = function startGame() {
          this.gameState = 'playing';
          // Only schedule if not already scheduled
          if (!this._updateScheduled) {
            director.getScheduler().schedule(this.update, this, 0);
            this._updateScheduled = true;
          }

          // Reset performance monitoring
          this.fpsHistory = [];
          this.lastFrameTime = Date.now();
          this.frameCounter = 0;
          this.performanceLevel = 'high';
        }

        /**
         * Stop the game
         */;
        _proto.stopGame = function stopGame() {
          this.gameState = 'stopped';

          // Explicitly unschedule when stopping the game completely
          if (this._updateScheduled) {
            director.getScheduler().unschedule(this.update, this);
            this._updateScheduled = false;
          }
          this.clearActiveTiles();
        }

        /**
         * Pause the game
         */;
        _proto.pauseGame = function pauseGame() {
          this.gameState = 'paused';
          // Keep the update scheduled but it will early-return based on state
        }

        /**
         * Resume the game
         */;
        _proto.resumeGame = function resumeGame() {
          this.gameState = 'playing';

          // Ensure update is scheduled
          if (!this._updateScheduled) {
            director.getScheduler().schedule(this.update, this, 0);
            this._updateScheduled = true;
          }
        }

        /**
         * Update method called every frame
         * @param dt Delta time since last frame in seconds
         */;
        _proto.update = function update(dt) {
          // Monitor performance regardless of game state
          this.monitorPerformance(dt);

          // Early return based on state
          if (this.gameState !== 'playing') return;

          // Use the optimized time estimation from AudioManager
          if (this.audioManager) {
            this.gameTime = this.audioManager.getEstimatedAudioTime();
          } else {
            // Fallback for backward compatibility
            this.timeSinceLastAudioCheck += dt;

            // Only check actual audio time periodically
            if (this.timeSinceLastAudioCheck >= this.audioTimeCheckInterval) {
              this.cachedAudioTime = MagicTilesAudioManager.instance.getAudioTime();
              this.timeSinceLastAudioCheck = 0;
            } else {
              // Estimate time between checks
              this.cachedAudioTime += dt;
            }

            // Use cached time for all operations
            this.gameTime = this.cachedAudioTime;
          }

          // Throttle UI updates to reduce overhead - update every ~3 frames (50ms)
          if (Math.random() < 0.03) {
            MTUIManager.instance.updateSongTimeDisplay(this.gameTime);
          }

          // Spawn tiles that should be visible
          this.spawnTiles();

          // Update tile priorities based on distance from target
          // this.updateTilePriorities();

          // Use balanced update for better performance
          this.balancedUpdateActiveTiles();
        }

        /**
         * Update tile update priorities based on distance from target position
         */;
        _proto.updateTilePriorities = function updateTilePriorities() {
          for (var _iterator = _createForOfIteratorHelperLoose(this.activeTiles), _step; !(_step = _iterator()).done;) {
            var tile = _step.value;
            var distanceToTarget = Math.abs(tile.node.position.y - this.targetPositionY);

            // Tiles far from the target position update less frequently
            // Closer tiles update every frame for maximum precision
            var priority = 0; // Default: update every frame

            if (distanceToTarget > 1500) {
              priority = 2; // Update every 3rd frame
            } else if (distanceToTarget > 1000) {
              priority = 1; // Update every other frame
            }

            tile.setUpdatePriority(priority);
          }
        }

        /**
         * Spawn tiles that should be visible based on current time
         */;
        _proto.spawnTiles = function spawnTiles() {
          // Get all notes from the beatmap
          var notes = this.beatmapManager.getNotes();
          if (!notes.length) return;

          // Calculate how far ahead we should spawn tiles
          var spawnTime = this.gameTime + this.lookAheadTime;

          // Spawn all notes that should be visible by now
          while (this.nextNoteIndex < notes.length && notes[this.nextNoteIndex].time <= spawnTime) {
            this.spawnTile(notes[this.nextNoteIndex]);
            this.nextNoteIndex++;
          }
        }

        /**
         * Helper method to update tile position without creating new Vec3 objects
         * @param tile The tile to update
         * @param posY The Y position to set
         */;
        _proto.updateTilePosition = function updateTilePosition(tile, posY) {
          // Reuse the same Vec3 object instead of creating a new one
          this.tempVec3.set(0, posY, 0);
          tile.node.position = this.tempVec3;
        }

        /**
         * Spawn a single tile
         * @param note The note data to spawn a tile for
         */;
        _proto.spawnTile = function spawnTile(note) {
          // Get a tile from te pool
          var tile = this.getTileFromPool();
          if (!tile) {
            console.warn("Tile pool exhausted, cannot spawn more tiles");
            return;
          }

          // Calculate which lane to spawn in
          var lane = note.lane;
          if (lane < 0 || lane >= this.laneContainers.length) {
            console.error("Invalid lane " + lane + " for note " + note.midi);
            return;
          }

          // Add the tile to the correct lane
          var laneNode = this.laneContainers[lane];
          tile.node.parent = laneNode;

          // Initialize the tile
          tile.init(note, lane, this.spawnPositionY, this.targetPositionY, this.laneWidth, this.scrollSpeed, this.minTileHeight);
          tile.setBufferHeight(this.minTileHeight / 2.0);

          // Assign an index in the position arrays
          var tileIndex = this.nextTileIndex % this.maxPoolSize;
          this.tileIndices.set(tile, tileIndex);
          this.tilePositionsY[tileIndex] = this.spawnPositionY;
          this.nextTileIndex++;

          // Position the tile using our reusable vector
          this.updateTilePosition(tile, this.spawnPositionY);

          // Calculate the total distance from spawn to miss threshold (instead of just to target)
          var totalDistance = this.spawnPositionY - this.recyclePositionY + tile.getTileHeight() + 500.0; //500 is buffer for moving

          // Calculate how long it should take for the tile to reach the target position
          var distanceToTarget = this.spawnPositionY - this.targetPositionY;
          var travelTimeToTarget = distanceToTarget / this.scrollSpeed;

          // Calculate total travel time to reach the miss threshold
          var totalTravelTime = totalDistance / this.scrollSpeed;

          // Calculate when the tile should arrive at the target (hit time)
          var hitTime = note.time;

          // Calculate when to start the tile moving to arrive at the right time
          var startTime = hitTime - travelTimeToTarget;

          // If we need to start moving immediately
          if (startTime <= this.gameTime) {
            // Start movement immediately with the total travel time to the miss threshold
            // This will make the tile continue past the target position
            tile.startMovement(totalTravelTime, startTime);
          } else {
            // Schedule the tile to start moving at the correct time
            var delay = startTime - this.gameTime;
            this.scheduleOnce(function () {
              if (tile.node.active) {
                // Check if still active
                tile.startMovement(totalTravelTime, startTime);
              }
            }, delay);
          }

          // Add to active tiles
          this.activeTiles.push(tile);

          // Add to lane array for faster lookups
          if (lane >= 0 && lane < this.laneArrays.length) {
            this.laneArrays[lane].push(tile);
          }
        }

        /**
         * Update active tiles with load balancing to maintain consistent FPS
         */;
        _proto.balancedUpdateActiveTiles = function balancedUpdateActiveTiles() {
          var _this2 = this;
          // Check for tiles that need to be auto-played
          if (this.isAutoplay) {
            this.handleAutoplay();
          }

          // Process any queued tiles first
          if (this.updateQueue.length > 0) {
            var tilesToProcess = Math.min(this.updateBudgetPerFrame / 2, this.updateQueue.length);
            for (var i = 0; i < tilesToProcess; i++) {
              var tile = this.updateQueue.shift();
              this.processTileUpdate(tile);
            }
          }

          // Queue updates if we have too many active tiles
          if (this.activeTiles.length > this.updateBudgetPerFrame) {
            // Sort by priority (closest to target position gets processed first)
            this.activeTiles.sort(function (a, b) {
              var distA = Math.abs(a.node.position.y - _this2.targetPositionY);
              var distB = Math.abs(b.node.position.y - _this2.targetPositionY);
              return distA - distB;
            });

            // Process high priority tiles immediately
            for (var _i = 0; _i < this.updateBudgetPerFrame; _i++) {
              if (_i < this.activeTiles.length) {
                this.processTileUpdate(this.activeTiles[_i]);
              }
            }

            // Queue remaining tiles for next frames if not already in queue
            for (var _i2 = this.updateBudgetPerFrame; _i2 < this.activeTiles.length; _i2++) {
              if (_i2 < this.activeTiles.length && !this.isInUpdateQueue(this.activeTiles[_i2])) {
                this.updateQueue.push(this.activeTiles[_i2]);
              }
            }
          } else {
            // Normal update for all tiles
            for (var _iterator2 = _createForOfIteratorHelperLoose(this.activeTiles), _step2; !(_step2 = _iterator2()).done;) {
              var _tile = _step2.value;
              this.processTileUpdate(_tile);
            }
          }

          // Remove tiles that should be recycled
          this.checkRecycleTiles();
        }

        /**
         * Process a single tile update
         */;
        _proto.processTileUpdate = function processTileUpdate(tile) {
          // Check for missed tiles
          if (tile.getStatus() === TileStatus.ACTIVE && tile.node.position.y <= this.missThreshold) {
            // Mark the tile as missed
            tile.miss();
          }
        }

        /**
         * Check for tiles that need to be recycled
         */;
        _proto.checkRecycleTiles = function checkRecycleTiles() {
          var i = 0;
          while (i < this.activeTiles.length) {
            var tile = this.activeTiles[i];

            // Check if the tile has passed the recycle position
            if (tile.node.position.y + tile.getTileHeight() <= this.recyclePositionY) {
              // For HOLD notes that are currently pressed, release them before recycling
              if (tile.getStatus() === TileStatus.HOLDING && tile.isLongPressType()) {
                // Force release of the hold note
                tile.release(this.gameTime);
              }

              // Return the tile to the pool
              this.returnTileToPool(tile);

              // Remove from active tiles without creating a new array
              this.activeTiles[i] = this.activeTiles[this.activeTiles.length - 1];
              this.activeTiles.pop();

              // Also remove from update queue if present
              var queueIndex = this.updateQueue.indexOf(tile);
              if (queueIndex !== -1) {
                this.updateQueue.splice(queueIndex, 1);
              }
            } else {
              // Only increment if we didn't remove an item
              i++;
            }
          }
        }

        /**
         * Handle autoplay functionality to automatically hit tiles at the right time
         */;
        _proto.handleAutoplay = function handleAutoplay() {
          var _this3 = this;
          if (!this.isAutoplay) return;

          // Get all active tiles that are close to the target position
          var autoplayTiles = this.activeTiles.filter(function (tile) {
            if (tile.getStatus() !== TileStatus.ACTIVE) return false;
            var note = tile.getNote();
            if (!note) return false;

            // Check if the tile is within the autoplay hit window
            // For regular notes, tap when they're at or just before the hit time
            // For hold notes, tap them slightly earlier to ensure natural timing
            var timeDiff = note.time - _this3.gameTime;
            return timeDiff <= 0.05; // Within 50ms window (detect slightly ahead of time)
          });

          // Process each autoplayable tile
          for (var _iterator3 = _createForOfIteratorHelperLoose(autoplayTiles), _step3; !(_step3 = _iterator3()).done;) {
            var tile = _step3.value;
            var laneIndex = tile.getLane();
            var note = tile.getNote();
            if (!note) continue;

            // Handle different tile types
            if (tile.isLongPressType()) {
              // For hold notes, store them to release later
              if (!this.touchedTiles.has(laneIndex)) {
                // Tap the tile
                var hitRating = tile.tap(this.gameTime);
                // Store it for later release only if it was successfully tapped
                if (hitRating !== HitRating.MISS) {
                  this.touchedTiles.set(laneIndex, tile);
                }
              }
            } else {
              // For regular tap notes, just tap them
              tile.tap(this.gameTime);
            }
          }

          // Check for held notes that need to be released
          this.touchedTiles.forEach(function (tile, laneIndex) {
            var note = tile.getNote();
            if (!note || tile.getStatus() !== TileStatus.HOLDING) {
              // Remove from tracked tiles if not in pressed state
              _this3.touchedTiles["delete"](laneIndex);
              return;
            }

            // Calculate when to release the hold note
            // Release exactly at the end of the hold duration for perfect timing
            var releaseTime = note.time + note.duration;

            // Check if it's time to release the held note
            if (releaseTime <= _this3.gameTime) {
              tile.release(_this3.gameTime);
              _this3.touchedTiles["delete"](laneIndex);
            }
          });
        }

        /**
         * Toggle autoplay mode
         * @param enable Whether to enable or disable autoplay
         */;
        _proto.toggleAutoplay = function toggleAutoplay(enable) {
          if (enable !== undefined) {
            this.isAutoplay = enable;
          } else {
            this.isAutoplay = !this.isAutoplay;
          }
          console.log("Autoplay " + (this.isAutoplay ? 'enabled' : 'disabled'));
        }

        /**
         * Check if autoplay is enabled
         */;
        _proto.isAutoplayEnabled = function isAutoplayEnabled() {
          return this.isAutoplay;
        }

        /**
         * Clear all active tiles and return them to the pool
         */;
        _proto.clearActiveTiles = function clearActiveTiles() {
          for (var _iterator4 = _createForOfIteratorHelperLoose(this.activeTiles), _step4; !(_step4 = _iterator4()).done;) {
            var tile = _step4.value;
            this.returnTileToPool(tile);
          }
          this.activeTiles = [];
        }

        /**
         * Get a tile from the object pool
         */;
        _proto.getTileFromPool = function getTileFromPool() {
          // Check if there are any tiles in the pool
          if (this.tilePool.length === 0) {
            // No tiles available, create a new one if we haven't reached max capacity
            if (this.activeTiles.length < this.maxPoolSize) {
              var tileNode = instantiate(this.tilePrefab);
              var _tile2 = tileNode.getComponent(Tile);
              return _tile2;
            } else {
              return null; // Pool exhausted and at max capacity
            }
          }

          // Get a tile from the pool
          var tile = this.tilePool.pop();
          tile.node.active = true;
          return tile;
        }

        /**
         * Return a tile to the object pool
         */;
        _proto.returnTileToPool = function returnTileToPool(tile) {
          // Remove from touchedTiles tracking if it's a HOLD note being tracked
          var laneIndex = tile.getLane();
          if (this.touchedTiles.has(laneIndex) && this.touchedTiles.get(laneIndex) === tile) {
            // Make sure to release the note if it's in HOLDING state
            if (tile.getStatus() === TileStatus.HOLDING) {
              tile.release(this.gameTime);
            }
            this.touchedTiles["delete"](laneIndex);
          }

          // Recycle the tile
          tile.recycle();

          // Add back to pool
          this.tilePool.push(tile);

          // Remove from lane array
          if (laneIndex >= 0 && laneIndex < this.laneArrays.length) {
            var laneArray = this.laneArrays[laneIndex];
            var index = laneArray.indexOf(tile);
            if (index !== -1) {
              // Fast removal without creating a new array
              laneArray[index] = laneArray[laneArray.length - 1];
              laneArray.pop();
            }
          }

          // Remove from position tracking
          this.tileIndices["delete"](tile);
        }

        /**
         * Handle a touch event in a lane
         * @param laneIndex The index of the lane that was touched
         * @param isTouchStart Whether this is a touch start (true) or touch end (false)
         * @returns The hit rating if a tile was hit
         */;
        _proto.handleLaneTouch = function handleLaneTouch(laneIndex, isTouchStart) {
          var _this4 = this;
          console.log("handleLaneTouch", laneIndex, isTouchStart);
          if (!isTouchStart) {
            // This is a touch up event - check if we have a stored tile
            var touchedTile = this.touchedTiles.get(laneIndex);
            if (touchedTile && touchedTile.isLongPressType()) {
              this.touchedTiles["delete"](laneIndex);
              return touchedTile.release(this.gameTime);
            }
          }

          // Get tiles only for the specific lane using our optimized array
          var laneTiles = laneIndex >= 0 && laneIndex < this.laneArrays.length ? this.laneArrays[laneIndex] : [];

          // Find hitable tiles in this lane
          var hitableTiles = laneTiles.filter(function (tile) {
            return tile.getStatus() === TileStatus.ACTIVE;
          });

          // Sort by closest to target position
          hitableTiles.sort(function (a, b) {
            var aNote = a.getNote();
            var bNote = b.getNote();
            if (!aNote || !bNote) return 0;
            return Math.abs(aNote.time - _this4.gameTime) - Math.abs(bNote.time - _this4.gameTime);
          });
          if (hitableTiles.length === 0) {
            return HitRating.MISS; // No tiles to hit
          }

          var tile = hitableTiles[0];
          if (isTouchStart) {
            // This is a touch down event
            var rating = tile.tap(this.gameTime);

            // If this is a long press type, store it for the release event
            if (tile.isLongPressType() && rating !== HitRating.MISS) {
              this.touchedTiles.set(laneIndex, tile);
            }
            return rating;
          }
          return HitRating.MISS;
        }

        /**
         * Set the scroll speed for tiles
         * @param speed The new scroll speed in pixels per second
         */;
        _proto.setScrollSpeed = function setScrollSpeed(speed) {
          var oldSpeed = this.scrollSpeed;
          this.scrollSpeed = speed;
        }

        /**
         * Get the current scroll speed
         */;
        _proto.getScrollSpeed = function getScrollSpeed() {
          return this.scrollSpeed;
        }

        /**
         * Get the number of active tiles
         */;
        _proto.getActiveTileCount = function getActiveTileCount() {
          return this.activeTiles.length;
        }

        /**
         * Get the current game time
         */;
        _proto.getGameTime = function getGameTime() {
          return this.gameTime;
        }

        /**
         * Set the current game time (useful for syncing with audio)
         */;
        _proto.setGameTime = function setGameTime(time) {
          this.gameTime = time;
        }

        /**
         * Calculate optimal scroll speed based on note density and timing
         * Optimized version with reduced math operations
         */;
        _proto.calculateDynamicScrollSpeed = function calculateDynamicScrollSpeed() {
          // Get all notes from the beatmap
          var notes = this.beatmapManager.getNotes();
          if (!notes || notes.length < 2) {
            // Not enough notes to analyze, use default speed
            this.scrollSpeed = this.defaultScrollSpeed;
            return;
          }

          // Precalculate constants
          var minSpeed = this.defaultScrollSpeed * 0.5; // Don't go below 50% of default
          var maxSpeed = this.defaultScrollSpeed * 1.5; // Don't go above 150% of default

          // Sort notes by time (they should already be sorted, but just to be safe)
          // We'll avoid sorting if the notes already appear to be in order
          var isSorted = true;
          for (var i = 1; i < notes.length; i++) {
            if (notes[i].time < notes[i - 1].time) {
              isSorted = false;
              break;
            }
          }

          // Only sort if necessary
          var sortedNotes = isSorted ? notes : [].concat(notes).sort(function (a, b) {
            return a.time - b.time;
          });

          // Find the minimum time gap between consecutive notes more efficiently
          var minTimeGap = Number.MAX_VALUE;
          var totalTimeGap = 0;
          var totalGaps = 0;
          var maxNoteDuration = 0;

          // Single loop to calculate all metrics
          for (var _i3 = 1; _i3 < sortedNotes.length; _i3++) {
            var timeGap = sortedNotes[_i3].time - sortedNotes[_i3 - 1].time;
            if (timeGap > 0) {
              if (timeGap < minTimeGap) {
                minTimeGap = timeGap;
              }
              totalTimeGap += timeGap;
              totalGaps++;
            }

            // Track the longest note duration for hold notes
            var duration = sortedNotes[_i3].duration;
            if (duration > maxNoteDuration) {
              maxNoteDuration = duration;
            }
          }

          // Calculate average time gap
          var averageTimeGap = totalGaps > 0 ? totalTimeGap / totalGaps : 1.0;

          // If we couldn't find a valid minimum gap, use default
          if (minTimeGap === Number.MAX_VALUE) {
            minTimeGap = 1.0;
          }

          // Calculate speed factors without expensive square roots
          // Approximate sqrt(x) with a faster but still reasonable calculation
          // We'll use a simple linear mapping instead of sqrt for better performance
          var speedFactor = Math.min(1.0, minTimeGap * 0.7 + 0.3);
          var avgSpeedFactor = Math.min(1.0, averageTimeGap * 0.5 + 0.5);

          // For hold notes, calculate a simple duration factor
          var durationFactor = 1.0;
          if (maxNoteDuration > 0) {
            // Use simple linear scaling, capped at sensible values
            durationFactor = Math.max(0.7, 1.0 - maxNoteDuration * 0.1);
          }

          // Combine all factors with appropriate weights
          var combinedFactor = speedFactor * 0.6 + avgSpeedFactor * 0.25 + durationFactor * 0.15;

          // Scale the default speed by our factor, with limits
          var calculatedSpeed = minSpeed + (maxSpeed - minSpeed) * combinedFactor;

          // Use setScrollSpeed to ensure consistent behavior
          this.setScrollSpeed(calculatedSpeed * 2.5);

          // Log with reduced string operations
          if (this.performanceLevel === 'high') {
            console.log("Dynamic scroll speed: " + Math.round(this.scrollSpeed) + " px/s");
          }
        }

        /**
         * Update tile positions in batch using the typed arrays
         */;
        _proto.updateTilePositionsFromArray = function updateTilePositionsFromArray() {
          for (var _iterator5 = _createForOfIteratorHelperLoose(this.activeTiles), _step5; !(_step5 = _iterator5()).done;) {
            var tile = _step5.value;
            var index = this.tileIndices.get(tile);
            if (index !== undefined) {
              // Update node position from the typed array
              this.updateTilePosition(tile, this.tilePositionsY[index]);
            }
          }
        }

        /**
         * Check if a tile is already in the update queue
         */;
        _proto.isInUpdateQueue = function isInUpdateQueue(tile) {
          return this.updateQueue.findIndex(function (t) {
            return t === tile;
          }) !== -1;
        }

        /**
         * Monitor performance and adjust settings accordingly
         */;
        _proto.monitorPerformance = function monitorPerformance(dt) {
          this.frameCounter++;

          // Calculate FPS every second
          var now = Date.now();
          if (now - this.lastFrameTime > 1000) {
            var fps = this.frameCounter;
            this.fpsHistory.push(fps);

            // Keep only the last 5 samples
            if (this.fpsHistory.length > 5) {
              this.fpsHistory.shift();
            }

            // Adjust performance level based on average FPS
            var avgFps = this.fpsHistory.reduce(function (a, b) {
              return a + b;
            }, 0) / this.fpsHistory.length;
            this.adjustPerformanceSettings(avgFps);

            // Reset counters
            this.frameCounter = 0;
            this.lastFrameTime = now;
          }
        }

        /**
         * Adjust game settings based on performance level
         */;
        _proto.adjustPerformanceSettings = function adjustPerformanceSettings(fps) {
          var oldLevel = this.performanceLevel;

          // Determine performance level
          if (fps < 30) {
            this.performanceLevel = 'low';
          } else if (fps < 50) {
            this.performanceLevel = 'medium';
          } else {
            this.performanceLevel = 'high';
          }

          // Only apply changes if performance level changed
          if (oldLevel !== this.performanceLevel) {
            console.log("Performance level changed: " + oldLevel + " -> " + this.performanceLevel + " (Average FPS: " + fps.toFixed(1) + ")");
            switch (this.performanceLevel) {
              case 'low':
                this.updateBudgetPerFrame = 10;
                this.audioTimeCheckInterval = 60; // Check audio time less often
                break;
              case 'medium':
                this.updateBudgetPerFrame = 15;
                this.audioTimeCheckInterval = 45;
                break;
              case 'high':
                this.updateBudgetPerFrame = 20;
                this.audioTimeCheckInterval = 30;
                break;
            }
          }
        }

        /**
         * Set up a beginning tile that the player must tap to start the game
         */;
        _proto.setupBeginningTile = function setupBeginningTile() {
          // Clear any existing tiles
          this.clearActiveTiles();

          // Set game state to a ready state but not fully playing
          this.gameState = 'paused';

          // Choose a random lane for the beginning tile (typically middle lane for better UX)
          var lane = Math.min(Math.floor(this.laneContainers.length / 2), this.laneContainers.length - 1);

          // Create a special beginning tile at the hit line
          this.createBeginningTile(lane);
        }

        /**
         * Create a special beginning tile at the hit line
         * @param lane The lane to place the beginning tile in
         */;
        _proto.createBeginningTile = function createBeginningTile(lane) {
          // Get a tile from the pool
          var tile = this.getTileFromPool();
          if (!tile) {
            console.error("Failed to create beginning tile - pool empty");
            return;
          }

          // Create a simple note for the beginning tile
          var beginningNote = {
            midi: 60,
            // Middle C
            time: 0,
            lane: lane,
            type: 0,
            // Regular tap note (NoteType.TAP)
            duration: 0.3,
            durationTicks: 0,
            velocity: 100
          };

          // Position the tile at the hit line
          var laneContainer = this.laneContainers[lane];
          tile.node.parent = laneContainer;
          var yPos = this.targetPositionY; // Position slightly above the hit line for visibility

          // Initialize the tile with special settings
          tile.init(beginningNote, lane, yPos, yPos, this.laneWidth, this.scrollSpeed, this.minTileHeight);
          tile.setBufferHeight(this.minTileHeight / 2.0);
          tile.setBeginningNodeActive(true);

          // Set a special tag to identify this tile
          tile.node.name = "beginning_tile";

          // Add to active tiles
          this.activeTiles.push(tile);

          // Add to lane array
          if (lane >= 0 && lane < this.laneArrays.length) {
            this.laneArrays[lane].push(tile);
          }
        }

        /**
         * Check if the beginning tile was tapped
         * @param laneIndex The lane that was tapped
         * @returns True if the beginning tile was tapped
         */;
        _proto.checkBeginningTileTap = function checkBeginningTileTap(laneIndex) {
          // Find the beginning tile
          for (var i = 0; i < this.activeTiles.length; i++) {
            var tile = this.activeTiles[i];
            if (tile.node.name === "beginning_tile" && tile.getLane() === laneIndex) {
              // Remove the beginning tile
              tile.startMovement(1.0, this.gameTime);
              return true;
            }
          }
          return false;
        }

        /**
         * Remove a specific tile
         * @param tile The tile to remove
         */;
        _proto.removeTile = function removeTile(tile) {
          // Remove from active tiles
          var index = this.activeTiles.indexOf(tile);
          if (index >= 0) {
            this.activeTiles.splice(index, 1);
          }

          // Remove from lane array
          var lane = tile.getLane();
          if (lane >= 0 && lane < this.laneArrays.length) {
            var laneIndex = this.laneArrays[lane].indexOf(tile);
            if (laneIndex >= 0) {
              this.laneArrays[lane].splice(laneIndex, 1);
            }
          }

          // Return to pool
          this.returnTileToPool(tile);
        };
        return TileManager;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "tilePrefab", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "laneContainers", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "spawnPositionY", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1200;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "targetPositionY", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return -400;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "recyclePositionY", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return -1500;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "lookAheadTime", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 4.0;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "defaultScrollSpeed", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 600;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "laneWidth", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 160;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "maxPoolSize", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 50;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "isAutoplay", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "missThreshold", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return -450;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/tilling-and-offset.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec2, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec2 = module.Vec2;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "5f40e+RWa9OQYJs/kAgd0eT", "tilling-and-offset", undefined);
      var TillingAndOffset = exports('default', (_dec = register({
        menu: 'Uv/TillingAndOffset',
        title: 'TillingAndOffset'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(TillingAndOffset, _ShaderNode);
        function TillingAndOffset() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.depChunks = ['uv'];
          _this.data = {
            inputs: [slot('uv', Vec2.ZERO, 'vec2', 'vector'), slot('tilling', Vec2.ZERO, 'vec2', 'vector'), slot('offset', Vec2.ZERO, 'vec2', 'vector')],
            outputs: [slot('Out', Vec2.ZERO, 'vec2', 'vector')]
          };
          return _this;
        }
        var _proto = TillingAndOffset.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          if (!this.inputs[0].connectSlot) {
            input0 = 'v_uv.xy';
          }
          var input1 = this.getInputValue(1);
          var input2 = this.getInputValue(2);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = " + input0 + " * " + input1 + " + " + input2 + ";\n        ";
        };
        return TillingAndOffset;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/time.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './utils.ts', './input-node.ts', './index3.ts', './register.ts'], function (exports) {
  var _inheritsLoose, cclegacy, slot, InputNode, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      slot = module.slot;
    }, function (module) {
      InputNode = module.default;
    }, null, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "d78e7iowiJHXbVo2J+jhSXo", "time", undefined);
      var TimeNode = exports('default', (_dec = register({
        menu: 'Input/Basic/Time',
        title: 'Time'
      }), _dec(_class = /*#__PURE__*/function (_InputNode) {
        _inheritsLoose(TimeNode, _InputNode);
        function TimeNode() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _InputNode.call.apply(_InputNode, [this].concat(args)) || this;
          _this.data = {
            outputs: [slot('Time', 0, 'float', 'vector'), slot('Sine Time', 0, 'float', 'vector'), slot('Cosine Time', 0, 'float', 'vector'), slot('Delta Time', 0, 'float', 'vector'), slot('Smooth Delta', 0, 'float', 'vector')]
          };
          return _this;
        }
        var _proto = TimeNode.prototype;
        _proto.generateCode = function generateCode() {
          var Time = this.getOutputSlotWithSlotName('Time');
          var SineTime = this.getOutputSlotWithSlotName('Sine Time');
          var CosineTime = this.getOutputSlotWithSlotName('Cosine Time');
          var DeltaTime = this.getOutputSlotWithSlotName('Delta Time');
          var SmoothDelta = this.getOutputSlotWithSlotName('Smooth Delta');
          var code = '';
          if (Time != null && Time.connectSlot) {
            code += "float " + Time.varName + " = cc_time.x;";
          }
          if (SineTime != null && SineTime.connectSlot) {
            code += "float " + SineTime.varName + " = sin(cc_time.x);";
          }
          if (CosineTime != null && CosineTime.connectSlot) {
            code += "float " + CosineTime.varName + " = cos(cc_time.x);";
          }
          if (DeltaTime != null && DeltaTime.connectSlot) {
            code += "float " + DeltaTime.varName + " = cc_time.y;";
          }
          if (SmoothDelta != null && SmoothDelta.connectSlot) {
            console.warn('Not support smooth delta time');
            code += "float " + SmoothDelta.varName + " = cc_time.y;";
          }
          return code;
        };
        return TimeNode;
      }(InputNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ToggleAutoSound.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './audioManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Toggle, EventHandler, Component, AudioManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Toggle = module.Toggle;
      EventHandler = module.EventHandler;
      Component = module.Component;
    }, function (module) {
      AudioManager = module.AudioManager;
    }],
    execute: function () {
      var _dec, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "36cdeVcYgBP746cVQn6km3N", "ToggleAutoSound", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var ToggleAutoSound = exports('ToggleAutoSound', (_dec = ccclass('ToggleAutoSound'), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(ToggleAutoSound, _Component);
        function ToggleAutoSound() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "onAudioName", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "offAudioName", _descriptor2, _assertThisInitialized(_this));
          _this.toggle = null;
          return _this;
        }
        var _proto = ToggleAutoSound.prototype;
        _proto.onLoad = function onLoad() {
          this.toggle = this.getComponent(Toggle);
          if (!this.toggle) return;
          var eventHandler = new EventHandler();
          eventHandler.target = this.node;
          eventHandler.component = "ToggleAutoSound";
          eventHandler.handler = "onToggleChanged";
          this.toggle.checkEvents.push(eventHandler);
        };
        _proto.onToggleChanged = function onToggleChanged() {
          if (!this.toggle) return;
          AudioManager.instance.playSound(this.toggle.isChecked ? this.onAudioName : this.offAudioName);
        };
        return ToggleAutoSound;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "onAudioName", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return "sfx_lobby_ui_01";
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "offAudioName", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return "sfx_lobby_ui_01_Low";
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ToggleHotKey.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './HotKey.ts'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, Toggle, Hotkey;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Toggle = module.Toggle;
    }, function (module) {
      Hotkey = module.Hotkey;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "37345Pr89dKxKXe+sjSuW5N", "ToggleHotKey", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var ToggleHotKey = exports('ToggleHotKey', (_dec = ccclass('ToggleHotKey'), _dec(_class = /*#__PURE__*/function (_Hotkey) {
        _inheritsLoose(ToggleHotKey, _Hotkey);
        function ToggleHotKey() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Hotkey.call.apply(_Hotkey, [this].concat(args)) || this;
          _this.toggle = null;
          return _this;
        }
        var _proto = ToggleHotKey.prototype;
        _proto.onLoad = function onLoad() {
          _Hotkey.prototype.onLoad.call(this);
          this.toggle = this.getComponent(Toggle);
        };
        _proto.trigger = function trigger() {
          _Hotkey.prototype.trigger.call(this);
          if (this.toggle) {
            this.toggle.isChecked = !this.toggle.isChecked;
            this.toggle.checkEvents.forEach(function (event) {
              event.emit(null);
            });
          }
        };
        return ToggleHotKey;
      }(Hotkey)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/TrajectoryDrawer.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ProjectileMath.ts', './VectorUtil.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Prefab, NodePool, Vec3, Quat, MeshRenderer, instantiate, Component, ProjectileMath, VectorUtil;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Prefab = module.Prefab;
      NodePool = module.NodePool;
      Vec3 = module.Vec3;
      Quat = module.Quat;
      MeshRenderer = module.MeshRenderer;
      instantiate = module.instantiate;
      Component = module.Component;
    }, function (module) {
      ProjectileMath = module.ProjectileMath;
    }, function (module) {
      VectorUtil = module.VectorUtil;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3;
      cclegacy._RF.push({}, "01c94oOie9EDZDjFFfzDe9j", "TrajectoryDrawer", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var TrajectoryDrawer = exports('TrajectoryDrawer', (_dec = ccclass('TrajectoryDrawer'), _dec2 = property({
        type: Prefab,
        displayName: 'prefab'
      }), _dec3 = property({
        displayName: 'fixedQuantity'
      }), _dec4 = property({
        visible: function visible() {
          return this.fixedQuantity;
        },
        displayName: 'quantity'
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(TrajectoryDrawer, _Component);
        function TrajectoryDrawer() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "prefab", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "fixedQuantity", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "quantity", _descriptor3, _assertThisInitialized(_this));
          _this.points = [];
          _this.nodePool = new NodePool();
          _this.tempVec3 = new Vec3();
          _this.tempQuat = new Quat();
          return _this;
        }
        var _proto = TrajectoryDrawer.prototype;
        _proto.draw = function draw(startPos, targetPos, angle, velocity, fixedDistance, maxDistance) {
          var direction = Vec3.subtract(new Vec3(), targetPos, startPos);
          var directionOnPlane = VectorUtil.projectOnPlane(direction, Vec3.UP);
          var distance = fixedDistance != undefined ? fixedDistance : directionOnPlane.length();
          // if (distance >= maxDistance) return;
          var time = ProjectileMath.calculateTotalTime(distance, angle, velocity);
          var count;
          if (this.fixedQuantity) {
            count = Math.ceil(this.quantity);
          } else {
            count = Math.max(8, Math.ceil(distance * 3));
          }
          var interval = time / count;
          this.producePoints(count);
          var forward = directionOnPlane.normalize();
          var points = this.points,
            tempVec3 = this.tempVec3,
            tempQuat = this.tempQuat;
          for (var i = 0; i < count; i++) {
            var node = points[i];
            node.active = true;
            var _time = (i + 1) * interval;
            var _ProjectileMath$calcu = ProjectileMath.calculateDisplacementAtMoment(angle, velocity, _time),
              x = _ProjectileMath$calcu.x,
              y = _ProjectileMath$calcu.y;
            var position = startPos.clone();
            position.add(tempVec3.set(forward).multiplyScalar(x));
            position.add(tempVec3.set(Vec3.UP).multiplyScalar(y));
            node.setWorldPosition(position);
            var rotation = Quat.fromViewUp(tempQuat, forward, Vec3.UP);
            var pitch = -ProjectileMath.calculateAngleAtMoment(angle, velocity, _time, true);
            Quat.rotateX(rotation, rotation, pitch);
            node.setWorldRotation(rotation);
          }
        };
        _proto.clear = function clear() {
          this.producePoints(0);
        };
        _proto.setColor = function setColor(color) {
          var renderer = this.prefab.data.getComponent(MeshRenderer);
          if (!renderer) {
            renderer = this.prefab.data.getComponentInChildren(MeshRenderer);
          }
          if (renderer) {
            renderer.sharedMaterial.setProperty('mainColor', color);
          }
        };
        _proto.producePoints = function producePoints(quantity) {
          var points = this.points;
          if (points.length < quantity) {
            var diff = quantity - points.length;
            while (diff > 0) {
              points.push(this.getPoint());
              diff--;
            }
          } else if (points.length > quantity) {
            var _diff = points.length - quantity;
            while (_diff > 0) {
              this.putPoint(points.pop());
              _diff--;
            }
          }
        };
        _proto.getPoint = function getPoint() {
          var node;
          if (this.nodePool.size() > 0) {
            node = this.nodePool.get();
          } else {
            node = instantiate(this.prefab);
          }
          node.setParent(this.node);
          return node;
        };
        _proto.putPoint = function putPoint(node) {
          if (this.nodePool.size() < 50) {
            this.nodePool.put(node);
          } else {
            node.destroy();
          }
        };
        return TrajectoryDrawer;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "prefab", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "fixedQuantity", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "quantity", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 20;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/triangle-wave.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "92a3eZPGhZGbpxgWBNEKAGs", "triangle-wave", undefined);
      var TriangleWave = exports('default', (_dec = register({
        menu: 'Math/Wave/TriangleWave',
        title: 'TriangleWave'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(TriangleWave, _ShaderNode);
        function TriangleWave() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = TriangleWave.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = 2.0 * abs( 2 * (" + input0 + " - floor(0.5 + " + input0 + ")) ) - 1.0;\n        ";
        };
        return TriangleWave;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/truncate.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "96ddfY+NwRNKa+F0/nHJXIw", "truncate", undefined);
      var Truncate = exports('default', (_dec = register({
        menu: 'Math/Round/Truncate',
        title: 'Truncate'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Truncate, _ShaderNode);
        function Truncate() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('In', Vec4.ZERO, 'vec4', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Truncate.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = trunc(" + input0 + ");\n        ";
        };
        return Truncate;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/type.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "298c3IQrZBP6Lx7XE+N393z", "type", undefined);
      var ConcretePrecisionType = exports('ConcretePrecisionType', /*#__PURE__*/function (ConcretePrecisionType) {
        ConcretePrecisionType[ConcretePrecisionType["Min"] = 0] = "Min";
        ConcretePrecisionType[ConcretePrecisionType["Max"] = 1] = "Max";
        ConcretePrecisionType[ConcretePrecisionType["Fixed"] = 2] = "Fixed";
        ConcretePrecisionType[ConcretePrecisionType["Texture"] = 3] = "Texture";
        return ConcretePrecisionType;
      }({}));
      ConcretePrecisionType._name = 'ConcretePrecisionType';
      var TextureConcretePrecision = exports('TextureConcretePrecision', /*#__PURE__*/function (TextureConcretePrecision) {
        TextureConcretePrecision[TextureConcretePrecision["Texture2D"] = 100] = "Texture2D";
        TextureConcretePrecision[TextureConcretePrecision["TextureCube"] = 101] = "TextureCube";
        return TextureConcretePrecision;
      }({}));
      TextureConcretePrecision._name = 'TextureConcretePrecision';
      var PositionSpace = exports('PositionSpace', /*#__PURE__*/function (PositionSpace) {
        PositionSpace[PositionSpace["Local"] = 0] = "Local";
        PositionSpace[PositionSpace["View"] = 1] = "View";
        PositionSpace[PositionSpace["World"] = 2] = "World";
        return PositionSpace;
      }({})); // Tangent,
      // AbsoluteWorld
      PositionSpace._name = 'PositionSpace';
      var NormalSpace = exports('NormalSpace', /*#__PURE__*/function (NormalSpace) {
        NormalSpace[NormalSpace["Local"] = 0] = "Local";
        NormalSpace[NormalSpace["View"] = 1] = "View";
        NormalSpace[NormalSpace["World"] = 2] = "World";
        return NormalSpace;
      }({})); // Tangent,
      NormalSpace._name = 'NormalSpace';
      var ViewDirSpace = exports('ViewDirSpace', /*#__PURE__*/function (ViewDirSpace) {
        ViewDirSpace[ViewDirSpace["Local"] = 0] = "Local";
        ViewDirSpace[ViewDirSpace["View"] = 1] = "View";
        ViewDirSpace[ViewDirSpace["World"] = 2] = "World";
        return ViewDirSpace;
      }({})); // Tangent,
      ViewDirSpace._name = 'ViewDirSpace';
      var NormalMapSpace = exports('NormalMapSpace', 300);

      //  any slot 

      /**
       *  shader node  key
       */
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UIAutoVersion.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Utils2.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Label, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Label = module.Label;
      Component = module.Component;
    }, null],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "ade5btidtpL5YVAIw3v0u9e", "UIAutoVersion", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var UIAutoVersion = exports('UIAutoVersion', (_dec = ccclass('UIAutoVersion'), _dec2 = property(Label), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(UIAutoVersion, _Component);
        function UIAutoVersion() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "lbVersion", _descriptor, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = UIAutoVersion.prototype;
        _proto.start = function start() {};
        _proto.onFocusInEditor = function onFocusInEditor() {};
        return UIAutoVersion;
      }(Component), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "lbVersion", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UIAvatar.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './assetRemoteUtil.ts', './ImageLoader.ts'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, Sprite, Component, assetRemoteUtil, ImageLoader;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Sprite = module.Sprite;
      Component = module.Component;
    }, function (module) {
      assetRemoteUtil = module.assetRemoteUtil;
    }, function (module) {
      ImageLoader = module.ImageLoader;
    }],
    execute: function () {
      var _dec, _dec2, _class;
      cclegacy._RF.push({}, "03f5c6o2sJBCL/VJkJmJTZA", "UIAvatar", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property,
        requireComponent = _decorator.requireComponent;
      var UIAvatar = exports('UIAvatar', (_dec = ccclass('UIAvatar'), _dec2 = requireComponent(Sprite), _dec(_class = _dec2(_class = /*#__PURE__*/function (_Component) {
        _inheritsLoose(UIAvatar, _Component);
        function UIAvatar() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this.sprite = null;
          _this.data = null;
          _this.url = null;
          _this.id = null;
          _this.loadAvatarFunction = null;
          return _this;
        }
        var _proto = UIAvatar.prototype;
        _proto.onLoad = function onLoad() {
          this.sprite = this.getComponent(Sprite);
        };
        _proto.onDisable = function onDisable() {
          if (this.loadAvatarFunction) {
            assetRemoteUtil.removeListenAvatar(this.url, this.loadAvatarFunction);
          }
        };
        _proto.setData = function setData(photo_url, id) {
          if (!this.sprite) return;
          this.sprite.spriteFrame = ImageLoader.instance.getAvatar(this.id);
          this.id = id;
          this.url = photo_url;
          this.loadAvatarFunction = this.onLoadedAvatar.bind(this);
          assetRemoteUtil.loadAndListenAvatar(photo_url, this.loadAvatarFunction);
        };
        _proto.onLoadedAvatar = function onLoadedAvatar(sf) {
          this.sprite.spriteFrame = sf != null ? sf : ImageLoader.instance.getAvatar(this.id);
          this.loadAvatarFunction = null; // only load one per set data 
        };

        _proto.clear = function clear() {
          this.sprite.spriteFrame = null;
        };
        return UIAvatar;
      }(Component)) || _class) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UICashAnimation.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, Sprite, Vec3, v3, tween, Component;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Sprite = module.Sprite;
      Vec3 = module.Vec3;
      v3 = module.v3;
      tween = module.tween;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "60a69bp1SlI3LOxXGNq+M1o", "UICashAnimation", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var UICashAnimation = exports('UICashAnimation', (_dec = ccclass('UICashAnimation'), _dec(_class = /*#__PURE__*/function (_Component) {
        _inheritsLoose(UICashAnimation, _Component);
        function UICashAnimation() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this.posY = [];
          _this.sprites = [];
          _this.tweens = [];
          return _this;
        }
        var _proto = UICashAnimation.prototype;
        _proto.init = function init() {
          var _this2 = this;
          this.sprites = this.getComponentsInChildren(Sprite);
          this.sprites.forEach(function (sprite) {
            _this2.posY.push(sprite.node.position.y);
            _this2.tweens.push(null);
          });
        };
        _proto.setVisible = function setVisible(isVisible, time, callback, toStackNumber) {
          var _this3 = this;
          if (toStackNumber === void 0) {
            toStackNumber = -1;
          }
          if (this.sprites.length <= 0) {
            this.init();
          }
          if (toStackNumber < 0) {
            toStackNumber = this.sprites.length;
          } else {
            toStackNumber = Math.min(this.sprites.length, toStackNumber);
          }
          if (isVisible) {
            this.sprites.forEach(function (sprt) {
              return sprt.node.position = Vec3.ZERO;
            });
            var timePerStack = time / toStackNumber;
            var _loop = function _loop() {
              var _this3$tweens$index;
              var timeAnim = i * timePerStack;
              var index = i;
              _this3.sprites[index].node.active = true;
              if (time <= 0.0) {
                _this3.sprites[index].node.position = v3(0.0, _this3.posY[index]);
                return 1; // continue
              }

              (_this3$tweens$index = _this3.tweens[index]) == null || _this3$tweens$index.stop();
              _this3.tweens[index] = tween(_this3.sprites[index].node).to(timeAnim, {
                position: v3(0.0, _this3.posY[index])
              }).call(function () {
                if (index == toStackNumber - 1) {
                  callback == null || callback();
                }
              }).start();
            };
            for (var i = 0; i < toStackNumber; i++) {
              if (_loop()) continue;
            }
          } else {
            var _loop2 = function _loop2() {
              var _this3$tweens$index2;
              var index = _i;
              if (time <= 0.0) {
                _this3.sprites[index].node.active = false;
                return 1; // continue
              }

              (_this3$tweens$index2 = _this3.tweens[index]) == null || _this3$tweens$index2.stop();
              _this3.tweens[index] = tween(_this3.sprites[index].node).to(time, {
                position: Vec3.ZERO
              }).call(function () {
                _this3.sprites[index].node.active = false;
                if (index == _this3.sprites.length - 1) {
                  callback == null || callback();
                }
              }).start();
            };
            for (var _i = 0; _i < this.sprites.length; _i++) {
              if (_loop2()) continue;
            }
          }
        };
        return UICashAnimation;
      }(Component)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UICoins.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ClientEvent.ts', './Constants.ts', './UserManager.ts', './Utils2.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Node, Label, tween, v3, Vec3, easing, Component, ClientEvent, GameConstant, UserManager, Utils;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Label = module.Label;
      tween = module.tween;
      v3 = module.v3;
      Vec3 = module.Vec3;
      easing = module.easing;
      Component = module.Component;
    }, function (module) {
      ClientEvent = module.ClientEvent;
    }, function (module) {
      GameConstant = module.GameConstant;
    }, function (module) {
      UserManager = module.UserManager;
    }, function (module) {
      Utils = module.Utils;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor, _class3;
      cclegacy._RF.push({}, "f56b3kOhzpA5qPzFsat65CR", "UICoins", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var UICoins = exports('UICoins', (_dec = ccclass('UICoins'), _dec2 = property(Node), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(UICoins, _Component);
        function UICoins() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "nodeIcon", _descriptor, _assertThisInitialized(_this));
          _this.labelMain = null;
          _this.showCoins = {
            value: 0
          };
          _this.tweenMain = null;
          _this.tweenNodeCoin = null;
          return _this;
        }
        var _proto = UICoins.prototype;
        _proto.onEnable = function onEnable() {
          if (this.labelMain == null) {
            this.labelMain = this.getComponent(Label);
          }
          ClientEvent.on(GameConstant.EVENT_NAME.USERCOIN_UPDATED, this.updateData, this);
          UICoins.uistacks.push(this);
        };
        _proto.onDisable = function onDisable() {
          var _this2 = this,
            _this$tweenMain;
          ClientEvent.off(GameConstant.EVENT_NAME.USERCOIN_UPDATED, this.updateData, this);
          UICoins.uistacks = UICoins.uistacks.filter(function (ui) {
            return ui != _this2;
          });
          (_this$tweenMain = this.tweenMain) == null || _this$tweenMain.stop();
          this.tweenMain = null;
        };
        _proto.updateData = function updateData() {
          var _this$tweenMain2,
            _this3 = this;
          var checkCoins = UserManager.instance.coins;
          (_this$tweenMain2 = this.tweenMain) == null || _this$tweenMain2.stop();
          this.tweenMain = tween(this.showCoins).to(0.35, {
            value: checkCoins
          }).call(function () {
            var _this3$showCoins;
            _this3.tweenMain = null;
            _this3.labelMain.string = Utils.formatNumber(Math.round((_this3$showCoins = _this3.showCoins) == null ? void 0 : _this3$showCoins.value));
          }).start();
        };
        _proto.update = function update(dt) {
          var _this$showCoins;
          if (this.tweenMain == null) return;
          var checkShown = Utils.formatNumber(Math.round((_this$showCoins = this.showCoins) == null ? void 0 : _this$showCoins.value));
          if (this.labelMain.string == checkShown) return;
          this.labelMain.string = checkShown;
        };
        _proto.doSpriteEffect = function doSpriteEffect() {
          var _this$tweenNodeCoin;
          if (!this.nodeIcon) return;
          this.nodeIcon.scale = v3(1.1, 1.1);
          (_this$tweenNodeCoin = this.tweenNodeCoin) == null || _this$tweenNodeCoin.stop();
          this.tweenNodeCoin = tween(this.nodeIcon).to(0.15, {
            scale: Vec3.ONE
          }, {
            easing: easing.backIn
          }).start();
        };
        _createClass(UICoins, null, [{
          key: "position",
          get: function get() {
            try {
              return this.uistacks[this.uistacks.length - 1].node.worldPosition;
            } catch (error) {
              return new Vec3(0, 0, 0);
            }
          }
        }, {
          key: "iconPosition",
          get: function get() {
            try {
              return this.uistacks[this.uistacks.length - 1].nodeIcon.worldPosition;
            } catch (error) {
              return new Vec3(0, 0, 0);
            }
          }
        }, {
          key: "current",
          get: function get() {
            try {
              return this.uistacks[this.uistacks.length - 1];
            } catch (error) {
              return null;
            }
          }
        }]);
        return UICoins;
      }(Component), _class3.uistacks = [], _class3), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "nodeIcon", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UICountdownNumber.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './UINumberLabel.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Sprite, CCBoolean, math, UINumberLabel;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Sprite = module.Sprite;
      CCBoolean = module.CCBoolean;
      math = module.math;
    }, function (module) {
      UINumberLabel = module.UINumberLabel;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "64605hgPdJFkLm/270UV/jD", "UICountdownNumber", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var UICountdownNumber = exports('UICountdownNumber', (_dec = ccclass('UICountdownNumber'), _dec2 = property(Sprite), _dec3 = property(CCBoolean), _dec(_class = (_class2 = /*#__PURE__*/function (_UINumberLabel) {
        _inheritsLoose(UICountdownNumber, _UINumberLabel);
        function UICountdownNumber() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _UINumberLabel.call.apply(_UINumberLabel, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "sprtProgress", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "isProgressSpriteRevert", _descriptor2, _assertThisInitialized(_this));
          _this.startValue = 0;
          _this.onRoundNumberCallback = null;
          _this.lastRoundNumberCall = 0;
          return _this;
        }
        var _proto = UICountdownNumber.prototype;
        _proto.startCountdownFrom = function startCountdownFrom(value, callback, format, onRoundNumberCallback) {
          if (callback === void 0) {
            callback = null;
          }
          if (format === void 0) {
            format = "";
          }
          if (onRoundNumberCallback === void 0) {
            onRoundNumberCallback = null;
          }
          this.startValue = value;
          this.onRoundNumberCallback = onRoundNumberCallback;
          this.lastRoundNumberCall = 0;
          this.showValue.value = value;
          this.setNumber(0, value, true, callback, format, 0);
        };
        _proto.update = function update(dt) {
          _UINumberLabel.prototype.update.call(this, dt);
          if (this.sprtProgress) {
            var fillAmount = math.clamp(this.showValue.value / this.startValue, 0.0, 1.0);
            if (this.isProgressSpriteRevert) {
              fillAmount = 1.0 - fillAmount;
            }
            this.sprtProgress.fillRange = fillAmount;
          }
          this.checkCallRoundNumber();
        };
        _proto.checkCallRoundNumber = function checkCallRoundNumber() {
          var checkRound = Math.round(this.showValue.value);
          if (checkRound != this.lastRoundNumberCall) {
            var _this$onRoundNumberCa;
            this.lastRoundNumberCall = checkRound;
            (_this$onRoundNumberCa = this.onRoundNumberCallback) == null || _this$onRoundNumberCa.call(this, this.lastRoundNumberCall);
          }
        };
        return UICountdownNumber;
      }(UINumberLabel), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "sprtProgress", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "isProgressSpriteRevert", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UIFastToggle.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Node, EventHandler, Toggle;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      EventHandler = module.EventHandler;
      Toggle = module.Toggle;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "0c915T7nLRFS43XBQpOPZlf", "UIFastToggle", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var UIFastToggle = exports('UIFastToggle', (_dec = ccclass('UIFastToggle'), _dec2 = property([Node]), _dec(_class = (_class2 = /*#__PURE__*/function (_Toggle) {
        _inheritsLoose(UIFastToggle, _Toggle);
        function UIFastToggle() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Toggle.call.apply(_Toggle, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "nodes", _descriptor, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = UIFastToggle.prototype;
        _proto.onLoad = function onLoad() {
          var eventHandler = new EventHandler();
          eventHandler.target = this.node;
          eventHandler.component = "UIFastToggle";
          eventHandler.handler = "updateNodesState";
          this.checkEvents.push(eventHandler);
          this.updateNodesState();
        };
        _proto.updateNodesState = function updateNodesState() {
          var _this2 = this;
          this.nodes.forEach(function (node) {
            return node.active = _this2.isChecked;
          });
        };
        return UIFastToggle;
      }(Toggle), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "nodes", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UIHotkeyLabel.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './HotKey.ts', './Constants.ts', './ClientEvent.ts', './storageManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Node, Label, Component, Hotkey, GameConstant, ClientEvent, StorageManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Label = module.Label;
      Component = module.Component;
    }, function (module) {
      Hotkey = module.Hotkey;
    }, function (module) {
      GameConstant = module.GameConstant;
    }, function (module) {
      ClientEvent = module.ClientEvent;
    }, function (module) {
      StorageManager = module.StorageManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "3d20epSqOJE7Yu882uRz4oI", "UIHotkeyLabel", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var UIHotkeyLabel = exports('UIHotkeyLabel', (_dec = ccclass('UIHotkeyLabel'), _dec2 = property(Node), _dec3 = property(Label), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(UIHotkeyLabel, _Component);
        function UIHotkeyLabel() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "nodeMain", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "lbMain", _descriptor2, _assertThisInitialized(_this));
          _this.hotkey = null;
          return _this;
        }
        var _proto = UIHotkeyLabel.prototype;
        _proto.onLoad = function onLoad() {
          this.hotkey = this.node.getComponent(Hotkey);
          if (!this.hotkey) {
            console.error("UIHotkeylabel the hotkey is null");
            return;
          }
          this.lbMain.string = this.hotkey.getKeyString();
          ClientEvent.on(GameConstant.EVENT_NAME.HOTKEY_STATE_CHANGED, this.updateHotKeyState, this);
          this.updateHotKeyState();
        };
        _proto.onDestroy = function onDestroy() {
          ClientEvent.off(GameConstant.EVENT_NAME.HOTKEY_STATE_CHANGED, this.updateHotKeyState, this);
        };
        _proto.updateHotKeyState = function updateHotKeyState() {
          var _StorageManager$insta;
          var isOn = (_StorageManager$insta = StorageManager.instance.getGlobalData(GameConstant.STORAGE_KEY.HOTKEY)) != null ? _StorageManager$insta : false;
          this.nodeMain.active = isOn;
        };
        return UIHotkeyLabel;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "nodeMain", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "lbMain", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UIItemUser.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './UICoins.ts', './UIAvatar.ts', './UIName.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Component, UICoins, UIAvatar, UIName;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
    }, function (module) {
      UICoins = module.UICoins;
    }, function (module) {
      UIAvatar = module.UIAvatar;
    }, function (module) {
      UIName = module.UIName;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;
      cclegacy._RF.push({}, "5a859+X7W5OBYSIMvu0QJVW", "UIItemUser", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var UIItemUser = exports('UIItemUser', (_dec = ccclass('UIItemUser'), _dec2 = property({
        type: UIName,
        group: {
          name: "User Info",
          id: "1"
        }
      }), _dec3 = property({
        type: UIName,
        group: {
          name: "User Info",
          id: "1"
        }
      }), _dec4 = property({
        type: UICoins,
        group: {
          name: "User Info",
          id: "1"
        }
      }), _dec5 = property({
        type: UIAvatar,
        group: {
          name: "User Info",
          id: "1"
        }
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(UIItemUser, _Component);
        function UIItemUser() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "lbUserName", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "lbUserUserName", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "lbCoins", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "avatarUser", _descriptor4, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = UIItemUser.prototype;
        _proto.setUserData = function setUserData(user) {
          var _this$lbUserName2, _user$first_name, _user$last_name, _this$lbUserUserName2, _user$username, _this$lbCoins, _this$avatarUser2;
          if (!user) {
            var _this$lbUserName, _this$lbUserUserName, _this$avatarUser;
            (_this$lbUserName = this.lbUserName) == null || _this$lbUserName.setName("");
            (_this$lbUserUserName = this.lbUserUserName) == null || _this$lbUserUserName.setName("");
            (_this$avatarUser = this.avatarUser) == null || _this$avatarUser.setData(null, null);
            return;
          }
          (_this$lbUserName2 = this.lbUserName) == null || _this$lbUserName2.setName(((_user$first_name = user == null ? void 0 : user.first_name) != null ? _user$first_name : "") + " " + ((_user$last_name = user == null ? void 0 : user.last_name) != null ? _user$last_name : ""));
          (_this$lbUserUserName2 = this.lbUserUserName) == null || _this$lbUserUserName2.setName("@" + ((_user$username = user == null ? void 0 : user.username) != null ? _user$username : ""));
          (_this$lbCoins = this.lbCoins) == null || _this$lbCoins.updateData();
          (_this$avatarUser2 = this.avatarUser) == null || _this$avatarUser2.setData(user.photo_url, "");
        };
        _proto.setFechtingData = function setFechtingData(placeholder) {
          if (placeholder === void 0) {
            placeholder = "loading...";
          }
          if (this.lbUserName) {
            this.lbUserName.setName(placeholder);
          }
          if (this.lbUserUserName) {
            this.lbUserUserName.setName(placeholder);
          }
          if (this.avatarUser) {
            this.avatarUser.setData("", "");
          }
        };
        _proto.setNullAvatar = function setNullAvatar() {
          if (this.avatarUser) {
            this.avatarUser.clear();
          }
        };
        return UIItemUser;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "lbUserName", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "lbUserUserName", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "lbCoins", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "avatarUser", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/uiManager.ts", ['cc', './resourceUtil.ts', './PopupBase.ts', './PopupDefine.ts'], function (exports) {
  var cclegacy, _decorator, isValid, find, Node, resourceUtil, PopupBase, POPUP;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      isValid = module.isValid;
      find = module.find;
      Node = module.Node;
    }, function (module) {
      resourceUtil = module.resourceUtil;
    }, function (module) {
      PopupBase = module.PopupBase;
    }, function (module) {
      POPUP = module.POPUP;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "c34cbKAQZdEpJrFv/VJuh+B", "uiManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var PopupLayer = exports('PopupLayer', /*#__PURE__*/function (PopupLayer) {
        PopupLayer["LAYER_1"] = "GlobalCanvas/Layer1";
        PopupLayer["LAYER_2"] = "GlobalCanvas/Layer2";
        PopupLayer["LAYER_3"] = "GlobalCanvas/Layer3";
        PopupLayer["LAYER_4"] = "GlobalCanvas/Layer4";
        return PopupLayer;
      }({}));
      var UIManager = exports('UIManager', (_dec = ccclass("UIManager"), _dec(_class = (_class2 = /*#__PURE__*/function () {
        function UIManager() {
          this.preloadPrefabNames = [POPUP.LOADING, POPUP.MESSAGE];
          this._dictSharedPanel = {};
          this._dictLoading = {};
          this._arrPopupDialog = [];
          this.layerNodeMap = new Map();
          //#endregion
          //#region blocking
          this.blockNode = null;
          //#endregion
          //#region loading
          this.delayTimeoutDefine = 0;
          this.popupLoading = null;
          this.popupLoadingData = null;
          this.preloadUIs();
        }
        var _proto = UIManager.prototype;
        _proto.preloadUIs = function preloadUIs() {
          var _this = this;
          this.preloadPrefabNames.forEach(function (uiName) {
            _this.preloadDialog(uiName, null);
          });
        };
        _proto.isDialogVisible = function isDialogVisible(panelPath) {
          if (!this._dictSharedPanel.hasOwnProperty(panelPath)) {
            return false;
          }
          var panel = this._dictSharedPanel[panelPath];
          return isValid(panel) && panel.active && isValid(panel.parent);
        };
        _proto.getLayerNode = function getLayerNode(layer) {
          if (this.layerNodeMap.has(layer)) {
            var _node = this.layerNodeMap.get(layer);
            if (isValid(_node)) {
              return _node;
            }
          }
          var node = find(layer);
          if (!node) {
            node = new Node();

            //split by / and get the last one
            var arr = layer.split('/');
            node.name = arr[arr.length - 1];
            node.parent = find("Game/Canvas");
          }
          this.layerNodeMap.set(layer, node);
          return node;
        };
        _proto.showDialog = function showDialog(panelPath, args, cb, panelPriority, layer) {
          var _this2 = this;
          if (panelPriority === void 0) {
            panelPriority = -1;
          }
          if (layer === void 0) {
            layer = PopupLayer.LAYER_1;
          }
          if (this._dictLoading[panelPath]) {
            return;
          }
          var idxSplit = panelPath.lastIndexOf('/');
          var scriptName = panelPath.slice(idxSplit + 1);
          if (!args) {
            args = [];
          }
          if (this._dictSharedPanel.hasOwnProperty(panelPath)) {
            var panel = this._dictSharedPanel[panelPath];
            if (isValid(panel) && isValid(panel.parent)) {
              try {
                panel.parent = this.getLayerNode(layer);
                panel.active = true;
                var script = panel.getComponent(scriptName);
                var script2 = panel.getComponent(scriptName.charAt(0).toUpperCase() + scriptName.slice(1));
                if (script && script.show) {
                  script.show.apply(script, args);
                  cb && cb(script);
                } else if (script2 && script2.show) {
                  script2.show.apply(script2, args);
                  cb && cb(script2);
                } else {
                  throw "" + scriptName;
                }
                return;
              } catch (e) {
                this.showMessage({
                  message: "Error while showing dialog",
                  title: "Error"
                });
                return;
              }
            }
          }
          this.setLoading(true, 0.5);
          this._dictLoading[panelPath] = true;
          resourceUtil.createUI(panelPath, function (error, node) {
            _this2.setLoading(false);
            if (error) return;
            var isCloseBeforeShow = false;
            if (!_this2._dictLoading[panelPath]) {
              isCloseBeforeShow = true;
            }
            _this2._dictLoading[panelPath] = false;
            if (panelPriority >= 0) {
              node.setSiblingIndex(panelPriority);
            }
            _this2._dictSharedPanel[panelPath] = node;
            var script = node.getComponent(scriptName);
            var script2 = node.getComponent(scriptName.charAt(0).toUpperCase() + scriptName.slice(1));
            if (script && script.show) {
              script.show.apply(script, args);
              cb && cb(script);
            } else if (script2 && script2.show) {
              script2.show.apply(script2, args);
              cb && cb(script2);
            } else {
              throw "" + scriptName;
            }
            if (isCloseBeforeShow) {
              _this2.hideDialog(panelPath);
            }
          }, null, layer);
        };
        _proto.preloadDialog = function preloadDialog(uiName, callback) {
          var _this3 = this;
          this._dictLoading[uiName] = true;
          resourceUtil.preloadUI(uiName, function (error, node) {
            if (error) {
              callback == null || callback(error);
              return;
            }
            _this3._dictLoading[uiName] = false;
            _this3._dictSharedPanel[uiName] = node;
            node.parent = null;
            callback == null || callback(null);
          });
        };
        _proto.hideDialog = function hideDialog(panelPath, callback) {
          if (this._dictSharedPanel.hasOwnProperty(panelPath)) {
            var panel = this._dictSharedPanel[panelPath];
            if (panel && isValid(panel)) {
              var ani = panel.getComponent('animationUI');
              if (ani) {
                ani.close(function () {
                  panel.parent = null;
                  if (callback && typeof callback === 'function') {
                    callback();
                  }
                });
              } else {
                panel.parent = null;
                if (callback && typeof callback === 'function') {
                  callback();
                }
              }
            } else if (callback && typeof callback === 'function') {
              callback();
            }
          }
          this._dictLoading[panelPath] = false;
        };
        _proto.hidePopup = function hidePopup(panelPath, callback) {
          if (this._dictSharedPanel.hasOwnProperty(panelPath)) {
            var panel = this._dictSharedPanel[panelPath];
            if (panel && isValid(panel)) {
              var popup = panel.getComponent(PopupBase);
              if (popup) {
                popup.hide(function () {
                  panel.parent = null;
                  if (callback && typeof callback === 'function') {
                    callback();
                  }
                });
              } else {
                panel.parent = null;
                if (callback && typeof callback === 'function') {
                  callback();
                }
              }
            } else if (callback && typeof callback === 'function') {
              callback();
            }
          }
          this._dictLoading[panelPath] = false;
        };
        _proto.pushToPopupSeq = function pushToPopupSeq(panelPath, scriptName, param) {
          var popupDialog = {
            panelPath: panelPath,
            scriptName: scriptName,
            param: param,
            isShow: false
          };
          this._arrPopupDialog.push(popupDialog);
          this._checkPopupSeq();
        };
        _proto.insertToPopupSeq = function insertToPopupSeq(index, panelPath, param) {
          var popupDialog = {
            panelPath: panelPath,
            param: param,
            isShow: false
          };
          this._arrPopupDialog.splice(index, 0, popupDialog);
        };
        _proto.shiftFromPopupSeq = function shiftFromPopupSeq(panelPath) {
          var _this4 = this;
          this.hideDialog(panelPath, function () {
            if (_this4._arrPopupDialog[0] && _this4._arrPopupDialog[0].panelPath === panelPath) {
              _this4._arrPopupDialog.shift();
              _this4._checkPopupSeq();
            }
          });
        };
        _proto._checkPopupSeq = function _checkPopupSeq() {
          if (this._arrPopupDialog.length > 0) {
            var first = this._arrPopupDialog[0];
            if (!first.isShow) {
              this.showDialog(first.panelPath, first.param);
              this._arrPopupDialog[0].isShow = true;
            }
          }
        }

        //#region message popup
        ;

        _proto.showMessage = function showMessage(data) {
          this.showDialog(POPUP.MESSAGE, [data], function (script) {}, 9999, PopupLayer.LAYER_4);
        };
        _proto.setBlock = function setBlock(isBlock) {
          if (!this.blockNode) {
            this.blockNode = find("GlobalCanvas/Block");
          }
          this.blockNode.active = isBlock;
          this.blockNode.setSiblingIndex(999);
        };
        _proto.setLoading = function setLoading(isVisible, delay, data) {
          var _this5 = this;
          if (delay === void 0) {
            delay = 2.0;
          }
          if (data === void 0) {
            data = null;
          }
          clearTimeout(this.delayTimeoutDefine);
          if (isVisible) {
            this.setBlock(true);
            this.popupLoadingData = data;
            if (this.popupLoading) {
              this.popupLoading.setLoadingDetail(data);
              return;
            }
            this.delayTimeoutDefine = setTimeout(function () {
              _this5.showLoading();
            }, delay * 1000.0);
          } else {
            clearTimeout(this.delayTimeoutDefine);
            this.setBlock(false);
            this.hidePopup(POPUP.LOADING);
            this.popupLoading = null;
            this.popupLoadingData = null;
          }
        };
        _proto.showLoading = function showLoading() {
          var _this6 = this;
          this.showDialog(POPUP.LOADING, [this.popupLoadingData], function (script) {
            _this6.popupLoading = script;
          }, 1, PopupLayer.LAYER_3);
        }

        //#endregion
        ;

        return UIManager;
      }(), _class2.instance = void 0, _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UIName.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Utils2.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, CCInteger, Label, Utils;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      CCInteger = module.CCInteger;
      Label = module.Label;
    }, function (module) {
      Utils = module.Utils;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "4a84fL/AtlOh5ZYcK3uvEF8", "UIName", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var UIName = exports('UIName', (_dec = ccclass('UIName'), _dec2 = property(CCInteger), _dec(_class = (_class2 = /*#__PURE__*/function (_Label) {
        _inheritsLoose(UIName, _Label);
        function UIName() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Label.call.apply(_Label, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "limitChar", _descriptor, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = UIName.prototype;
        _proto.setName = function setName(value) {
          var headTailCount = Math.round((this.limitChar - 3) / 2.0);
          this.string = Utils.truncateString(value, this.limitChar, headTailCount, headTailCount);
        };
        return UIName;
      }(Label), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "limitChar", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 15;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UINumberByImages.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Utils2.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, SpriteFrame, Sprite, Node, Component, Utils;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      SpriteFrame = module.SpriteFrame;
      Sprite = module.Sprite;
      Node = module.Node;
      Component = module.Component;
    }, function (module) {
      Utils = module.Utils;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;
      cclegacy._RF.push({}, "63144Dta6NLH4Ot5UmPJL47", "UINumberByImages", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var UINumberByImages = exports('UINumberByImages', (_dec = ccclass('UINumberByImages'), _dec2 = property([SpriteFrame]), _dec3 = property([Sprite]), _dec4 = property([Sprite]), _dec5 = property(Node), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(UINumberByImages, _Component);
        function UINumberByImages() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "spriteframeNumbers", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "spriteNumbers", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "spriteDecimals", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "nodeDot", _descriptor4, _assertThisInitialized(_this));
          _this.charMap = new Map();
          return _this;
        }
        var _proto = UINumberByImages.prototype;
        _proto.onLoad = function onLoad() {
          var _this2 = this;
          this.spriteframeNumbers.forEach(function (num) {
            return _this2.charMap.set(num.name, num);
          });
        };
        _proto.getChar = function getChar(charNumber) {
          return this.charMap.get(charNumber);
        };
        _proto.setNumber = function setNumber(number) {
          this.setNumberString(Utils.toFixed(number, 5));
        };
        _proto.setNumberString = function setNumberString(number) {
          var _numbers$, _numbers$2;
          var numbers = number.split(".");
          this.nodeDot.active = numbers.length > 1;

          //must set the nubers before dot first
          var beforeDot = (_numbers$ = numbers[0]) != null ? _numbers$ : "";
          for (var i = 0; i < this.spriteNumbers.length; i++) {
            var _char = beforeDot[i];
            this.spriteNumbers[i].node.active = !!_char;
            if (!!_char) {
              this.spriteNumbers[i].spriteFrame = this.getChar(_char);
            }
          }

          //set the decimals number
          var afterDot = (_numbers$2 = numbers[1]) != null ? _numbers$2 : "";
          for (var _i = 0; _i < this.spriteDecimals.length; _i++) {
            var _char2 = afterDot[_i];
            this.spriteDecimals[_i].node.active = !!_char2;
            if (!!_char2) {
              this.spriteDecimals[_i].spriteFrame = this.getChar(_char2);
            }
          }
        };
        return UINumberByImages;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "spriteframeNumbers", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "spriteNumbers", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "spriteDecimals", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "nodeDot", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UINumberLabel.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Utils2.ts'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, tween, Label, Utils;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      tween = module.tween;
      Label = module.Label;
    }, function (module) {
      Utils = module.Utils;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "4bf9dim3D5ES4wXF3TDJfmM", "UINumberLabel", undefined);
      var ccclass = _decorator.ccclass;
      var UINumberLabel = exports('UINumberLabel', (_dec = ccclass('UINumberLabel'), _dec(_class = /*#__PURE__*/function (_Label) {
        _inheritsLoose(UINumberLabel, _Label);
        function UINumberLabel() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Label.call.apply(_Label, [this].concat(args)) || this;
          _this.showValue = {
            value: 0
          };
          _this.tweenMain = null;
          _this.isReformatNumber = false;
          _this.decimalNumberCount = 0;
          _this.format = "";
          return _this;
        }
        var _proto = UINumberLabel.prototype;
        //have to look like "(value)" the value will be replaced
        _proto.getNumber = function getNumber(input) {
          if (!this.isReformatNumber) return Utils.toFixed(input, 3);
          return Utils.formatNumber(this.showValue.value, this.decimalNumberCount, this.decimalNumberCount);
        };
        _proto.getString = function getString(input) {
          var number = this.getNumber(input);
          if (!this.format) return number;
          return this.format.replace("value", number);
        };
        _proto.onDisable = function onDisable() {
          this.stop();
        };
        _proto.setNumber = function setNumber(value, duration, isReformatNumber, callback, format, decimalNumberCount) {
          var _this$tweenMain,
            _this2 = this;
          if (duration === void 0) {
            duration = 0.35;
          }
          if (isReformatNumber === void 0) {
            isReformatNumber = true;
          }
          if (callback === void 0) {
            callback = null;
          }
          if (format === void 0) {
            format = "";
          }
          if (decimalNumberCount === void 0) {
            decimalNumberCount = 2;
          }
          this.isReformatNumber = isReformatNumber;
          this.decimalNumberCount = decimalNumberCount;
          this.format = format;
          (_this$tweenMain = this.tweenMain) == null || _this$tweenMain.stop();
          if (duration <= 0) {
            this.showValue.value = duration;
            this.string = this.getString(this.showValue.value);
            return;
          }
          this.tweenMain = tween(this.showValue).to(duration, {
            value: value
          }).call(function () {
            _this2.tweenMain = null;
            _this2.string = _this2.getString(_this2.showValue.value);
            callback == null || callback();
          }).start();
        };
        _proto.stop = function stop() {
          var _this$tweenMain2;
          (_this$tweenMain2 = this.tweenMain) == null || _this$tweenMain2.stop();
          this.tweenMain = null;
        };
        _proto.update = function update(dt) {
          if (this.tweenMain == null) return;
          var checkShown = this.getString(this.showValue.value);
          if (this.string == checkShown) return;
          this.string = checkShown;
        };
        return UINumberLabel;
      }(Label)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UINumberLabelComponent.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Utils2.ts'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, Label, tween, Component, Utils;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Label = module.Label;
      tween = module.tween;
      Component = module.Component;
    }, function (module) {
      Utils = module.Utils;
    }],
    execute: function () {
      var _dec, _dec2, _class;
      cclegacy._RF.push({}, "3d366e1pk5BN6GTDW/fi9nd", "UINumberLabelComponent", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property,
        requireComponent = _decorator.requireComponent;
      var UINumberLabelComponent = exports('UINumberLabelComponent', (_dec = ccclass('UINumberLabelComponent'), _dec2 = requireComponent(Label), _dec(_class = _dec2(_class = /*#__PURE__*/function (_Component) {
        _inheritsLoose(UINumberLabelComponent, _Component);
        function UINumberLabelComponent() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this.showValue = {
            value: 0
          };
          _this.tweenMain = null;
          _this.isReformatNumber = false;
          _this.decimalNumberCount = 0;
          _this.format = "";
          //have to look like "(value)" the value will be replaced
          _this.label = null;
          return _this;
        }
        var _proto = UINumberLabelComponent.prototype;
        _proto.onLoad = function onLoad() {
          this.label = this.node.getComponent(Label);
        };
        _proto.getNumber = function getNumber(input) {
          if (!this.isReformatNumber) return Utils.toFixed(input, 3);
          return Utils.formatNumber(this.showValue.value, this.decimalNumberCount, this.decimalNumberCount);
        };
        _proto.getString = function getString(input) {
          var number = this.getNumber(input);
          if (!this.format) return number;
          return this.format.replace("value", number);
        };
        _proto.onDisable = function onDisable() {
          this.stop();
        };
        _proto.setNumber = function setNumber(value, duration, isReformatNumber, callback, format, decimalNumberCount) {
          var _this$tweenMain,
            _this2 = this;
          if (duration === void 0) {
            duration = 0.35;
          }
          if (isReformatNumber === void 0) {
            isReformatNumber = true;
          }
          if (callback === void 0) {
            callback = null;
          }
          if (format === void 0) {
            format = "";
          }
          if (decimalNumberCount === void 0) {
            decimalNumberCount = 2;
          }
          this.isReformatNumber = isReformatNumber;
          this.decimalNumberCount = decimalNumberCount;
          this.format = format;
          (_this$tweenMain = this.tweenMain) == null || _this$tweenMain.stop();
          if (duration <= 0) {
            this.showValue.value = duration;
            this.label.string = this.getString(this.showValue.value);
            return;
          }
          this.tweenMain = tween(this.showValue).to(duration, {
            value: value
          }).call(function () {
            _this2.tweenMain = null;
            _this2.label.string = _this2.getString(_this2.showValue.value);
            callback == null || callback();
          }).start();
        };
        _proto.stop = function stop() {
          var _this$tweenMain2;
          (_this$tweenMain2 = this.tweenMain) == null || _this$tweenMain2.stop();
          this.tweenMain = null;
        };
        _proto.update = function update(dt) {
          if (this.tweenMain == null) return;
          var checkShown = this.getString(this.showValue.value);
          if (this.label.string == checkShown) return;
          this.label.string = checkShown;
        };
        return UINumberLabelComponent;
      }(Component)) || _class) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UIScaler.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, v2, screen, math, v3, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      v2 = module.v2;
      screen = module.screen;
      math = module.math;
      v3 = module.v3;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "35e18W5KnNNt7BMewSFb2bH", "UIScaler", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var UIScaler = exports('UIScaler', (_dec = ccclass('UIScaler'), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(UIScaler, _Component);
        function UIScaler() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "maxValue", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "minValue", _descriptor2, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = UIScaler.prototype;
        _proto.onLoad = function onLoad() {
          var designres = v2(1080.0, 1920.0);
          var baseRatio = designres.x / designres.y;
          var curRatio = screen.windowSize.width / screen.windowSize.height;
          var scaleRatio = math.clamp(curRatio / baseRatio, this.minValue, this.maxValue);
          this.node.setScale(v3(scaleRatio, scaleRatio, scaleRatio));
        };
        return UIScaler;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "maxValue", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1.0;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "minValue", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.5;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UIScreenScaler.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Node, Widget, UITransform, view, sys, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      Widget = module.Widget;
      UITransform = module.UITransform;
      view = module.view;
      sys = module.sys;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor, _descriptor2, _descriptor3;
      cclegacy._RF.push({}, "30045XZ1HVFj77RL4VxNUVU", "UIScreenScaler", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var UIScreenScaler = exports('UIScreenScaler', (_dec = ccclass('UIScreenScaler'), _dec2 = property(Node), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(UIScreenScaler, _Component);
        function UIScreenScaler() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "targetNode", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "designWidth", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "designHeight", _descriptor3, _assertThisInitialized(_this));
          _this.widget = null;
          _this.transform = null;
          return _this;
        }
        var _proto = UIScreenScaler.prototype;
        _proto.onLoad = function onLoad() {
          if (!this.targetNode) {
            this.targetNode = this.node;
          }
          this.widget = this.targetNode.getComponent(Widget);
          this.transform = this.targetNode.getComponent(UITransform);

          // Register for window resize events
          view.on('design-resolution-changed', this.onScreenResize, this);
          view.on('canvas-resize', this.onScreenResize, this);

          // Initial setup
          this.onScreenResize();
        };
        _proto.onDestroy = function onDestroy() {
          // Unregister from window resize events
          view.off('design-resolution-changed', this.onScreenResize, this);
          view.off('canvas-resize', this.onScreenResize, this);
        };
        _proto.onScreenResize = function onScreenResize() {
          var visibleSize = view.getVisibleSize();
          var isMobile = sys.platform === sys.Platform.MOBILE_BROWSER;
          if (isMobile) {
            // For mobile, stretch both horizontally and vertically
            this.widget.isAlignLeft = true;
            this.widget.isAlignRight = true;
            this.widget.isAlignTop = true;
            this.widget.isAlignBottom = true;
            this.widget.left = 0;
            this.widget.right = 0;
            this.widget.top = 0;
            this.widget.bottom = 0;
          } else {
            // For desktop web, handle different aspect ratios
            var targetRatio = 9 / 16;
            var currentRatio = visibleSize.width / visibleSize.height;
            if (currentRatio > targetRatio) {
              // Screen is wider than 16:9
              var targetWidth = visibleSize.height * targetRatio;
              var horizontalOffset = (visibleSize.width - targetWidth) / 2;
              this.widget.isAlignLeft = true;
              this.widget.isAlignRight = true;
              this.widget.isAlignTop = true;
              this.widget.isAlignBottom = true;
              this.widget.left = horizontalOffset;
              this.widget.right = horizontalOffset;
              this.widget.top = 0;
              this.widget.bottom = 0;
            } else {
              // Screen ratio is between 9:16 and 16:9
              this.widget.isAlignLeft = true;
              this.widget.isAlignRight = true;
              this.widget.isAlignTop = true;
              this.widget.isAlignBottom = true;
              this.widget.left = 0;
              this.widget.right = 0;
              this.widget.top = 0;
              this.widget.bottom = 0;
            }
          }

          // Update widget
          this.widget.updateAlignment();
        };
        return UIScreenScaler;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "targetNode", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "designWidth", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1080;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "designHeight", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 1920;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UISlider.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createForOfIteratorHelperLoose, cclegacy, _decorator, Sprite, Node, Slider;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createForOfIteratorHelperLoose = module.createForOfIteratorHelperLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Sprite = module.Sprite;
      Node = module.Node;
      Slider = module.Slider;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3;
      cclegacy._RF.push({}, "23aff/dfqZMeJFuAqFaQ5p2", "UISlider", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var UISlider = exports('UISlider', (_dec = ccclass('UISlider'), _dec2 = property(Sprite), _dec3 = property([Node]), _dec4 = property([Node]), _dec(_class = (_class2 = /*#__PURE__*/function (_Slider) {
        _inheritsLoose(UISlider, _Slider);
        function UISlider() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Slider.call.apply(_Slider, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "spriteFiller", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "objectsOff", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "objectsOn", _descriptor3, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = UISlider.prototype;
        _proto.start = function start() {
          this.node.on('slide', this.onSliderChange, this);
          this.onSliderChange();
        };
        _proto.onSliderChange = function onSliderChange() {
          var value = this.progress;
          this.updateSpriteFiller(value);
          this.updateObjects(value);
        };
        _proto.updateSpriteFiller = function updateSpriteFiller(value) {
          if (this.spriteFiller) {
            // Assuming the sprite filler is scaled based on the slider value
            this.spriteFiller.node.setScale(value, 1, 1);
          }
        };
        _proto.updateObjects = function updateObjects(value) {
          var isZero = value === 0;

          // Toggle visibility of objects in the first array
          for (var _iterator = _createForOfIteratorHelperLoose(this.objectsOff), _step; !(_step = _iterator()).done;) {
            var obj = _step.value;
            obj.active = isZero;
          }

          // Toggle visibility of objects in the second array
          for (var _iterator2 = _createForOfIteratorHelperLoose(this.objectsOn), _step2; !(_step2 = _iterator2()).done;) {
            var _obj = _step2.value;
            _obj.active = !isZero;
          }
        };
        return UISlider;
      }(Slider), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "spriteFiller", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "objectsOff", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "objectsOn", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UISliderRectSize.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './UISlider.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, UITransform, UISlider;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      UITransform = module.UITransform;
    }, function (module) {
      UISlider = module.UISlider;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "92959RjXUxD97yy1ukHjcyM", "UISliderRectSize", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var UISliderRectSize = exports('UISliderRectSize', (_dec = ccclass('UISliderRectSize'), _dec2 = property(UITransform), _dec3 = property(UITransform), _dec(_class = (_class2 = /*#__PURE__*/function (_UISlider) {
        _inheritsLoose(UISliderRectSize, _UISlider);
        function UISliderRectSize() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _UISlider.call.apply(_UISlider, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "transSlider", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "transMain", _descriptor2, _assertThisInitialized(_this));
          _this.originalWidth = 0.0;
          return _this;
        }
        var _proto = UISliderRectSize.prototype;
        _proto.start = function start() {
          this.originalWidth = this.transSlider.width;
          _UISlider.prototype.start.call(this);
        };
        _proto.updateSpriteFiller = function updateSpriteFiller(value) {
          this.transMain.width = value * this.originalWidth;
        };
        return UISliderRectSize;
      }(UISlider), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "transSlider", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "transMain", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UITimer.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Utils2.ts'], function (exports) {
  var _inheritsLoose, cclegacy, _decorator, Label, Component, Utils;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Label = module.Label;
      Component = module.Component;
    }, function (module) {
      Utils = module.Utils;
    }],
    execute: function () {
      var _dec, _dec2, _class;
      cclegacy._RF.push({}, "d3e939wqpFGLblmd/OMduC5", "UITimer", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property,
        requireComponent = _decorator.requireComponent;
      var UITimer = exports('UITimer', (_dec = ccclass('UITimer'), _dec2 = requireComponent(Label), _dec(_class = _dec2(_class = /*#__PURE__*/function (_Component) {
        _inheritsLoose(UITimer, _Component);
        function UITimer() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _this.label = null;
          _this.endTime = 0;
          _this.callback = null;
          _this.scheduleCountingDown = -1;
          return _this;
        }
        var _proto = UITimer.prototype;
        _proto.onLoad = function onLoad() {
          this.label = this.getComponent(Label);
        };
        _proto.onEnable = function onEnable() {
          if (this.endTime > 0) {
            this.startCountingDown(this.endTime, this.callback);
          }
        };
        _proto.onDisable = function onDisable() {
          this.stopCountingEventDown();
        };
        _proto.startCountingDown = function startCountingDown(endTime, outOfTimeCallback) {
          var _this2 = this;
          this.endTime = endTime;
          this.callback = outOfTimeCallback;
          var timeGap = endTime - Date.now();
          if (timeGap <= 0) {
            outOfTimeCallback == null || outOfTimeCallback();
            return;
          }
          var totalSeconds = Math.round(timeGap / 1000.0) + 1.0;
          var countDown = function countDown() {
            if (--totalSeconds < 0) {
              outOfTimeCallback == null || outOfTimeCallback();
              return;
            }
            var timeStr = Utils.formatTimeForSecond(totalSeconds);
            if (_this2.label) {
              _this2.label.string = timeStr;
            }
            _this2.scheduleCountingDown = setTimeout(function () {
              countDown();
            }, 1000);
          };
          this.stopCountingEventDown();
          countDown();
        };
        _proto.stopCountingEventDown = function stopCountingEventDown() {
          clearTimeout(this.scheduleCountingDown);
        };
        return UITimer;
      }(Component)) || _class) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UIToggleGroups.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './VisiblePanel.ts', './Constants.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Toggle, EventHandler, Component, VisiblePanel, CurrentEnviroment;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Toggle = module.Toggle;
      EventHandler = module.EventHandler;
      Component = module.Component;
    }, function (module) {
      VisiblePanel = module.VisiblePanel;
    }, function (module) {
      CurrentEnviroment = module.CurrentEnviroment;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _dec4, _dec5, _dec6, _class4, _class5, _descriptor3, _descriptor4, _descriptor5;
      cclegacy._RF.push({}, "59a6c9CvhtC0L3ZWOHqwOyc", "UIToggleGroups", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var ToggleData = exports('ToggleData', (_dec = ccclass('ToggleData'), _dec2 = property(Toggle), _dec3 = property([VisiblePanel]), _dec(_class = (_class2 = /*#__PURE__*/function () {
        function ToggleData() {
          _initializerDefineProperty(this, "toggle", _descriptor, this);
          _initializerDefineProperty(this, "visibleViews", _descriptor2, this);
        }
        var _proto = ToggleData.prototype;
        _proto.updateVisible = function updateVisible() {
          var _this = this;
          this.visibleViews.forEach(function (view) {
            return view == null ? void 0 : view.setPanelVisible(_this.toggle.isChecked, 0.25, true);
          });
        };
        return ToggleData;
      }(), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "toggle", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "visibleViews", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      })), _class2)) || _class));
      var UIToggleGroups = exports('UIToggleGroups', (_dec4 = ccclass('UIToggleGroups'), _dec5 = property([ToggleData]), _dec6 = property(Toggle), _dec4(_class4 = (_class5 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(UIToggleGroups, _Component);
        function UIToggleGroups() {
          var _this2;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this2 = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this2, "data", _descriptor3, _assertThisInitialized(_this2));
          _initializerDefineProperty(_this2, "default", _descriptor4, _assertThisInitialized(_this2));
          _initializerDefineProperty(_this2, "isAllowOffAll", _descriptor5, _assertThisInitialized(_this2));
          _this2.activeToggle = null;
          return _this2;
        }
        var _proto2 = UIToggleGroups.prototype;
        _proto2.onLoad = function onLoad() {
          this.init();
        };
        _proto2.init = function init() {
          var _this3 = this;
          this.data.forEach(function (tgl) {
            var eventHandler = new EventHandler();
            eventHandler.target = _this3.node;
            eventHandler.component = "UIToggleGroups";
            eventHandler.handler = "onToggleChanged";
            tgl.toggle.checkEvents.push(eventHandler);
          });
          if (this["default"]) {
            this["default"].isChecked = true;
            this.onToggleChanged(this["default"]);
          }
        };
        _proto2.onToggleChanged = function onToggleChanged(toggle) {
          if (this.isAllowOffAll == false) ;
          if (this.activeToggle == toggle) {
            return;
          }
          if (toggle.isChecked) {
            this.activeToggle = toggle;
            this.activeToggle.interactable = false;
          }
          if (CurrentEnviroment.LOG) console.log("onToggleChanged" + toggle);
          if (toggle.isChecked) {
            this.data.forEach(function (data) {
              if (data.toggle != toggle) {
                data.toggle.isChecked = false;
                data.toggle.interactable = true;
              }
              data.updateVisible();
            });
          }

          // AudioManager.instance.playSound(GameConstant.SOUND_FILES.TAB_SWITCH);
        };

        _proto2.updateToggles = function updateToggles() {
          this.data.forEach(function (tgl) {
            tgl.updateVisible();
          });
        };
        return UIToggleGroups;
      }(Component), (_descriptor3 = _applyDecoratedDescriptor(_class5.prototype, "data", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class5.prototype, "default", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class5.prototype, "isAllowOffAll", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      })), _class5)) || _class4));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UIViewDrawer.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Defines.ts', './Constants.ts', './audioManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, Enum, Vec3, Node, tween, easing, Component, v3, ViewBeginType, GameConstant, AudioManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Enum = module.Enum;
      Vec3 = module.Vec3;
      Node = module.Node;
      tween = module.tween;
      easing = module.easing;
      Component = module.Component;
      v3 = module.v3;
    }, function (module) {
      ViewBeginType = module.ViewBeginType;
    }, function (module) {
      GameConstant = module.GameConstant;
    }, function (module) {
      AudioManager = module.AudioManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7;
      cclegacy._RF.push({}, "e1a51NjaFRBkoSdI6zruA8N", "UIViewDrawer", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var DrawerDirectionType = exports('DrawerDirectionType', /*#__PURE__*/function (DrawerDirectionType) {
        DrawerDirectionType[DrawerDirectionType["HORIZONTAL"] = 0] = "HORIZONTAL";
        DrawerDirectionType[DrawerDirectionType["VERTICAL"] = 1] = "VERTICAL";
        return DrawerDirectionType;
      }({}));
      var UIViewDrawer = exports('UIViewDrawer', (_dec = ccclass('UIViewDrawer'), _dec2 = property({
        type: Enum(ViewBeginType)
      }), _dec3 = property({
        type: Enum(DrawerDirectionType)
      }), _dec4 = property(Vec3), _dec5 = property(Node), _dec6 = property([Node]), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(UIViewDrawer, _Component);
        function UIViewDrawer() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "beginType", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "direction", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "beginPosition", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "drawerIndicator", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "nodeVisibles", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "hidePosX", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "showPosX", _descriptor7, _assertThisInitialized(_this));
          _this.visibleIndex = -1;
          return _this;
        }
        var _proto = UIViewDrawer.prototype;
        _proto.setPosition = function setPosition(input, value) {
          switch (this.direction) {
            case DrawerDirectionType.HORIZONTAL:
              input.x = value;
              break;
            case DrawerDirectionType.VERTICAL:
              input.y = value;
              break;
          }
          return input;
        };
        _proto.addPosition = function addPosition(input, value) {
          switch (this.direction) {
            case DrawerDirectionType.HORIZONTAL:
              input.x += value;
              break;
            case DrawerDirectionType.VERTICAL:
              input.y += value;
              break;
          }
          return input;
        };
        _proto.onLoad = function onLoad() {
          switch (this.beginType) {
            case ViewBeginType.NONE:
              break;
            case ViewBeginType.HIDE:
              this.nodeVisibles.forEach(function (node) {
                return node.active = false;
              });
              var hidePos = this.beginPosition.clone();
              this.setPosition(hidePos, this.hidePosX);
              this.node.setPosition(hidePos);
              if (this.drawerIndicator) {
                this.drawerIndicator.angle = 0.0;
              }
              this.visibleIndex = 0;
              break;
            case ViewBeginType.SHOW:
              this.node.setPosition(this.beginPosition);
              this.nodeVisibles.forEach(function (node) {
                return node.active = true;
              });
              if (this.drawerIndicator) {
                this.drawerIndicator.angle = 180.0;
              }
              this.visibleIndex = 1;
              break;
          }
        };
        _proto.setDrawerVisible = function setDrawerVisible(isVisible, callback, timeAction) {
          var _this2 = this;
          if (callback === void 0) {
            callback = null;
          }
          if (timeAction === void 0) {
            timeAction = 0.2;
          }
          if (this.visibleIndex == (isVisible ? 1 : 0)) return;
          this.visibleIndex = isVisible ? 1 : 0;
          if (isVisible) {
            this.nodeVisibles.forEach(function (node) {
              return node.active = true;
            });
          }
          var targetPos = this.node.position.clone();
          this.setPosition(targetPos, isVisible ? this.showPosX : this.hidePosX);
          tween(this.node).stop();
          tween(this.node).to(timeAction, {
            position: targetPos
          }, {
            easing: easing.quartOut
          }).call(function () {
            if (isVisible == false) {
              _this2.nodeVisibles.forEach(function (node) {
                return node.active = false;
              });
            }
            callback == null || callback();
          }).start();

          //drawer indicator
          var indicatorAngle = isVisible ? 180.0 : 0.0;
          if (this.drawerIndicator) {
            tween(this.drawerIndicator).stop();
            tween(this.drawerIndicator).to(timeAction, {
              angle: indicatorAngle
            }, {
              easing: easing.backOut
            }).start();
          }
        };
        _proto.show = function show(data, callback) {
          var _this3 = this;
          if (callback === void 0) {
            callback = null;
          }
          this.setDrawerVisible(true, function () {
            _this3.shown();
            callback == null || callback();
          });
          AudioManager.instance.playSound(GameConstant.SOUND_FILES.SLIDE_IN);
        };
        _proto.doShow = function doShow() {
          this.show(null);
        };
        _proto.doHide = function doHide() {
          this.hide();
        };
        _proto.hide = function hide(callback) {
          var _this4 = this;
          if (callback === void 0) {
            callback = null;
          }
          this.setDrawerVisible(false, function () {
            _this4.hided();
            callback == null || callback();
          });
          AudioManager.instance.playSound(GameConstant.SOUND_FILES.SLIDE_OUT);
        };
        _proto.shown = function shown() {};
        _proto.hided = function hided() {};
        _proto.onTouch_ShowHide = function onTouch_ShowHide() {
          if (this.visibleIndex == 1) {
            this.doHide();
          } else {
            this.doShow();
          }
        };
        _createClass(UIViewDrawer, [{
          key: "isShowing",
          get: function get() {
            return this.visibleIndex == 1;
          }
        }]);
        return UIViewDrawer;
      }(Component), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "beginType", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ViewBeginType.HIDE;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "direction", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return DrawerDirectionType.HORIZONTAL;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "beginPosition", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return v3(0.0, 0.0, 0.0);
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "drawerIndicator", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "nodeVisibles", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return [];
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "hidePosX", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "showPosX", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UnlitMasterNode.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './MasterNode.ts', './utils.ts', './index3.ts', './context.ts', './register.ts'], function (exports) {
  var _inheritsLoose, _createClass, cclegacy, Vec3, Vec4, MasterSlotType, MasterNode, slot, path, shaderContext, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec3 = module.Vec3;
      Vec4 = module.Vec4;
    }, function (module) {
      MasterSlotType = module.MasterSlotType;
      MasterNode = module.default;
    }, function (module) {
      slot = module.slot;
      path = module.path;
    }, null, function (module) {
      shaderContext = module.shaderContext;
    }, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "f3fa2kI6ulBJKyUfbfTCT2P", "UnlitMasterNode", undefined);
      var UnlitMasterNode = exports('default', (_dec = register({
        title: 'Unlit',
        master: true
      }), _dec(_class = /*#__PURE__*/function (_MasterNode) {
        _inheritsLoose(UnlitMasterNode, _MasterNode);
        function UnlitMasterNode() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _MasterNode.call.apply(_MasterNode, [this].concat(args)) || this;
          _this.data = {
            inputs: [slot('Vertex Position', Vec3.ZERO, 'vec3', 'vector', {
              slotType: MasterSlotType.Vertex,
              codeChunk: 0
            }), slot('Vertex Normal', Vec3.ZERO, 'vec3', 'vector', {
              slotType: MasterSlotType.Vertex,
              codeChunk: 0
            }), slot('Vertex Tangent', Vec3.ZERO, 'vec3', 'vector', {
              slotType: MasterSlotType.Vertex,
              codeChunk: 0
            }), slot('BaseColor', new Vec4(0.5, 0.5, 0.5, 0.5), 'color', 'vector', {
              slotType: MasterSlotType.Fragment,
              codeChunk: 3
            }), slot('Alpha', 1, 'float', 'vector', {
              slotType: MasterSlotType.Fragment,
              codeChunk: 3
            }), slot('AlphaClipThreshold', 0, 'float', 'vector', {
              slotType: MasterSlotType.Fragment,
              codeChunk: 3
            })]
          };
          return _this;
        }
        UnlitMasterNode.generatePreviewCode = function generatePreviewCode(node) {
          var tempNode = new UnlitMasterNode();
          tempNode.init();
          var baseColor = tempNode.getSlotWithSlotName('BaseColor');
          if (baseColor) {
            baseColor.connectSlots[0] = node.outputs[0];
          }
          return tempNode.generateCode();
        };
        _createClass(UnlitMasterNode, [{
          key: "templatePath",
          get: function get() {
            return path.join(shaderContext.shaderTemplatesDir, 'master/UnlitMasterNode.effect');
          }
        }]);
        return UnlitMasterNode;
      }(MasterNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UserInteractHandler.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Defines.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Node, NodeEventType, Vec2, Component, UserInteractEventType;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      NodeEventType = module.NodeEventType;
      Vec2 = module.Vec2;
      Component = module.Component;
    }, function (module) {
      UserInteractEventType = module.UserInteractEventType;
    }],
    execute: function () {
      var _dec, _dec2, _class2, _class3, _descriptor;
      cclegacy._RF.push({}, "6cc02rpxS1ESpwuMymGkGQL", "UserInteractHandler", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var EventBase = exports('EventBase', function EventBase() {
        this.type = UserInteractEventType.NONE;
        this.data = null;
      });
      var UserInteractHandler = exports('UserInteractHandler', (_dec = ccclass('TouchController'), _dec2 = property(Node), _dec(_class2 = (_class3 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(UserInteractHandler, _Component);
        function UserInteractHandler() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "listenerNode", _descriptor, _assertThisInitialized(_this));
          //#region observer
          _this.listeners = {};
          //#endregion
          //#region interacting
          _this.initialDistance = null;
          _this.startTouchPos = null;
          _this.isTouchMoveTrigger = false;
          _this.lastDragPos = null;
          return _this;
        }
        var _proto = UserInteractHandler.prototype;
        _proto.onLoad = function onLoad() {
          this.initInteracting();
        };
        _proto.onDestroy = function onDestroy() {};
        _proto.addListener = function addListener(eventType, listener) {
          if (!this.listeners[eventType]) {
            this.listeners[eventType] = [];
          }
          this.listeners[eventType].push(listener);
        };
        _proto.removeListener = function removeListener(eventType, listener) {
          if (this.listeners[eventType]) {
            var index = this.listeners[eventType].indexOf(listener);
            if (index > -1) {
              this.listeners[eventType].splice(index, 1);
            }
          }
        };
        _proto.dispatchEvent = function dispatchEvent(event) {
          if (this.listeners[event.type]) {
            this.listeners[event.type].forEach(function (listener) {
              return listener(event.data);
            });
          }
        };
        _proto.resetValues = function resetValues() {
          this.startTouchPos = null;
          this.initialDistance = null;
          this.lastDragPos = null;
        };
        _proto.initInteracting = function initInteracting() {
          var _this2 = this;
          this.listenerNode.on(NodeEventType.MOUSE_WHEEL, function (event) {
            var dispatchEvent = new EventBase();
            dispatchEvent.type = UserInteractEventType.ZOOM;
            dispatchEvent.data = -event.getScrollY() / 10.0;
            _this2.dispatchEvent(dispatchEvent);
          }, this);
          this.listenerNode.on(NodeEventType.TOUCH_START, this.onTouchStart, this);
          this.listenerNode.on(NodeEventType.TOUCH_MOVE, this.onTouchMove, this);
          this.listenerNode.on(NodeEventType.TOUCH_END, this.onTouchEnd, this);
          this.listenerNode.on(NodeEventType.TOUCH_CANCEL, this.onTouchEnd, this);
          this.listenerNode.on(NodeEventType.MOUSE_ENTER, this.onHoverBackground, this);
        };
        _proto.onHoverBackground = function onHoverBackground(event) {
          var dispatchEvent = new EventBase();
          dispatchEvent.type = UserInteractEventType.HOVER;
          this.dispatchEvent(dispatchEvent);
        };
        _proto.onTouchStart = function onTouchStart(event) {
          if (event.getTouches().length === 2) {
            this.initialDistance = this.getDistanceBetweenTouches(event);
          }
          if (event.getTouches().length === 1) {
            this.startTouchPos = event.getTouches()[0].getLocation();
          }
          this.isTouchMoveTrigger = false;
        };
        _proto.onTouchMove = function onTouchMove(event) {
          if (event.getTouches().length === 2) {
            var currentDistance = this.getDistanceBetweenTouches(event);
            var scale = currentDistance - this.initialDistance;
            // this.initialDistance = currentDistance;

            var dispatchEvent = new EventBase();
            dispatchEvent.type = UserInteractEventType.ZOOM;
            var weight = -0.01;
            dispatchEvent.data = scale * weight;
            this.dispatchEvent(dispatchEvent);
            this.isTouchMoveTrigger = true;
          } else if (event.getTouches().length === 1) {
            var currentTouchPos = event.getTouches()[0].getLocation();
            var _dispatchEvent = new EventBase();
            _dispatchEvent.type = UserInteractEventType.DRAG;
            _dispatchEvent.data = {
              start: this.lastDragPos == null ? this.startTouchPos : this.lastDragPos,
              current: currentTouchPos
            };
            this.dispatchEvent(_dispatchEvent);
            this.isTouchMoveTrigger = true;
            this.lastDragPos = currentTouchPos.clone();
          }
        };
        _proto.onTouchEnd = function onTouchEnd(event) {
          if (event.getTouches().length < 2) {
            this.initialDistance = null;
            this.lastDragPos = null;
            if (this.isTouchMoveTrigger == false) {
              var _dispatchEvent2 = new EventBase();
              _dispatchEvent2.type = UserInteractEventType.TOUCH;
              _dispatchEvent2.data = this.startTouchPos;
              this.dispatchEvent(_dispatchEvent2);
            }
          }
          if (event.getTouches().length === 0 && this.startTouchPos) {
            var endTouchPos = event.getTouches()[0].getLocation();
            if (Vec2.distance(endTouchPos, this.startTouchPos) > 100.0) {
              var _dispatchEvent3 = new EventBase();
              _dispatchEvent3.type = UserInteractEventType.SWIPE;
              _dispatchEvent3.data = {
                start: this.startTouchPos,
                end: endTouchPos
              };
              this.dispatchEvent(_dispatchEvent3);
            }
          }
          var dispatchEvent = new EventBase();
          dispatchEvent.type = UserInteractEventType.END_INTERACTED;
          this.dispatchEvent(dispatchEvent);
          this.startTouchPos = null;
        };
        _proto.getDistanceBetweenTouches = function getDistanceBetweenTouches(event) {
          var touches = event.getTouches();
          var touch1 = touches[0].getLocation();
          var touch2 = touches[1].getLocation();
          return Vec2.distance(touch1, touch2);
        }

        //#endregion
        ;

        return UserInteractHandler;
      }(Component), _descriptor = _applyDecoratedDescriptor(_class3.prototype, "listenerNode", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _class3)) || _class2));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UserManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _createClass, cclegacy;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "e2cc7nhdnVFF5CMWYmDA7HF", "UserManager", undefined);
      var UserManager = exports('UserManager', /*#__PURE__*/function () {
        function UserManager() {
          this.userdata = null;
          UserManager.instance = this;
        }
        var _proto = UserManager.prototype;
        _proto.setUserData = function setUserData(userdata) {
          this.userdata = userdata;
        }

        //#region user base info
        ;

        _createClass(UserManager, [{
          key: "id",
          get: function get() {
            var _this$userdata$id;
            return (_this$userdata$id = this.userdata.id) != null ? _this$userdata$id : "";
          }
        }, {
          key: "coins",
          get: function get() {
            var _this$userdata$coin, _this$userdata;
            return (_this$userdata$coin = (_this$userdata = this.userdata) == null ? void 0 : _this$userdata.coin) != null ? _this$userdata$coin : 0;
          }
        }]);
        return UserManager;
      }());
      UserManager.instance = null;
      var user = new UserManager();
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/UserModel.ts", ['cc'], function () {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "2863714705FO4J9mAWwN/3b", "UserModel", undefined);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/utils.ts", ['cc', './env', './type.ts'], function (exports) {
  var cclegacy, EDITOR, TextureConcretePrecision;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      EDITOR = module.EDITOR;
    }, function (module) {
      TextureConcretePrecision = module.TextureConcretePrecision;
    }],
    execute: function () {
      exports({
        ensureEnumDefines: ensureEnumDefines,
        getEnumDefine: getEnumDefine,
        getEnumDefineName: getEnumDefineName,
        getEnumNames: getEnumNames,
        getFloatString: getFloatString,
        getJsonObject: getJsonObject,
        getPrecisionName: getPrecisionName,
        getValueConcretePrecision: getValueConcretePrecision,
        getValueElement: getValueElement,
        getValueElementStr: getValueElementStr,
        prop: prop,
        slot: slot
      });
      cclegacy._RF.push({}, "7ceabXBz/tABa7CTXDAMxJn", "utils", undefined);
      var useNpm = globalThis.electron;
      var Editor = exports('Editor', useNpm && globalThis.Editor);
      var projectPath = exports('projectPath', EDITOR);
      var fs = exports('fs', useNpm && globalThis.require('fs-extra'));
      var path = exports('path', useNpm && globalThis.require('path'));

      // export const shaderTemplatesDir = path.join(__dirname, '../../compile-shader/shader-templates');

      function getJsonObject(str) {
        var content;
        try {
          content = JSON.parse(str);
        } catch (err) {
          console.error(err);
        }
        return content;
      }
      function getFloatString(value) {
        if (typeof value !== 'number') {
          return value;
        }
        var str = value + '';
        if (!str.includes('.')) {
          str += '.';
        }
        return str;
      }
      var ValueElements = {
        vector: ['x', 'y', 'z', 'w'],
        color: ['r', 'g', 'b', 'a'],
        mat4: ['e00', 'e01', 'e02', 'e03']
      };
      function getValueElement(value, index) {
        if (typeof value === 'number') {
          return value;
        }
        var elements;
        if (value.x !== undefined) {
          elements = ValueElements.vector;
        } else if (value.r !== undefined) {
          elements = ValueElements.color;
        } else if (value.e00 !== undefined) {
          elements = ValueElements.mat4;
        }
        return value[elements[index]] || 0;
      }
      function getValueElementStr(value, index) {
        return getFloatString(getValueElement(value, index));
      }
      function getValueConcretePrecision(value) {
        var valueConretePresition = 1;
        if (typeof value === 'object') {
          if (value.w !== undefined || value.a !== undefined) {
            valueConretePresition = 4;
          } else if (value.z !== undefined || value.b !== undefined) {
            valueConretePresition = 3;
          } else if (value.y !== undefined || value.g !== undefined) {
            valueConretePresition = 2;
          } else if (value.m_SerializedTexture !== undefined) {
            valueConretePresition = TextureConcretePrecision.Texture2D;
          } else if (value.m_SerializedCubemap !== undefined) {
            valueConretePresition = TextureConcretePrecision.TextureCube;
          }
        }
        return valueConretePresition;
      }
      function getPrecisionName(precision, type) {
        var name = '';
        if (type === 'boolean') {
          name = 'bool';
        } else if (precision === 1) {
          name = 'float';
        } else if (precision === 2) {
          name = 'vec2';
        } else if (precision === 3) {
          name = 'vec3';
        } else if (precision === 4) {
          name = 'vec4';
        } else if (precision === TextureConcretePrecision.Texture2D) {
          name = 'sampler2D';
        } else if (precision === TextureConcretePrecision.TextureCube) {
          name = 'samplerCube';
        }
        return name;
      }
      function getEnumNames(type) {
        var names = Object.getOwnPropertyNames(type);
        names = names.filter(function (name) {
          return Number.isNaN(Number.parseFloat(name)) && name !== '_name';
        });
        return names;
      }
      function slot(display, defaultValue, type, connectType, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var data = {
          display: display,
          "default": defaultValue,
          type: type,
          connectType: connectType
        };
        Object.assign(data, opts);
        return data;
      }
      function prop(display, defaultValue, type, details) {
        if (details === void 0) {
          details = {};
        }
        var data = {
          display: display,
          "default": defaultValue,
          type: type
        };
        Object.assign(data, details);
        return data;
      }
      function getEnumDefineName(enumObj, value) {
        return ("CC_" + enumObj._name.replace('Space', '') + "_" + enumObj[value]).toUpperCase();
      }
      function getEnumDefine(enumObj, value) {
        var name = getEnumDefineName(enumObj, value);
        return "#define " + name + " 1";
      }
      function ensureEnumDefines(enumObj, define) {
        getEnumNames(enumObj).forEach(function (name) {
          var def = getEnumDefineName(enumObj, enumObj[name]);
          if (!define.includes(def)) {
            define += "#define " + def + " 0\n";
          }
        });
        return define;
      }
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/Utils2.ts", ['cc'], function (exports) {
  var cclegacy, _decorator;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "f17deAL74VOroYmPuGafWvU", "Utils", undefined);
      Number.prototype["clamp"] = function (min, max) {
        return Math.min(Math.max(this.valueOf(), min), max);
      };
      Number.prototype["pingPong"] = function (min, max) {
        var offset = max - min;
        // Use this.valueOf() to get the number value of 'this'
        var finalValue = (this.valueOf() - min) / offset;
        var beforeDot = Math.floor(finalValue);
        var afterDot = finalValue - beforeDot;
        var retVal = beforeDot % 2 === 0 ? min + offset * afterDot : max - offset * afterDot;
        return retVal;
      };
      Number.prototype["randomInt"] = function (min, max) {
        return Math.floor(Math.random() * (max - min) + min);
      };
      Array.prototype["shuffle"] = function () {
        for (var i = this.length - 1; i > 0; i--) {
          var j = Math.floor(Math.random() * (i + 1));
          var _ref = [this[j], this[i]];
          this[i] = _ref[0];
          this[j] = _ref[1];
        }
        return this;
      };
      Array.prototype["distinct"] = function () {
        return this.filter(function (thing, i, arr) {
          return arr.findIndex(function (t) {
            return t.id === thing.id;
          }) === i;
        });
      };
      Array.prototype["randomElement"] = function () {
        if (this.length <= 0) return null;
        return this[Math.floor(Math.random() * this.length)];
      };
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var Utils = exports('Utils', (_dec = ccclass("util"), _dec(_class = (_class2 = /*#__PURE__*/function () {
        function Utils() {}
        Utils.formatNumber = function formatNumber(num, noAbbDecimals, fixedValue) {
          if (noAbbDecimals === void 0) {
            noAbbDecimals = 0;
          }
          if (fixedValue === void 0) {
            fixedValue = 2;
          }
          if (!num) return '0';
          var abbreviations = ['', 'K', 'M', 'B', 'T', 'Qa', 'Qi', 'Sx', 'Sp', 'Oc', 'No', 'Dc', 'Ud', 'Dd', 'Td', 'Qua', 'Qui', 'Sx', 'Sp', 'Oc', 'No', 'Vi', 'Dv', 'Tv', 'Qaa', 'Qaq', 'Qap', 'Qaop', 'Qit']; // Add more as needed
          var index = 0;
          while (num >= 1000) {
            num /= 1000;
            index++;
            if (index >= abbreviations.length - 1) break;
          }
          if (index == 0) {
            return this.toFixed(num, noAbbDecimals);
          }
          var roundedNum = this.toFixed(num, fixedValue);
          return "" + roundedNum.replace(".", ",") + abbreviations[index];
          // return `${roundedNum.replace(/\B(?=(\d{3})+(?!\d))/g, ",")}${abbreviations[index]}`;
        };

        Utils.toFixed = function toFixed(input, decimalPlaces) {
          var fixedStr = input.toFixed(decimalPlaces);
          return fixedStr.replace(/(\.\d*?[1-9])0+$|\.0*$/, '$1');
        };
        Utils.commaNumber = function commaNumber(num) {
          if (!num) return '0';
          return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        };
        Utils.mapAbbreviationToWord = function mapAbbreviationToWord(abbreviation) {
          var abbreviationMap = {
            '': ' ',
            'K': 'Thousand',
            'M': 'Million',
            'B': 'Billion',
            'T': 'Trillion',
            'Qa': 'Quadrillion',
            'Qi': 'Quintillion',
            'Sx': 'Sextillion',
            'Sp': 'Septillion',
            'Oc': 'Octillion',
            'No': 'Nonillion',
            'Dc': 'Decillion',
            'Ud': 'Undecillion',
            'Dd': 'Duodecillion',
            'Td': 'Tredecillion',
            'Qua': 'Quattuordecillion',
            'Qui': 'Quindecillion',
            'Vi': 'Sexdecillion',
            'Dv': 'Septendecillion',
            'Tv': 'Octodecillion',
            'Qaa': 'Novemdecillion',
            'Qaq': 'Vigintillion',
            'Qap': 'Unvigintillion',
            'Qaop': 'Duovigintillion',
            'Qit': 'Tresvigintillion'
          };
          return abbreviationMap[abbreviation] || '';
        };
        Utils.getTokenParam = function getTokenParam() {
          return this.getUrlkeyValue("tk");
        };
        Utils.getRefreshTokenParam = function getRefreshTokenParam() {
          return this.getUrlkeyValue("rtk");
        };
        Utils.getDeviceKeyParam = function getDeviceKeyParam() {
          return this.getUrlkeyValue("dk");
        };
        Utils.getIdPasswordUrl = function getIdPasswordUrl() {
          return {
            username: this.getUrlkeyValue("username"),
            password: this.getUrlkeyValue("password")
          };
        };
        Utils.WaitFor = function WaitFor(condition, callback) {
          if (!condition()) {
            setTimeout(this.WaitFor.bind(null, condition, callback), 100); /* this checks the flag every 100 milliseconds*/
          } else {
            callback();
          }
        };
        Utils.loadScript = function loadScript(url, callback) {
          var script = document.createElement('script');
          script.type = 'text/javascript';
          script.src = url;
          if (callback) {
            // Execute the callback once the script has loaded
            script.onload = callback;
          }

          // Append the script tag to the document's <head> or <body>
          document.head.appendChild(script);
        };
        Utils.clone = function clone(sObj) {
          if (sObj === null || typeof sObj !== "object") {
            return sObj;
          }
          var s = {};
          if (sObj.constructor === Array) {
            s = [];
          }
          for (var i in sObj) {
            if (sObj.hasOwnProperty(i)) {
              s[i] = this.clone(sObj[i]);
            }
          }
          return s;
        }

        /**
         * @param { any} srcObj  
         * @returns 
         */;
        Utils.objectToArray = function objectToArray(srcObj) {
          var resultArr = [];

          // to array
          for (var _key in srcObj) {
            if (!srcObj.hasOwnProperty(_key)) {
              continue;
            }
            resultArr.push(srcObj[_key]);
          }
          return resultArr;
        }
        /**
         * 
         * @param { any} srcObj 
         * @param { string} objectKey 
         * @returns 
         */;
        Utils.arrayToObject = function arrayToObject(srcObj, objectKey) {
          var resultObj = {};

          // to object
          for (var key in srcObj) {
            if (!srcObj.hasOwnProperty(key) || !srcObj[key][objectKey]) {
              continue;
            }
            resultObj[srcObj[key][objectKey]] = srcObj[key];
          }
          return resultObj;
        }

        /**
         * @param {arrany} weightArr 
         * @param {number} totalWeight 
         * @returns 
         */;
        Utils.getWeightRandIndex = function getWeightRandIndex(weightArr, totalWeight) {
          var randWeight = Math.floor(Math.random() * totalWeight);
          var sum = 0;
          for (var weightIndex = 0; weightIndex < weightArr.length; weightIndex++) {
            sum += weightArr[weightIndex];
            if (randWeight < sum) {
              break;
            }
          }
          return weightIndex;
        }

        /**
         * @param {Number} n   
         * @param {Number} m    
         * @returns {Array}    
         */;
        Utils.getRandomNFromM = function getRandomNFromM(n, m) {
          var array = [];
          var intRd = 0;
          var count = 0;
          while (count < m) {
            if (count >= n + 1) {
              break;
            }
            intRd = this.getRandomInt(0, n);
            var flag = 0;
            for (var i = 0; i < count; i++) {
              if (array[i] === intRd) {
                flag = 1;
                break;
              }
            }
            if (flag === 0) {
              array[count] = intRd;
              count++;
            }
          }
          return array;
        }

        /**
         * @param {Number} min 
         * @param {Number} max 
         * @returns 
         */;
        Utils.getRandomInt = function getRandomInt(min, max) {
          var r = Math.random();
          var rr = r * (max - min + 1) + min;
          return Math.floor(rr);
        }

        /**
         * @param {string} render 
         * @returns 
         */;
        Utils.getStringLength = function getStringLength(render) {
          var strArr = render;
          var len = 0;
          for (var i = 0, n = strArr.length; i < n; i++) {
            var val = strArr.charCodeAt(i);
            if (val <= 255) {
              len = len + 1;
            } else {
              len = len + 2;
            }
          }
          return Math.ceil(len / 2);
        }

        /**
         * @param obj
         */;
        Utils.isEmptyObject = function isEmptyObject(obj) {
          var result = true;
          if (obj && obj.constructor === Object) {
            for (var key in obj) {
              if (obj.hasOwnProperty(key)) {
                result = false;
                break;
              }
            }
          } else {
            result = false;
          }
          return result;
        }

        /**
         * @param {Object|Number} dateValue 
         * @returns {boolean}
         */;
        Utils.isNewDay = function isNewDay(dateValue) {
          var oldDate = new Date(dateValue);
          var curDate = new Date();
          var oldYear = oldDate.getYear();
          var oldMonth = oldDate.getMonth();
          var oldDay = oldDate.getDate();
          var curYear = curDate.getYear();
          var curMonth = curDate.getMonth();
          var curDay = curDate.getDate();
          if (curYear > oldYear) {
            return true;
          } else {
            if (curMonth > oldMonth) {
              return true;
            } else {
              if (curDay > oldDay) {
                return true;
              }
            }
          }
          return false;
        }

        /**
         * @param {object}o 
         * @returns 
         */;
        Utils.getPropertyCount = function getPropertyCount(o) {
          var n,
            count = 0;
          for (n in o) {
            if (o.hasOwnProperty(n)) {
              count++;
            }
          }
          return count;
        }

        /**
         * @param array
         * @param diff
         */;
        Utils.difference = function difference(array, diff) {
          var result = [];
          if (array.constructor !== Array || diff.constructor !== Array) {
            return result;
          }
          var length = array.length;
          for (var i = 0; i < length; i++) {
            if (diff.indexOf(array[i]) === -1) {
              result.push(array[i]);
            }
          }
          return result;
        };
        Utils._stringToArray = function _stringToArray(string) {
          var rsAstralRange = "\\ud800-\\udfff";
          var rsZWJ = "\\u200d";
          var rsVarRange = "\\ufe0e\\ufe0f";
          var rsComboMarksRange = "\\u0300-\\u036f";
          var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
          var rsComboSymbolsRange = "\\u20d0-\\u20ff";
          var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
          var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
          var rsFitz = "\\ud83c[\\udffb-\\udfff]";
          var rsOptVar = '[' + rsVarRange + ']?';
          var rsCombo = '[' + rsComboRange + ']';
          var rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';
          var reOptMod = rsModifier + '?';
          var rsAstral = '[' + rsAstralRange + ']';
          var rsNonAstral = '[^' + rsAstralRange + ']';
          var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
          var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
          var rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';
          var rsSeq = rsOptVar + reOptMod + rsOptJoin;
          var rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
          var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
          var hasUnicode = function hasUnicode(val) {
            return reHasUnicode.test(val);
          };
          var unicodeToArray = function unicodeToArray(val) {
            return val.match(reUnicode) || [];
          };
          var asciiToArray = function asciiToArray(val) {
            return val.split('');
          };
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        };
        Utils.simulationUUID = function simulationUUID() {
          function s4() {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
          }
          return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
        };
        Utils.trim = function trim(str) {
          return str.replace(/(^\s*)|(\s*$)/g, "");
        }

        /**
         * @param {String|Number} start 
         * @param {String|Number} end 
         */;
        Utils.isNowValid = function isNowValid(start, end) {
          var startTime = new Date(start);
          var endTime = new Date(end);
          var result = false;
          if (startTime.getDate() + '' !== 'NaN' && endTime.getDate() + '' !== 'NaN') {
            var curDate = new Date();
            result = curDate < endTime && curDate > startTime;
          }
          return result;
        }

        /**
         * @param start 
         * @param end 
         * @returns 
         */;
        Utils.getDeltaDays = function getDeltaDays(start, end) {
          start = new Date(start);
          end = new Date(end);
          var startYear = start.getFullYear();
          var startMonth = start.getMonth() + 1;
          var startDate = start.getDate();
          var endYear = end.getFullYear();
          var endMonth = end.getMonth() + 1;
          var endDate = end.getDate();
          start = new Date(startYear + '/' + startMonth + '/' + startDate + ' GMT+0800').getTime();
          end = new Date(endYear + '/' + endMonth + '/' + endDate + ' GMT+0800').getTime();
          var deltaTime = end - start;
          return Math.floor(deltaTime / (24 * 60 * 60 * 1000));
        };
        Utils.getUserTimezone = function getUserTimezone() {
          var offset = new Date().getTimezoneOffset();
          var hours = Math.abs(offset / 60);
          var minutes = Math.abs(offset % 60);
          var sign = offset > 0 ? "-" : "+";
          return "GMT" + sign + String(hours) + String(minutes);
        }

        /**
         * @param array 
         * @returns 
         */;
        Utils.getMin = function getMin(array) {
          var result = null;
          if (array.constructor === Array) {
            var length = array.length;
            for (var i = 0; i < length; i++) {
              if (i === 0) {
                result = Number(array[0]);
              } else {
                result = result > Number(array[i]) ? Number(array[i]) : result;
              }
            }
          }
          return result;
        }

        /**
         * @param time 
         * @returns 
         */;
        Utils.formatTwoDigits = function formatTwoDigits(time) {
          //@ts-ignore
          return (Array(2).join(0) + time).slice(-2);
        };
        Utils.getRemainingTime = function getRemainingTime(startDate, endDate) {
          if (!endDate) {
            return {
              string: "",
              isZero: true,
              remainSeconds: 0
            };
          }
          var msPerSecond = 1000;
          var msPerMinute = msPerSecond * 60;
          var msPerHour = msPerMinute * 60;
          var msPerDay = msPerHour * 24;
          var diff = endDate.getTime() - startDate.getTime();
          var days = Math.floor(diff / msPerDay);
          var hours = Math.floor(diff % msPerDay / msPerHour);
          var minutes = Math.floor(diff % msPerHour / msPerMinute);
          var seconds = Math.floor(diff % msPerMinute / msPerSecond);
          var isZero = diff <= 0;
          var getString = function getString(number) {
            if (number < 10) return "0" + number;
            return number + "";
          };
          var retVal = "" + (days > 0 ? getString(days) + ":" : "") + getString(hours) + ":" + getString(minutes) + ":" + getString(seconds);
          if (days <= 0 && hours <= 0 && minutes <= 0 && seconds <= 10) {
            retVal = getString(seconds);
          }
          return {
            string: retVal,
            isZero: isZero,
            remainSeconds: diff / msPerSecond
          };
        }

        /**
         * @param date  
         * @param fmt 
         * @returns 
         */;
        Utils.formatDate = function formatDate(date, fmt) {
          var monthsFull = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
          var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          if (fmt.includes("MMMM")) {
            fmt = fmt.replace("MMMM", monthsFull[date.getMonth()]);
          } else if (fmt.includes("MMM")) {
            fmt = fmt.replace("MMM", monthsShort[date.getMonth()]);
          }
          var o = {
            "Y+": date.getFullYear(),
            "M+": date.getMonth() + 1,
            // Month as number
            "d+": date.getDate(),
            // Day of month
            "h+": date.getHours(),
            // Hour
            "m+": date.getMinutes(),
            // Minute
            "s+": date.getSeconds(),
            // Second
            "q+": Math.floor((date.getMonth() + 3) / 3),
            // Quarter
            "S": date.getMilliseconds() // Millisecond
          };

          if (/(y+)/.test(fmt)) {
            fmt = fmt.replace(RegExp.$1, (date.getFullYear() + "").substr(4 - RegExp.$1.length));
          }
          for (var k in o) {
            if (new RegExp("(" + k + ")").test(fmt)) {
              fmt = fmt.replace(RegExp.$1, RegExp.$1.length === 1 ? o[k].toString() : ("00" + o[k]).substr(("" + o[k]).length));
            }
          }
          return fmt;
        };
        Utils.getDay = function getDay() {
          var date = new Date();
          return date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate();
        }

        /**
         * @param {string} name  
         * @param {number}limit 
         * @returns {string} 
         */;
        Utils.formatName = function formatName(name, limit) {
          limit = limit || 6;
          var nameArray = this._stringToArray(name);
          var str = '';
          var length = nameArray.length;
          if (length > limit) {
            for (var i = 0; i < limit; i++) {
              str += nameArray[i];
            }
            str += '...';
          } else {
            str = name;
          }
          return str;
        }

        /**
         * @param {number}money 
         * @returns {string}
         */;
        Utils.formatMoney = function formatMoney(money) {
          var arrUnit = ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y', 'B', 'N', 'D'];
          var strValue = '';
          for (var idx = 0; idx < arrUnit.length; idx++) {
            if (money >= 10000) {
              money /= 1000;
            } else {
              strValue = Math.floor(money).toLocaleString() + arrUnit[idx];
              break;
            }
          }
          if (strValue === '') {
            strValue = Math.floor(money) + 'U';
          }
          return strValue.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }

        /**
         * @param {number}value 
         * @returns {string}
         */;
        Utils.formatValue = function formatValue(value) {
          var arrUnit = [];
          var strValue = '';
          for (var i = 0; i < 26; i++) {
            arrUnit.push(String.fromCharCode(97 + i));
          }
          for (var idx = 0; idx < arrUnit.length; idx++) {
            if (value >= 10000) {
              value /= 1000;
            } else {
              strValue = Math.floor(value) + arrUnit[idx];
              break;
            }
          }
          return strValue;
        }

        /**
         * @param {Number} leftSec 
         */;
        Utils.formatTimeForSecond = function formatTimeForSecond(leftSec, withoutSeconds) {
          if (withoutSeconds === void 0) {
            withoutSeconds = false;
          }
          var timeStr = '';
          var sec = leftSec % 60;
          var leftMin = Math.floor(leftSec / 60);
          leftMin = leftMin < 0 ? 0 : leftMin;
          var hour = Math.floor(leftMin / 60);
          var min = leftMin % 60;
          if (hour > 0) {
            timeStr += hour > 9 ? hour.toString() : '0' + hour;
            timeStr += ':';
          } else {
            timeStr += '00:';
          }
          timeStr += min > 9 ? min.toString() : '0' + min;
          if (!withoutSeconds) {
            timeStr += ':';
            timeStr += sec > 9 ? sec.toString() : '0' + sec;
          }
          return timeStr;
        }

        /**
         * @param {Number} ms
         */;
        Utils.formatTimeForMillisecond = function formatTimeForMillisecond(ms) {
          var second = Math.floor(ms / 1000 % 60);
          var minute = Math.floor(ms / 1000 / 60 % 60);
          var hour = Math.floor(ms / 1000 / 60 / 60);
          return {
            'hour': hour,
            'minute': minute,
            'second': second
          };
        }

        /**
         * @param {Array}arr  
         * @returns 
         */;
        Utils.rand = function rand(arr) {
          var arrClone = this.clone(arr);
          for (var i = arrClone.length - 1; i >= 0; i--) {
            var randomIndex = Math.floor(Math.random() * (i + 1));
            var itemIndex = arrClone[randomIndex];
            arrClone[randomIndex] = arrClone[i];
            arrClone[i] = itemIndex;
          }
          return arrClone;
        }

        /**
         * @static
         * @param {number} start
         * @param {number} end
         * @memberof Util
         */;
        Utils.getOffsetMimutes = function getOffsetMimutes(start, end) {
          var offSetTime = end - start;
          var minute = Math.floor(offSetTime % (1000 * 60 * 60) / (1000 * 60));
          return minute;
        }

        /**
         * @param {number} num 
         * @param {number} idx 
         */;
        Utils.formatNumToFixed = function formatNumToFixed(num, idx) {
          if (idx === void 0) {
            idx = 0;
          }
          return Number(num.toFixed(idx));
        }

        /**
         * @param {number} targetValue  
         * @param {number} curValue 
         * @param {number} ratio    
         * @returns 
         */;
        Utils.lerp = function lerp(targetValue, curValue, ratio) {
          if (ratio === void 0) {
            ratio = 0.25;
          }
          var v = curValue;
          if (targetValue > curValue) {
            v = curValue + (targetValue - curValue) * ratio;
          } else if (targetValue < curValue) {
            v = curValue - (curValue - targetValue) * ratio;
          }
          return v;
        }

        /**
         * @param {String} str 
         */;
        Utils.decrypt = function decrypt(b64Data) {
          var n = 6;
          if (b64Data.length % 2 === 0) {
            n = 7;
          }
          var decodeData = '';
          for (var idx = 0; idx < b64Data.length - n; idx += 2) {
            decodeData += b64Data[idx + 1];
            decodeData += b64Data[idx];
          }
          decodeData += b64Data.slice(b64Data.length - n + 1);
          decodeData = this._base64Decode(decodeData);
          return decodeData;
        }

        /**
        * @param {String} str 
        */;
        Utils.encrypt = function encrypt(str) {
          var b64Data = this._base64encode(str);
          var n = 6;
          if (b64Data.length % 2 === 0) {
            n = 7;
          }
          var encodeData = '';
          for (var idx = 0; idx < (b64Data.length - n + 1) / 2; idx++) {
            encodeData += b64Data[2 * idx + 1];
            encodeData += b64Data[2 * idx];
          }
          encodeData += b64Data.slice(b64Data.length - n + 1);
          return encodeData;
        }

        //public method for encoding
        /**
         * base64
         * @param {string}input 
         * @returns 
         */;
        Utils._base64encode = function _base64encode(input) {
          var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var output = "",
            chr1,
            chr2,
            chr3,
            enc1,
            enc2,
            enc3,
            enc4,
            i = 0;
          input = this._utf8Encode(input);
          while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = (chr1 & 3) << 4 | chr2 >> 4;
            enc3 = (chr2 & 15) << 2 | chr3 >> 6;
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
              enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
              enc4 = 64;
            }
            output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
          }
          return output;
        }

        /**
         * utf-8 
         * @param string 
         * @returns 
         */;
        Utils._utf8Encode = function _utf8Encode(string) {
          string = string.replace(/\r\n/g, "\n");
          var utftext = "";
          for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);
            if (c < 128) {
              utftext += String.fromCharCode(c);
            } else if (c > 127 && c < 2048) {
              utftext += String.fromCharCode(c >> 6 | 192);
              utftext += String.fromCharCode(c & 63 | 128);
            } else {
              utftext += String.fromCharCode(c >> 12 | 224);
              utftext += String.fromCharCode(c >> 6 & 63 | 128);
              utftext += String.fromCharCode(c & 63 | 128);
            }
          }
          return utftext;
        }

        /**
         * utf-8
         * @param utftext 
         * @returns 
         */;
        Utils._utf8Decode = function _utf8Decode(utftext) {
          var string = "";
          var i = 0;
          var c = 0;
          var c2 = 0;
          var c3 = 0;
          while (i < utftext.length) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
              string += String.fromCharCode(c);
              i++;
            } else if (c > 191 && c < 224) {
              c2 = utftext.charCodeAt(i + 1);
              string += String.fromCharCode((c & 31) << 6 | c2 & 63);
              i += 2;
            } else {
              c2 = utftext.charCodeAt(i + 1);
              c3 = utftext.charCodeAt(i + 2);
              string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
              i += 3;
            }
          }
          return string;
        }

        /**
         * @param {string}input 
         * @returns 
         */;
        Utils._base64Decode = function _base64Decode(input) {
          var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var output = "";
          var chr1;
          var chr2;
          var chr3;
          var enc1;
          var enc2;
          var enc3;
          var enc4;
          var i = 0;
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
          while (i < input.length) {
            enc1 = keyStr.indexOf(input.charAt(i++));
            enc2 = keyStr.indexOf(input.charAt(i++));
            enc3 = keyStr.indexOf(input.charAt(i++));
            enc4 = keyStr.indexOf(input.charAt(i++));
            chr1 = enc1 << 2 | enc2 >> 4;
            chr2 = (enc2 & 15) << 4 | enc3 >> 2;
            chr3 = (enc3 & 3) << 6 | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 != 64) {
              output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
              output = output + String.fromCharCode(chr3);
            }
          }
          output = this._utf8Decode(output);
          return output;
        };
        Utils.checkIsLowPhone = function checkIsLowPhone() {
          if (window["wx"]) {
            var nowBenchmarkLevel = -1; //nowBenchmarkLevel = -1
            var sys = window["wx"].getSystemInfoSync();
            var isIOS = sys.system.indexOf('iOS') >= 0;
            if (isIOS) {
              var model = sys.model;
              var ultraLowPhoneType = ['iPhone1,1', 'iPhone1,2', 'iPhone2,1', 'iPhone3,1', 'iPhone3,3', 'iPhone4,1', 'iPhone5,1', 'iPhone5,2', 'iPhone5,3', 'iPhone5,4', 'iPhone6,1', 'iPhone6,2'];
              var lowPhoneType = ['iPhone6,2', 'iPhone7,1', 'iPhone7,2', 'iPhone8,1', 'iPhone8,2', 'iPhone8,4'];
              var middlePhoneType = ['iPhone9,1', 'iPhone9,2', 'iPhone9,3', 'iPhone9,4', 'iPhone10,1', 'iPhone10,2', 'iPhone10,3', 'iPhone10,4', 'iPhone10,5', 'iPhone10,6'];
              var highPhoneType = ['iPhone11,2', 'iPhone11,4', 'iPhone11,6', 'iPhone11,8', 'iPhone12,1', 'iPhone12,3', 'iPhone12,5', 'iPhone12,8'];
              for (var i = 0; i < ultraLowPhoneType.length; i++) {
                if (model.indexOf(ultraLowPhoneType[i]) >= 0) nowBenchmarkLevel = 5;
              }
              for (var _i = 0; _i < lowPhoneType.length; _i++) {
                if (model.indexOf(lowPhoneType[_i]) >= 0) nowBenchmarkLevel = 10;
              }
              for (var _i2 = 0; _i2 < middlePhoneType.length; _i2++) {
                if (model.indexOf(middlePhoneType[_i2]) >= 0) nowBenchmarkLevel = 20;
              }
              for (var _i3 = 0; _i3 < highPhoneType.length; _i3++) {
                if (model.indexOf(highPhoneType[_i3]) >= 0) nowBenchmarkLevel = 30;
              }
            } else {
              nowBenchmarkLevel = sys.benchmarkLevel;
            }
            if (nowBenchmarkLevel < 22) {
              return true;
            } else {
              return false;
            }
          } else {
            return false;
          }
        };
        Utils.truncateString = function truncateString(str, maxLength, headLength, tailLength) {
          if (maxLength === void 0) {
            maxLength = 15;
          }
          if (headLength === void 0) {
            headLength = 5;
          }
          if (tailLength === void 0) {
            tailLength = 5;
          }
          // Check if the string needs to be truncated
          if (str.length <= maxLength) {
            return str; // No truncation needed
          }

          // Calculate lengths and truncate
          var head = str.slice(0, headLength);
          var tail = str.slice(-tailLength);

          // Return the truncated string
          return head + "..." + tail;
        };
        Utils.getVectorString = function getVectorString(input) {
          return input.x.toFixed(2) + "-" + input.y.toFixed(2);
        };
        Utils.getCoorKey = function getCoorKey(row, col) {
          return row + "_" + col;
        };
        return Utils;
      }(), _class2.getUrlkeyValue = function (key) {
        var urlStr = window.location.href;
        var url = new URL(urlStr);
        if (url.searchParams.has(key)) {
          var code = url.searchParams.get(key);
          return code;
        }
        return "";
      }, _class2.getAngle = function (input) {
        if (input < 0.0) return 360.0 + input % 360.0;
        if (input > 360.0) return input % 360.0;
        return input;
      }, _class2.getPointText = function (point, bonus) {
        if (bonus <= 0) return point + "";
        return point + "(<color=green>" + bonus + "</color>)";
      }, _class2.getGuildShortName = function (guildName) {
        var splited = guildName.split(" ");
        var retVal = "";
        splited.forEach(function (str) {
          return retVal += str[0];
        });
        return retVal.toUpperCase();
      }, _class2.capitalizeWords = function (input) {
        // Convert the input string to lowercase and then capitalize the first character of each word
        return input.toLowerCase().replace(/\b\w/g, function (_char) {
          return _char.toUpperCase();
        });
      }, _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/uv.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './base.ts', './type.ts', './utils.ts', './index3.ts', './register.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec2, ShaderNode, ConcretePrecisionType, prop, slot, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec2 = module.Vec2;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      prop = module.prop;
      slot = module.slot;
    }, null, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "95b7bSNki1Ba5Pk4AQXXcG5", "uv", undefined);
      var UVNode = exports('default', (_dec = register({
        menu: 'Input/Geometry/UV',
        title: 'UV'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(UVNode, _ShaderNode);
        function UVNode() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.fixedConcretePrecision = 2;
          _this.data = {
            props: [prop('Channel', 0, 'float')],
            outputs: [slot('UV', new Vec2(), 'vec2', 'vector')]
          };
          return _this;
        }
        var _proto = UVNode.prototype;
        _proto.generateCode = function generateCode() {
          var prop = this.getPropWithName('Channel');
          if (!prop) {
            console.warn('UV Node generate code undefined');
            return '';
          }
          var uvName = "v_uv" + (prop.value > 0 ? prop.value : '');
          return this.getOutputVarDefine(0) + " = " + uvName + ";";
        };
        return UVNode;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/vector2.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec2, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec2 = module.Vec2;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "7f058nmp+ZIQ6FPIyLJ3wpK", "vector2", undefined);
      var Vector2 = exports('default', (_dec = register({
        menu: 'Input/Basic/Vector2',
        title: 'Vector2'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Vector2, _ShaderNode);
        function Vector2() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.data = {
            inputs: [slot('X', 0, 'float', 'vector'), slot('Y', 0, 'float', 'vector')],
            outputs: [slot('Out', Vec2.ZERO, 'vec2', 'vector')]
          };
          return _this;
        }
        var _proto = Vector2.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = vec2(" + input0 + ", " + input1 + ");\n        ";
        };
        return Vector2;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/vector3.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec3, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec3 = module.Vec3;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "99486WpmApIPoULZGXK9dCS", "vector3", undefined);
      var Vector3 = exports('default', (_dec = register({
        menu: 'Input/Basic/Vector3',
        title: 'Vector3'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Vector3, _ShaderNode);
        function Vector3() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.data = {
            inputs: [slot('X', 0, 'float', 'vector'), slot('Y', 0, 'float', 'vector'), slot('Z', 0, 'float', 'vector')],
            outputs: [slot('Out', Vec3.ZERO, 'vec3', 'vector')]
          };
          return _this;
        }
        var _proto = Vector3.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var input2 = this.getInputValue(2);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = vec3(" + input0 + ", " + input1 + ", " + input2 + ");\n        ";
        };
        return Vector3;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/vector4.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './register.ts', './base.ts', './type.ts', './utils.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, register, ShaderNode, ConcretePrecisionType, slot;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      register = module.register;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "4e4e9VghSdMAohxS4AJDF0m", "vector4", undefined);
      var Vector4 = exports('default', (_dec = register({
        menu: 'Input/Basic/Vector4',
        title: 'Vector4'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(Vector4, _ShaderNode);
        function Vector4() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.data = {
            inputs: [slot('X', 0, 'float', 'vector'), slot('Y', 0, 'float', 'vector'), slot('Z', 0, 'float', 'vector'), slot('W', 0, 'float', 'vector')],
            outputs: [slot('Out', Vec4.ZERO, 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = Vector4.prototype;
        _proto.calcConcretePrecision = function calcConcretePrecision() {
          _ShaderNode.prototype.calcConcretePrecision.call(this);
        };
        _proto.generateCode = function generateCode() {
          var input0 = this.getInputValue(0);
          var input1 = this.getInputValue(1);
          var input2 = this.getInputValue(2);
          var input3 = this.getInputValue(3);
          var output0 = this.getOutputVarDefine(0);
          return "\n            " + output0 + " = vec4(" + input0 + ", " + input1 + ", " + input2 + ", " + input3 + ");\n        ";
        };
        return Vector4;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/VectorUtil.ts", ['cc'], function (exports) {
  var cclegacy, Vec3;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Vec3 = module.Vec3;
    }],
    execute: function () {
      cclegacy._RF.push({}, "59f54A7NwlOiY/boc9L5zON", "VectorUtil", undefined);
      var rad2Deg = 180 / Math.PI;
      var tempVec3 = new Vec3();
      var VectorUtil = exports('VectorUtil', /*#__PURE__*/function () {
        function VectorUtil() {}
        VectorUtil.projectOnPlane = function projectOnPlane(vector, planeNormal) {
          var projectionLength = Vec3.dot(vector, planeNormal);
          var vectorOnPlane = tempVec3.set(planeNormal).multiplyScalar(projectionLength);
          return Vec3.subtract(new Vec3(), vector, vectorOnPlane);
        };
        VectorUtil.signedAngle = function signedAngle(a, b, axis) {
          var aOnAxisPlane = VectorUtil.projectOnPlane(a, axis);
          var bOnAxisPlane = VectorUtil.projectOnPlane(b, axis);
          var aNormalized = aOnAxisPlane.normalize();
          var bNormalized = bOnAxisPlane.normalize();
          var abNormal = Vec3.cross(new Vec3(), aNormalized, bNormalized).normalize();
          var sign = Vec3.dot(abNormal, axis);
          var radian = Math.acos(Vec3.dot(aNormalized, bNormalized));
          return radian * sign * rad2Deg;
        };
        return VectorUtil;
      }());
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/vertex-color.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './base.ts', './type.ts', './utils.ts', './index3.ts', './register.ts'], function (exports) {
  var _inheritsLoose, cclegacy, Vec4, ShaderNode, ConcretePrecisionType, slot, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec4 = module.Vec4;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      slot = module.slot;
    }, null, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "57f73xnQclNJoH/LZDbCo8N", "vertex-color", undefined);
      var VertexColorNode = exports('default', (_dec = register({
        menu: 'Input/Geometry/VertexColor',
        title: 'VertexColor'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(VertexColorNode, _ShaderNode);
        function VertexColorNode() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.fixedConcretePrecision = 4;
          _this.data = {
            outputs: [slot('Out', new Vec4(), 'vec4', 'vector')]
          };
          return _this;
        }
        var _proto = VertexColorNode.prototype;
        _proto.generateCode = function generateCode() {
          return this.getOutputVarDefine(0) + " = FSInput_vertexColor;";
        };
        return VertexColorNode;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/view-direction.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './base.ts', './type.ts', './utils.ts', './index3.ts', './register.ts'], function (exports) {
  var _inheritsLoose, _createClass, cclegacy, Vec3, ShaderNode, ViewDirSpace, ConcretePrecisionType, getEnumDefine, prop, slot, register;
  return {
    setters: [function (module) {
      _inheritsLoose = module.inheritsLoose;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      Vec3 = module.Vec3;
    }, function (module) {
      ShaderNode = module.ShaderNode;
    }, function (module) {
      ViewDirSpace = module.ViewDirSpace;
      ConcretePrecisionType = module.ConcretePrecisionType;
    }, function (module) {
      getEnumDefine = module.getEnumDefine;
      prop = module.prop;
      slot = module.slot;
    }, null, function (module) {
      register = module.register;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "fbe73AP6NxBTqOrL07ng2zD", "view-direction", undefined);
      var ViewDirection = exports('default', (_dec = register({
        menu: 'Input/Geometry/ViewDirection',
        title: 'ViewDirection'
      }), _dec(_class = /*#__PURE__*/function (_ShaderNode) {
        _inheritsLoose(ViewDirection, _ShaderNode);
        function ViewDirection() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _ShaderNode.call.apply(_ShaderNode, [this].concat(args)) || this;
          _this.concretePrecisionType = ConcretePrecisionType.Fixed;
          _this.fixedConcretePrecision = 3;
          _this.data = {
            props: [prop('Space', ViewDirSpace.World, 'enum', {
              "enum": ViewDirSpace
            })],
            outputs: [slot('ViewDirection', new Vec3(), 'vec3', 'vector')]
          };
          return _this;
        }
        var _proto = ViewDirection.prototype;
        _proto.generateCode = function generateCode() {
          var space = this.getPropWithName('Space');
          var name = 'view';
          if (space.value === ViewDirSpace.Local) {
            name = 'view';
          } else if (space.value === ViewDirSpace.View) {
            name = 'viewView';
          }
          // else if (space.value === ViewDirSpace.Tangent) {
          //     // name = 'tangentView';
          //     name = 'worldView';
          // }
          else if (space.value === ViewDirSpace.World) {
            name = 'worldView';
          }
          this.defines = [getEnumDefine(ViewDirSpace, space.value)];
          return this.getOutputVarDefine(0) + " = " + name + ";";
        };
        _createClass(ViewDirection, [{
          key: "type",
          get: function get() {
            return 'ViewDirection';
          }
        }]);
        return ViewDirection;
      }(ShaderNode)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/View.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './debug.ts', './enum.ts', './helper.ts', './LayoutManager.ts', './ViewManager.ts'], function (exports) {
  var _createClass, cclegacy, _decorator, DEBUG_DRAW_LIND_WIDTH, WrapMode, Helper, LayoutManager, ViewManager;
  return {
    setters: [function (module) {
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
    }, function (module) {
      DEBUG_DRAW_LIND_WIDTH = module.DEBUG_DRAW_LIND_WIDTH;
    }, function (module) {
      WrapMode = module.WrapMode;
    }, function (module) {
      Helper = module.Helper;
    }, function (module) {
      LayoutManager = module.LayoutManager;
    }, function (module) {
      ViewManager = module.ViewManager;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "2de05BThzdKpKfaXzu3wLES", "View", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var View = exports('View', (_dec = ccclass('View'), _dec(_class = /*#__PURE__*/function () {
        function View(adapter) {
          this.__debug_graphics = void 0;
          this._adapter = void 0;
          this._total = 0;
          this._innerSize = 0;
          this._group = null;
          this._holderList = [];
          this._tempHolderList = [];
          this._isOverflowFixed = void 0;
          this._adapter = adapter;
          this.internal_reset();
          this.__createDebug();
        }
        var _proto = View.prototype;
        _proto.__createDebug = function __createDebug() {};
        _proto.__drawDebug = function __drawDebug() {
          if (!this.__debug_graphics || !this.group) return;
          this.__debug_graphics.clear();
          // if (this.index != 0) return
          var mainAxis = this.adapter.mainAxis;
          var crossAxis = this.adapter.crossAxis;
          var position = {
            x: 0,
            y: 0
          };
          var size = {
            x: this.group.size.x,
            y: this.group.size.y
          };
          var anchor = {
            x: this.group.anchorPoint.x,
            y: this.group.anchorPoint.y
          };
          position[mainAxis] = this.group.position[mainAxis] - size[mainAxis] * anchor[mainAxis];
          position[mainAxis] += DEBUG_DRAW_LIND_WIDTH * 0.5;
          position[crossAxis] = this.group.position[crossAxis] - size[crossAxis] * (1 - anchor[crossAxis]);
          position[crossAxis] += DEBUG_DRAW_LIND_WIDTH * 0.5;
          size[mainAxis] -= DEBUG_DRAW_LIND_WIDTH;
          size[crossAxis] -= DEBUG_DRAW_LIND_WIDTH;
          this.__debug_graphics.roundRect(position.x, position.y, size.x, size.y, 2);
          this.__debug_graphics.stroke();
        };
        _proto.getFixedHolders = function getFixedHolders() {
          if (!this.group.isFixed) return [];
          var list = [];
          var length = this.holderList.length;
          for (var i = 0; i < length; i++) {
            var _holder = this.holderList[i];
            if (_holder.model.element.fixed) {
              list.push(_holder);
            }
          }
          return list;
        }

        /** @deprecated  */;
        _proto.internal_isWrap = function internal_isWrap(model, group) {
          var wrap = false;
          var prev = group && group.models[group.models.length - 1];
          if (prev) {
            //view 
            switch (model.element.wrapBeforeMode) {
              case WrapMode.Wrap:
                wrap = true;
                break;
              case WrapMode.Nowrap:
                // 
                wrap = prev.element.wrapAfterMode == WrapMode.Wrap;
                break;
              case WrapMode.Auto:
                wrap = prev.element.wrapAfterMode == WrapMode.Wrap;
                if (!wrap) {
                  //
                  wrap = this._calculateInnerSize(model, group);
                }
                break;
            }
          }
          return wrap;
        }
        /** @deprecated  */;
        _proto.internal_reset = function internal_reset() {
          this._group = null;
          this._innerSize = 0;
          this._total = 0;
          this._holderList.length = 0;
          this._isOverflowFixed = true;
          this._tempHolderList.length = 0;
          if (this.__debug_graphics) {
            this.__debug_graphics.clear();
          }
        }
        /** @deprecated  */;
        _proto.internal_push = function internal_push(model) {
          this._total++;
          var crossAxis = this.adapter.crossAxis;
          if (!model.element.ignoreLayout || model.element.ignoreLayout && model.element.placeholder) {
            if (this._innerSize != 0) {
              this._innerSize += this.adapter.layoutManager.spacing;
            }
            this._innerSize += model.size[crossAxis];
          }
        }

        /** @deprecated  */;
        _proto.internal_recycleHolders = function internal_recycleHolders(done) {
          for (var i = 0; i < this._holderList.length; i++) {
            var _holder2 = this._holderList[i];
            _holder2.internal_disable();
            done(_holder2);
          }
          this._holderList.length = 0;
        }
        /** @deprecated  */;
        _proto.internal_preVisible = function internal_preVisible(group, findHolder) {
          this._group = group;
          this._createHolders(findHolder);
          return this;
        }
        /** @deprecated  */;
        _proto.internal_visible = function internal_visible() {
          this.register();
          for (var i = 0; i < this._tempHolderList.length; i++) {
            var _this$_tempHolderList = this._tempHolderList[i],
              _holder3 = _this$_tempHolderList.holder,
              _model = _this$_tempHolderList.model,
              isNew = _this$_tempHolderList.isNew;
            _holder3.internal_visible(this, _model, isNew);
          }
          this._tempHolderList.length = 0;
          this.adapter.layoutManager.layout(this.group);
          this.onVisible();
        }
        /** @deprecated  */;
        _proto.internal_disable = function internal_disable() {
          this.adapter.layoutManager.unLayout(this.index);
          this.unregister();
          this.onDisable();
          this.internal_reset();
        }
        /** @deprecated  */;
        _proto.internal_holderChanged = function internal_holderChanged(isMainAxisEqual) {
          var layoutSelf = true;
          var mainAxis = this.adapter.mainAxis;
          var oldMainAxisSize = this.group.size[mainAxis];
          if (!isMainAxisEqual) {
            var size = 0;
            for (var i = 0; i < this.group.models.length; i++) {
              var _model2 = this.group.models[i];
              var mainAxisSize = _model2.size[mainAxis];
              if (this.adapter.isVertical && this.adapter.layoutManager.controlScaleHeight || this.adapter.isHorizontal && this.adapter.layoutManager.controlScaleWidth) {
                mainAxisSize *= _model2.scale[mainAxis];
              }
              size = Math.max(size, mainAxisSize);
            }
            if (!Helper.approximately(this.group.size[mainAxis], size)) {
              this.group.oldSize[mainAxis] = this.group.size[mainAxis];
              this.group.size[mainAxis] = size;
              layoutSelf = false;
            }
          }
          if (layoutSelf) {
            //   
            this.adapter.layoutManager.layout(this.group);
          } else {
            //  viewManagerview
            this.adapter.viewManager.internal_viewChanged(this, oldMainAxisSize);
          }
        };
        _proto.register = function register() {
          this.adapter.viewManager.on(ViewManager.Event.ON_SCROLL, this._onScroll, this);
          this.adapter.viewManager.on(ViewManager.Event.ON_LATEUPDATE, this._onLateUpdate, this);
          this.adapter.layoutManager.on(LayoutManager.Event.ON_LAYOUT_COMPLATED, this._onLayoutComplated, this);
          this.adapter.layoutManager.on(LayoutManager.Event.ON_CHANGED_LAYOUT_STATE, this._onChangedLayoutState, this);
        };
        _proto.unregister = function unregister() {
          this.adapter.viewManager.off(ViewManager.Event.ON_SCROLL, this._onScroll, this);
          this.adapter.viewManager.off(ViewManager.Event.ON_LATEUPDATE, this._onLateUpdate, this);
          this.adapter.layoutManager.off(LayoutManager.Event.ON_LAYOUT_COMPLATED, this._onLayoutComplated, this);
          this.adapter.layoutManager.off(LayoutManager.Event.ON_CHANGED_LAYOUT_STATE, this._onChangedLayoutState, this);
        };
        _proto._createHolders = function _createHolders(findHolder) {
          var mainAxis = this.adapter.mainAxis;
          this._tempHolderList.length = 0;
          for (var i = 0; i < this.group.models.length; i++) {
            var _model3 = this.group.models[i];
            var isNew = false;
            var holder = findHolder && findHolder(_model3);
            if (!holder) {
              holder = this.adapter.viewManager.internal_getHolder(_model3);
              isNew = true;
            }
            // position=0 
            _model3.position[mainAxis] = this.group.position[mainAxis];
            this._holderList.push(holder);
            this._tempHolderList.push({
              holder: holder,
              model: _model3,
              isNew: isNew
            });
          }
        };
        _proto._calculateInnerSize = function _calculateInnerSize(model, group) {
          if (this._total == 0) return false;
          var size = model.size[this.adapter.crossAxis];
          return this._innerSize + size + this.adapter.layoutManager.spacing > group.size[this.adapter.crossAxis];
        };
        _proto._onLayoutComplated = function _onLayoutComplated(complatedIndexs) {
          if (complatedIndexs.indexOf(this.index) != -1) {
            for (var i = 0; i < this.holderList.length; i++) {
              var _holder4 = this.holderList[i];
              _holder4.internal_layout();
            }
            if (this.group.isFixed) {
              this._calcFixedPosition();
            }
          }
        };
        _proto._calcFixedPosition = function _calcFixedPosition() {
          var length = this._holderList.length;
          var mainAxis = this.adapter.mainAxis;
          for (var i = 0; i < length; i++) {
            var _holder5 = this._holderList[i];
            if (!_holder5.element.fixed) continue;
            var position = {
              x: _holder5.model.position.x,
              y: _holder5.model.position.y
            };
            var relativeOffset = 0;
            var boundary = this._getModelBoundary(_holder5.model);
            if (this._isNeedFixed(boundary)) {
              position[mainAxis] -= boundary;
              var holderList = this.adapter.viewManager.getNextFixedHolders(this.index);
              relativeOffset = this._getRelativeNextHolderOffset(_holder5, holderList);
            }
            position[mainAxis] += relativeOffset * this.adapter.multiplier;
            if (position[mainAxis] != _holder5.node.position[mainAxis]) {
              _holder5.node.setPosition(position.x, position.y);
            }
          }
        }
        /**   */;
        _proto._onChangedLayoutState = function _onChangedLayoutState() {
          this.adapter.layoutManager.layout(this.group);
        };
        _proto._onScroll = function _onScroll() {
          if (!this.group.isFixed || this._holderList.length == 0) return;
          this._calcFixedPosition();
        };
        _proto._onLateUpdate = function _onLateUpdate(deltaTime) {};
        _proto._isNeedFixed = function _isNeedFixed(boundary) {
          return this.adapter.multiplier == 1 ? boundary >= 0 : boundary <= 0;
        };
        _proto._getModelBoundary = function _getModelBoundary(model) {
          var fixedOffset = Helper.isNumber(model.element.fixedOffset) ? model.element.fixedOffset : 0;
          return this.adapter.multiplier == 1 ? this._getModelHeaderBoundary(model) + fixedOffset : this._getModelFooterBoundary(model) - fixedOffset;
        };
        _proto._getModelHeaderBoundary = function _getModelHeaderBoundary(model) {
          var mainAxis = this.adapter.mainAxis;
          return model.position[mainAxis] + model.size[mainAxis] * (1 - model.anchorPoint[mainAxis]) * model.scale[mainAxis] + this.adapter.scrollManager.contentPosition;
        };
        _proto._getModelFooterBoundary = function _getModelFooterBoundary(model) {
          var mainAxis = this.adapter.mainAxis;
          return model.position[mainAxis] - model.size[mainAxis] * model.anchorPoint[mainAxis] * model.scale[mainAxis] + this.adapter.scrollManager.contentPosition;
        };
        _proto._getModelSizeWithSpacing = function _getModelSizeWithSpacing(model) {
          var mainAxis = this.adapter.mainAxis;
          var fixedOffset = Helper.isNumber(model.element.fixedOffset) ? model.element.fixedOffset : 0;
          var spacing = Helper.isNumber(model.element.fixedSpacing) ? model.element.fixedSpacing : this.adapter.viewManager.spacing;
          return model.size[mainAxis] * model.scale[mainAxis] + fixedOffset + spacing;
        };
        _proto._getReatureRelativeBoundary = function _getReatureRelativeBoundary(model, offset) {
          var boundary = this.adapter.multiplier == 1 ? this._getModelHeaderBoundary(model) : this._getModelFooterBoundary(model);
          var value = this.adapter.multiplier == 1 ? boundary + offset : offset - boundary;
          return Math.min(value, offset);
        };
        _proto._getRelativeNextHolderOffset = function _getRelativeNextHolderOffset(currentHolder, holderList) {
          var length = holderList.length;
          var crossAxis = this.adapter.crossAxis;
          var sizeSpacing = this._getModelSizeWithSpacing(currentHolder.model);
          var relativeOffset = 0;
          for (var i = 0; i < length; i++) {
            var _holder6 = holderList[i];
            var offset = this._getReatureRelativeBoundary(_holder6.model, sizeSpacing);
            var sameScale = currentHolder.model.scale[crossAxis] == _holder6.model.scale[crossAxis];
            var sameSize = currentHolder.model.size[crossAxis] == _holder6.model.size[crossAxis];
            if (currentHolder.fixedIndex == _holder6.fixedIndex && sameScale && sameSize) {
              relativeOffset = offset > 0 ? offset : 0;
              break;
            }
            if (offset > 0) {
              relativeOffset = Math.max(relativeOffset, offset);
            }
          }
          return relativeOffset;
        };
        _createClass(View, [{
          key: "isOverflowFixed",
          get: function get() {
            return this._isOverflowFixed;
          }
        }, {
          key: "adapter",
          get: function get() {
            return this._adapter;
          }
        }, {
          key: "group",
          get: function get() {
            return this._group;
          }
        }, {
          key: "holderList",
          get: function get() {
            return this._holderList;
          }
        }, {
          key: "index",
          get: function get() {
            if (!this.group) return -1;
            return this.group.index;
          }
        }]);
        return View;
      }()) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ViewManager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './Group.ts', './Manager.ts', './View.ts', './enum.ts', './helper.ts', './ModelManager.ts', './ScrollManager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, _createClass, cclegacy, _decorator, instantiate, Group, Manager, View, ArrangeAxis, StretchDirection, MagneticDirection, ScrollDirection, Helper, ModelManager, ScrollManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
      _createClass = module.createClass;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      instantiate = module.instantiate;
    }, function (module) {
      Group = module.Group;
    }, function (module) {
      Manager = module.Manager;
    }, function (module) {
      View = module.View;
    }, function (module) {
      ArrangeAxis = module.ArrangeAxis;
      StretchDirection = module.StretchDirection;
      MagneticDirection = module.MagneticDirection;
      ScrollDirection = module.ScrollDirection;
    }, function (module) {
      Helper = module.Helper;
    }, function (module) {
      ModelManager = module.ModelManager;
    }, function (module) {
      ScrollManager = module.ScrollManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _class3;
      cclegacy._RF.push({}, "f2204qKI49MuZnaH/naH4DF", "ViewManager", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var Event = /*#__PURE__*/function (Event) {
        Event[Event["ON_SCROLL"] = 0] = "ON_SCROLL";
        Event[Event["ON_LATEUPDATE"] = 1] = "ON_LATEUPDATE";
        Event[Event["ON_CLEARVIEWS"] = 2] = "ON_CLEARVIEWS";
        Event[Event["ON_UPDATE_VIEWS"] = 3] = "ON_UPDATE_VIEWS";
        Event[Event["ON_CHANGED_VIRTUALSIZE"] = 4] = "ON_CHANGED_VIRTUALSIZE";
        Event[Event["ON_MAGNETIC"] = 5] = "ON_MAGNETIC";
        Event[Event["ON_CHANGED_OVERFLOWHEADER"] = 6] = "ON_CHANGED_OVERFLOWHEADER";
        Event[Event["ON_RESET_ALL_STATE"] = 7] = "ON_RESET_ALL_STATE";
        Event[Event["ON_CHANGED_SPACING"] = 8] = "ON_CHANGED_SPACING";
        return Event;
      }(Event || {});
      var ViewManager = exports('ViewManager', (_dec = ccclass('ViewManager'), _dec2 = property({
        type: ArrangeAxis
      }), _dec3 = property({
        type: ArrangeAxis,
        tooltip: "\u4E3B\u8F74\u65B9\u5411\u7684\u6392\u5217\u65B9\u5F0F\n        Start: \u4ECE\u4E0A\u5230\u4E0B\u3001\u4ECE\u5DE6\u5230\u53F3\n        End: \u4ECE\u4E0B\u5230\u4E0A\u3001\u4ECE\u53F3\u5230\u5DE6"
      }), _dec4 = property({
        type: StretchDirection,
        tooltip: "\u5F53\u5143\u7D20\u7684\u5C3A\u5BF8\u3001\u7F29\u653E\u6539\u53D8\u65F6\uFF0C\u53D7\u5F71\u54CD\u7684\u5176\u4ED6\u5143\u7D20\u5E94\u8BE5\u5982\u4F55\u8BA1\u7B97\u65B0\u7684\u4F4D\u7F6E\n        Auto: \u4EE5\u53EF\u89C6\u533A\u57DF\u4E2D\u5FC3\u4E3A\u8D77\u70B9\uFF0C\u6240\u6709\u5176\u4ED6\u5143\u7D20\u5411\u4E24\u8FB9\u5EF6\u4F38\n        Center: \u4EE5\u5F53\u524D\u53D8\u5316\u7684\u5143\u7D20\u4E3A\u8D77\u70B9\uFF0C\u6240\u6709\u5176\u4ED6\u5143\u7D20\u5411\u4E24\u8FB9\u5EF6\u4F38\n        Header: \u4EE5\u5F53\u524D\u53D8\u5316\u7684\u5143\u7D20\u548C\u5B83\u5934\u90E8\u7684\u6240\u6709\u5143\u7D20\u5411\u5934\u90E8\u5EF6\u4F38\n        Footer: \u4EE5\u5F53\u524D\u53D8\u5316\u7684\u5143\u7D20\u548C\u5B83\u5C3E\u90E8\u7684\u6240\u6709\u5143\u7D20\u5411\u5C3E\u90E8\u5EF6\u4F38"
      }), _dec5 = property({
        range: [0, 1],
        slide: true,
        step: 0.01,
        tooltip: "\u5F53\u5143\u7D20\u79FB\u52A8\u5230\u53EF\u89C6\u533A\u57DF\u5916\u504F\u79FB\u591A\u5C11\u65F6\u624D\u8FDB\u884C\u56DE\u6536\n        \u6BD4\u5982\u5143\u7D20\u7684\u5C3A\u5BF8\u4E3A100\uFF0C\u5F53\u5143\u7D20\u8D85\u51FA\u53EF\u89C6\u8303\u56F4 100+100*0.3 \u65F6\u5C31\u4F1A\u88AB\u56DE\u6536\n        \u6CA1\u6709\u7279\u6B8A\u9700\u6C42\u65F6\uFF0C\u9ED8\u8BA4\u503C\u5373\u53EF"
      }), _dec6 = property({
        range: [0, 1],
        slide: true,
        step: 0.01,
        tooltip: "\u6B64\u503C\u4F1A\u5F71\u54CD\u586B\u5145\u5143\u7D20\u7684\u65F6\u673A\n        \u6CA1\u6709\u7279\u6B8A\u9700\u6C42\u65F6\uFF0C\u9ED8\u8BA4\u503C\u5373\u53EF"
      }), _dec7 = property({
        tooltip: ""
      }), _dec8 = property({
        group: {
          id: "padding",
          name: "padding"
        }
      }), _dec9 = property({
        group: {
          id: "padding",
          name: "padding"
        }
      }), _dec10 = property({
        group: {
          id: "padding",
          name: "padding"
        }
      }), _dec11 = property({
        group: {
          id: "padding",
          name: "padding"
        }
      }), _dec12 = property({
        tooltip: "\u78C1\u6027\u505C\u9760\n        \u5F00\u542F\u540E\uFF0C\u4F1A\u5728\u589E\u52A0\u6570\u636E\u65F6\uFF0C\u6839\u636E\u8BBE\u7F6E\u8FDB\u884C\u81EA\u52A8\u6EDA\u52A8\u5230\u9876\u90E8\u6216\u5E95\u90E8"
      }), _dec13 = property({
        type: MagneticDirection,
        visible: function visible() {
          return this.magnetic;
        },
        tooltip: "\u505C\u9760\u7684\u65B9\u5411"
      }), _dec14 = property({
        visible: function visible() {
          return this.magnetic;
        },
        tooltip: ""
      }), _dec15 = property({
        visible: function visible() {
          return this.magnetic;
        },
        tooltip: "\u9ED8\u8BA4\u60C5\u51B5\u4E0B\uFF0C\u4EC5\u5F53\u6DFB\u52A0\u6570\u636E\u65F6\u624D\u4F1A\u89E6\u53D1\u505C\u9760\n        \u5F53\u5F00\u542F\u65F6\uFF0C\u5143\u7D20\u7684\u5C3A\u5BF8\u6539\u53D8\u65F6,\u4E5F\u4F1A\u5426\u89E6\u53D1\u505C\u9760"
      }), _dec16 = property({
        tooltip: ""
      }), _dec17 = property({
        tooltip: ""
      }), _dec(_class = (_class2 = (_class3 = /*#__PURE__*/function (_Manager) {
        _inheritsLoose(ViewManager, _Manager);
        function ViewManager() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Manager.call.apply(_Manager, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "_arrangeAxis", _descriptor, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "stretchDirection", _descriptor2, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "overflowOffset", _descriptor3, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "enterOffset", _descriptor4, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "_spacing", _descriptor5, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "left", _descriptor6, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "right", _descriptor7, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "top", _descriptor8, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "bottom", _descriptor9, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "magnetic", _descriptor10, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "magneticDirection", _descriptor11, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "magneticDuration", _descriptor12, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "magneticSizeChanges", _descriptor13, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "loopHeader", _descriptor14, _assertThisInitialized(_this));
          _initializerDefineProperty(_this, "loopFooter", _descriptor15, _assertThisInitialized(_this));
          _this._groupLength = 0;
          _this._cacheGroups = [];
          _this._groups = [];
          _this._disableViews = [];
          _this._visibleViews = [];
          _this._fixedViews = [];
          _this._disableHolders = [];
          _this._isFill = false;
          _this._headerIndex = -1;
          _this._footerIndex = -1;
          _this._virtualSize = 0;
          _this._overflowHeader = 0;
          _this._cacheHeadeDatas = [];
          _this._cacheHeadePosition = void 0;
          return _this;
        }
        var _proto = ViewManager.prototype;
        _proto.onInit = function onInit() {
          this.adapter.modelManager.on(ModelManager.Event.ON_CHANGE_BEFORE, this._onModelChangeBefore, this);
          this.adapter.modelManager.on(ModelManager.Event.ON_INSERT, this._updateGroups, this);
          this.adapter.modelManager.on(ModelManager.Event.ON_REMOVE, this._updateGroups, this);
          this.adapter.modelManager.on(ModelManager.Event.ON_MOVE, this._updateGroups, this);
          this.adapter.modelManager.on(ModelManager.Event.ON_CLEAR, this._onClearModel, this);
          this.adapter.scrollManager.on(ScrollManager.Event.ON_SCROLL, this._onScroll, this);
          this.adapter.scrollManager.on(ScrollManager.Event.ON_VIEW_SIZE_CHANGED, this._resetAllState, this);
          this.adapter.scrollManager.on(ScrollManager.Event.ON_CHANGED_ORIENTATION, this._resetAllState, this);
        };
        _proto._clearAll = function _clearAll() {
          var _this$_cacheGroups;
          for (var i = 0, len = this._visibleViews.length; i < len; i++) {
            this._recycleViewToDisableViews(this._visibleViews[i]);
          }
          (_this$_cacheGroups = this._cacheGroups).push.apply(_this$_cacheGroups, this._groups);
          this._clearFixedViews();
          this._visibleViews.length = 0;
          this._groups.length = 0;
          this.virtualSize = 0;
          this.overflowHeader = 0;
        };
        _proto._onClearModel = function _onClearModel() {
          this._clearAll();
          this.emit(Event.ON_CLEARVIEWS);
        };
        _proto._resetAllState = function _resetAllState() {
          this._clearAll();
          this.internal_updateVisibleView(0);
          this.emit(Event.ON_RESET_ALL_STATE);
        }
        /**
         * header
         */;
        _proto._onModelChangeBefore = function _onModelChangeBefore() {
          if (!this.header) return;
          // 0
          if (this.virtualSize > this.adapter.mainAxisSize) {
            var index = this.getVisibleIndexByGroupIndex(0);
            if (-1 != index) {
              var header = this._visibleViews[index];
              this._cacheHeadeDatas = header.group.models.map(function (item) {
                return item.data;
              });
              this._cacheHeadePosition = {
                x: header.group.position.x,
                y: header.group.position.y
              };
            } else {
              this._cacheHeadeDatas = this.header.group.models.map(function (item) {
                return item.data;
              });
              this._cacheHeadePosition = {
                x: this.header.group.position.x,
                y: this.header.group.position.y
              };
            }
          }
        }
        /**
         * Group
         */;
        _proto._updateGroups = function _updateGroups(insertIndex) {
          var _this$_cacheGroups2,
            _this2 = this;
          var view = this._getViewFromDisibleViews(null);
          var gindex = this.getGroupIndexByModelIndex(insertIndex);
          if (-1 == gindex) {
            gindex = this._groupLength - 1;
          }
          var group = null;
          var clear = false;
          var options = {
            modelIndex: insertIndex,
            fixedIndex: -1
          };
          var prevGroup = this._groups[gindex - 1];
          if (prevGroup) {
            options.fixedIndex = prevGroup.fixedIndex;
          }
          while (true) {
            group = this._groups[gindex];
            if (!group) {
              group = this._getGroupFromCache();
              group.internal_setIndex(this._groups.length);
              this._groups.push(group);
              gindex = this._groups.length;
            }
            var ok = group.internal_insert(options, view, clear);
            gindex++;
            clear = true;
            if (!ok) {
              break;
            }
          }
          var caches = this._groups.splice(gindex, this._groups.length);
          (_this$_cacheGroups2 = this._cacheGroups).push.apply(_this$_cacheGroups2, caches);
          this._groupLength = this._groups.length;
          // 
          var referIndex = -1;
          var virtualSize = 0;
          if (this._cacheHeadeDatas.length > 0) {
            referIndex = this._groups.findIndex(function (item) {
              return item.internal_includes(_this2._cacheHeadeDatas);
            });
          }
          var relative = this._groups[referIndex];
          if (relative) {
            // 
            virtualSize += relative.size[this.adapter.mainAxis] + this.spacing;
            relative.internal_setPosition(this._cacheHeadePosition[this.adapter.mainAxis]);
          }
          // 
          for (var i = referIndex - 1; i >= 0; i--) {
            var curr = this._groups[i];
            this._calcMainAxisPosition(curr, relative, MagneticDirection.Header);
            virtualSize += curr.size[this.adapter.mainAxis] + this.spacing;
            relative = curr;
          }
          relative = this._groups[referIndex];
          // 
          for (var _i = referIndex + 1; _i < this.groupLength; _i++) {
            var curr = this._groups[_i];
            this._calcMainAxisPosition(curr, relative, MagneticDirection.Footer);
            virtualSize += curr.size[this.adapter.mainAxis] + this.spacing;
            relative = curr;
          }
          virtualSize -= this.spacing;
          this._virtualSize = Math.max(0, virtualSize);
          this._resetOverflowHeader(this._groups[0]);
          view.internal_reset();
          this._disableViews.push(view);
          this.updateVisibles(referIndex);
          this._cacheHeadeDatas = [];
          this._cacheHeadePosition = null;
        };
        _proto.updateVisibles = function updateVisibles(referIndex) {
          var cacheHolders = [];
          referIndex = Math.max(0, referIndex);
          var findHolder = function findHolder(model) {
            var index = cacheHolders.findIndex(function (holder) {
              return holder.oldData == model.data;
            });
            if (-1 != index) {
              return cacheHolders.splice(index, 1)[0];
            }
            return null;
          };
          // holder
          for (var i = 0; i < this._visibleViews.length; i++) {
            var _view = this._visibleViews[i];
            cacheHolders = cacheHolders.concat(_view.holderList);
            _view.internal_reset();
          }
          var mainAxisSize = this.adapter.mainAxisSize;
          var visibleIndex = 0;
          var length = this.visibleLength;
          for (var _i2 = referIndex, len = this._groups.length; _i2 < len; _i2++) {
            var group = this._groups[_i2];
            var visibleSize = this.getVisibleMainAxisSize();
            if (visibleSize >= mainAxisSize && length <= 0) {
              break;
            }
            var view = this._visibleViews[visibleIndex++];
            if (!view) {
              view = this._getViewFromDisibleViews(group.index);
              this._visibleViews.push(view);
            }
            // Holder
            view.internal_preVisible(group, findHolder);
            length--;
          }
          // view
          for (var _i3 = this._visibleViews.length - 1; _i3 >= 0; _i3--) {
            var view = this._visibleViews[_i3];
            if (view.holderList.length > 0) {
              break;
            }
            this._disableFromVisibleViews(_i3);
          }
          // holder
          for (var _i4 = 0, _len2 = cacheHolders.length; _i4 < _len2; _i4++) {
            var holder = cacheHolders[_i4];
            holder.internal_disable();
            this._disableHolders.push(holder);
          }
          // HolderHolderHolder
          // 
          for (var _i5 = 0; _i5 < this.visibleLength; _i5++) {
            this._visibleViews[_i5].internal_visible();
          }
          this._forceFill();
          this._calcMagnetic();
          this.emit(Event.ON_UPDATE_VIEWS);
        };
        _proto._getGroupFromCache = function _getGroupFromCache() {
          var group = this._cacheGroups.pop();
          if (!group) {
            group = new Group(this.adapter);
          }
          group.internal_reset();
          return group;
        };
        _proto._calcMagnetic = function _calcMagnetic() {
          if (!this.magnetic) return;
          if (!this.header) return;
          var ok = false;
          if (this.adapter.scrollManager.velocity == 0) {
            if (this.magneticDirection == MagneticDirection.Footer) {
              if (this.footer.index == this._groupLength - 1) {
                this.adapter.scrollManager.scrollToFooter(this.magneticDuration);
                ok = true;
              }
            } else {
              if (this.header.index == 0) {
                this.adapter.scrollManager.scrollToHeader(this.magneticDuration);
                ok = true;
              }
            }
          }
          this.emit(Event.ON_MAGNETIC, ok);
        };
        _proto._calcMainAxisPosition = function _calcMainAxisPosition(group, relativeGroup, direction) {
          if (!group) return;
          if (!relativeGroup) {
            // this._setGroupPosition(group, this._getMainAxisHeaderPosition(group))
            group.internal_setPosition(this._getMainAxisHeaderPosition(group));
          } else {
            var xy = this.adapter.mainAxis;
            var multiplier = this.adapter.multiplier;
            var dirMultiplier = direction == MagneticDirection.Footer ? 1 : -1;
            var relPoint, curPoint;
            if (direction == MagneticDirection.Footer) {
              relPoint = multiplier == 1 ? relativeGroup.anchorPoint[xy] : 1 - relativeGroup.anchorPoint[xy];
              curPoint = multiplier == 1 ? 1 - group.anchorPoint[xy] : group.anchorPoint[xy];
            } else {
              relPoint = multiplier == 1 ? 1 - relativeGroup.anchorPoint[xy] : relativeGroup.anchorPoint[xy];
              curPoint = multiplier == 1 ? group.anchorPoint[xy] : 1 - group.anchorPoint[xy];
            }
            var position = relativeGroup.position[xy];
            position -= relativeGroup.size[xy] * relPoint * dirMultiplier * multiplier;
            position -= this.spacing * multiplier * dirMultiplier;
            position -= group.size[xy] * curPoint * dirMultiplier * multiplier;
            // this._setGroupPosition(group, position)
            group.internal_setPosition(position);
          }
        };
        _proto._getMainAxisHeaderPosition = function _getMainAxisHeaderPosition(group) {
          var position = 0;
          var anchor = 0;
          if (this.adapter.isVertical) {
            position = this.adapter.isArrangeAxisStart ? -this.top : this.bottom;
            anchor = this.adapter.isArrangeAxisStart ? 1 - group.anchorPoint[this.adapter.mainAxis] : group.anchorPoint[this.adapter.mainAxis];
          } else {
            position = this.adapter.isArrangeAxisStart ? this.left : -this.right;
            anchor = this.adapter.isArrangeAxisStart ? group.anchorPoint[this.adapter.mainAxis] : 1 - group.anchorPoint[this.adapter.mainAxis];
          }
          position -= anchor * group.size[this.adapter.mainAxis] * this.adapter.multiplier;
          return position;
        };
        _proto._getViewFromDisibleViews = function _getViewFromDisibleViews(groupIndex) {
          var view = null;
          if (groupIndex != null) {
            var index = this._fixedViews.findIndex(function (view) {
              return view.index == groupIndex;
            });
            if (-1 != index) {
              var remView = this._fixedViews.splice(index, 1)[0];
              this._recycleViewToDisableViews(remView);
            }
          }
          if (!view) {
            view = this._disableViews.pop();
          }
          if (!view) {
            view = this.adapter.getView();
          }
          return view;
        };
        _proto._getHolderFromDisableHolders = function _getHolderFromDisableHolders(model) {
          var index = this._disableHolders.findIndex(function (holder) {
            return holder.code == model.code;
          });
          if (-1 != index) {
            return this._disableHolders.splice(index, 1)[0];
          }
        }
        /**
         *  view 
         * @param visibleIndex view
         */;
        _proto._disableFromVisibleViews = function _disableFromVisibleViews(visibleIndexOrView) {
          var remIndex = -1;
          if (visibleIndexOrView instanceof View) {
            remIndex = this._visibleViews.findIndex(function (item) {
              return item.index == visibleIndexOrView.index;
            });
          } else {
            remIndex = visibleIndexOrView;
          }
          this._recycleViewToDisableViews(this._visibleViews[remIndex]);
          this._visibleViews.splice(remIndex, 1);
        };
        _proto._recycleViewToDisableViews = function _recycleViewToDisableViews(view) {
          var _this3 = this;
          if (!view) return;
          view.internal_recycleHolders(function (holder) {
            return _this3._disableHolders.push(holder);
          });
          view.internal_disable();
          this._disableViews.push(view);
        };
        _proto._clearFixedViews = function _clearFixedViews() {
          for (var i = 0, len = this._fixedViews.length; i < len; i++) {
            var view = this._fixedViews[i];
            this._recycleViewToDisableViews(view);
          }
          this._fixedViews.length = 0;
        };
        _proto._checkHeaderInvisible = function _checkHeaderInvisible() {
          if (!this.header) return;
          if (!this.loopFooter && this.footer.index == this.groupLength - 1) {
            return;
          }
          if (this._isOverflowHeader(this.header.group)) {
            this._disableFromVisibleViews(0);
            this._checkHeaderInvisible();
          }
        };
        _proto._checkFooterInvisible = function _checkFooterInvisible() {
          if (!this.footer) return;
          if (!this.loopHeader && this.header.index == 0) {
            return;
          }
          if (this._isOverflowFooter(this.footer.group)) {
            this._disableFromVisibleViews(this._visibleViews.length - 1);
            this._checkFooterInvisible();
          }
        };
        _proto._isOverflowHeader = function _isOverflowHeader(group, defaultOffset) {
          if (defaultOffset === void 0) {
            defaultOffset = this.overflowOffset;
          }
          var footerBoundary = this.internal_getGroupFooterBoundary(group);
          defaultOffset = defaultOffset * group.size[this.adapter.mainAxis];
          return this.adapter.multiplier == 1 ? footerBoundary >= defaultOffset : footerBoundary <= -defaultOffset;
        };
        _proto._isOverflowFooter = function _isOverflowFooter(group, defaultOffset) {
          if (defaultOffset === void 0) {
            defaultOffset = this.overflowOffset;
          }
          var headerBoundary = this.internal_getGroupHeaderBoundary(group);
          defaultOffset = defaultOffset * group.size[this.adapter.mainAxis];
          return this.adapter.multiplier == 1 ? headerBoundary + this.adapter.mainAxisSize <= -defaultOffset : headerBoundary - this.adapter.mainAxisSize >= defaultOffset;
        };
        _proto._isEnterFooter = function _isEnterFooter(group) {
          if (!group) return false;
          var footerBoundary = this.internal_getGroupFooterBoundary(group);
          var defaultOffset = this.enterOffset * group.size[this.adapter.mainAxis];
          return this.adapter.multiplier == 1 ? footerBoundary + this.adapter.mainAxisSize + defaultOffset >= 0 : footerBoundary - this.adapter.mainAxisSize - defaultOffset <= 0;
        };
        _proto._isEnterHeader = function _isEnterHeader(group) {
          if (!group) return false;
          var headerBoundary = this.internal_getGroupHeaderBoundary(group);
          var defaultOffset = this.overflowOffset * group.size[this.adapter.mainAxis];
          return this.adapter.multiplier == 1 ? headerBoundary - defaultOffset <= 0 : headerBoundary + defaultOffset >= 0;
        };
        _proto._fillHeader = function _fillHeader() {
          var group = this._groups[this._headerIndex];
          if (!this._isEnterHeader(group)) {
            return;
          }
          // 
          var _this$_accumTargetSiz = this._accumTargetSizeTowardsHeader(group.index, this.internal_getInitHeaderSize(group)),
            index = _this$_accumTargetSiz.index,
            size = _this$_accumTargetSiz.size;
          var target = this._groups[index];
          if (!target) {
            return;
          }
          if (-1 != this.getVisibleIndexByGroupIndex(index)) {
            return;
          }
          var position = this.internal_convertSizeToHeaderPosition(size, target);
          // this._setGroupPosition(target, position)
          target.internal_setPosition(position);
          var view = this._getViewFromDisibleViews(target.index);
          this._visibleViews.unshift(view);
          view.internal_preVisible(target).internal_visible();
          if (view.index == 0) {
            this._resetOverflowHeader(view.group);
          }
          this._headerIndex = target.index;
          this._fillHeader();
        };
        _proto._fillFooter = function _fillFooter() {
          var group = this._groups[this._footerIndex];
          if (!this._isEnterFooter(group)) {
            return;
          }
          // 
          var _this$_accumTargetSiz2 = this._accumTargetSizeTowardsFooter(group.index, this.internal_getInitFooterSize(group)),
            index = _this$_accumTargetSiz2.index,
            size = _this$_accumTargetSiz2.size;
          var target = this._groups[index];
          if (!target) {
            return;
          }
          if (-1 != this.getVisibleIndexByGroupIndex(index)) {
            return;
          }
          var position = this.internal_convertSizeToFooterPosition(size, target);
          target.internal_setPosition(position);
          // this._setGroupPosition(target, position)
          var view = this._getViewFromDisibleViews(target.index);
          this._visibleViews.push(view);
          view.internal_preVisible(target).internal_visible();
          if (view.index == 0) {
            this._resetOverflowHeader(view.group);
          }
          this._footerIndex = target.index;
          this._fillFooter();
        };
        _proto._fillFixedView = function _fillFixedView() {
          if (!this.header || this.header.group.fixedIndex == -1 && !this.header.group.isFixed) {
            return;
          }
          var startIndex = this.header.index;
          var mainAxis = this.adapter.mainAxis;
          // fixed
          var size = this.internal_getInitHeaderSize(this.header.group);
          for (var i = startIndex - 1; i >= 0; i--) {
            var group = this._groups[i];
            if (!group) {
              console.error("_fillFixedView group", i);
              return;
            }
            size += group.size[mainAxis] + this.spacing;
            if (!group.isFixed) {
              continue;
            }
            var position = this.internal_convertSizeToHeaderPosition(size, group);
            if (-1 != this._fixedViews.findIndex(function (view) {
              return view.index == group.index;
            })) {
              if (!Helper.approximately(position, group.position[mainAxis])) {
                // this._setGroupPosition(group, position)
                group.internal_setPosition(position);
                this.adapter.layoutManager.layout(group);
              }
              break;
            }
            this._clearFixedViews();
            var position = this.internal_convertSizeToHeaderPosition(size, group);
            // this._setGroupPosition(group, position)
            group.internal_setPosition(position);
            var view = this._getViewFromDisibleViews(group.index);
            view.internal_preVisible(group).internal_visible();
            this._fixedViews.push(view);
            break;
          }
        };
        _proto._accumTargetSizeTowardsHeader = function _accumTargetSizeTowardsHeader(index, size) {
          var length = this._groups.length;
          do {
            if (index == 0) {
              if (this.loopHeader) {
                index = length;
              }
            }
            if (index == 0) {
              return {
                index: index,
                size: size
              };
            }
            index--;
            var info = this._groups[index];
            if (!info) {
              return {
                index: index,
                size: size
              };
            }
            size += this.internal_accumulationSize(index);
            if (size >= 0) {
              return {
                index: index,
                size: size
              };
            }
          } while (true);
        };
        _proto._accumTargetSizeTowardsFooter = function _accumTargetSizeTowardsFooter(index, size) {
          var length = this._groups.length;
          do {
            if (index == length - 1) {
              if (this.loopFooter) {
                index = -1;
              }
            }
            if (index == length - 1) {
              return {
                index: index,
                size: size
              };
            }
            index++;
            var viewInfo = this._groups[index];
            if (!viewInfo) {
              return {
                index: index,
                size: size
              };
            }
            size += this.internal_accumulationSize(index);
            if (size >= 0) {
              return {
                index: index,
                size: size
              };
            }
          } while (true);
        };
        _proto._fillFooterHandle = function _fillFooterHandle() {
          this._checkHeaderInvisible();
          this._fillFooter();
        };
        _proto._fillHeaderHandle = function _fillHeaderHandle() {
          this._checkFooterInvisible();
          this._fillHeader();
        };
        _proto._forceFill = function _forceFill() {
          this._updateHeaderFooterIndex();
          this._fillHeaderHandle();
          this._fillFooterHandle();
        };
        _proto._updateHeaderFooterIndex = function _updateHeaderFooterIndex() {
          this._headerIndex = this.header ? this.header.index : 0;
          this._footerIndex = this.footer ? this.footer.index : 0;
        };
        _proto._onScroll = function _onScroll(direction) {
          if (this._groups.length == 0) return;
          this._updateHeaderFooterIndex();
          switch (direction) {
            case ScrollDirection.Up:
            case ScrollDirection.Left:
              //  
              if (this.adapter.isArrangeAxisStart) {
                this._fillFooterHandle();
              } else {
                this._fillHeaderHandle();
              }
              break;
            case ScrollDirection.Down:
            case ScrollDirection.Right:
              // 
              if (this.adapter.isArrangeAxisStart) {
                this._fillHeaderHandle();
              } else {
                this._fillFooterHandle();
              }
              break;
          }
          this._fillFixedView();
          this.emit(Event.ON_SCROLL);
        }
        /**
         * 
         */;
        _proto._stretchToHeader = function _stretchToHeader(current, start) {
          //  
          var prev = this._visibleViews[current];
          for (var i = start; i >= 0; i--) {
            var curr = this._visibleViews[i];
            if (prev) {
              this._calcMainAxisPosition(curr.group, prev.group, MagneticDirection.Header);
              this.adapter.layoutManager.layout(curr.group);
            } else if (this.getVisibleMainAxisSize() < this.adapter.mainAxisSize) {
              this._calcMainAxisPosition(curr.group, null, MagneticDirection.Header);
            }
            prev = curr;
          }
        }
        /**
         * 
         */;
        _proto._stretchToFooter = function _stretchToFooter(current, start) {
          //  
          var prev = this._visibleViews[current];
          for (var i = start; i < this._visibleViews.length; i++) {
            var curr = this._visibleViews[i];
            if (prev) {
              this._calcMainAxisPosition(curr.group, prev.group, MagneticDirection.Footer);
              this.adapter.layoutManager.layout(curr.group);
            } else if (this.getVisibleMainAxisSize() < this.adapter.mainAxisSize) {
              this._calcMainAxisPosition(curr.group, null, MagneticDirection.Footer);
            }
            prev = curr;
          }
        }
        /**
         * overflowHeader 0
         */;
        _proto._resetOverflowHeader = function _resetOverflowHeader(group) {
          if (!group) return this.overflowHeader = 0;
          var mainAxis = this.adapter.mainAxis;
          var anchor = group.anchorPoint[mainAxis];
          anchor = this.adapter.multiplier == 1 ? 1 - anchor : anchor;
          var offset = group.position[mainAxis];
          offset += group.size[mainAxis] * anchor * this.adapter.multiplier;
          this.overflowHeader = offset;
        }
        /**
        * item content
        */;
        _proto._calcOverflowHeader = function _calcOverflowHeader(group, centerIndex, visibleIndex) {
          var zero = this.getVisibleIndexByGroupIndex(0);
          if (-1 != zero) {
            var header = this._visibleViews[zero];
            return this._resetOverflowHeader(header.group);
          }
          var mainAxis = this.adapter.mainAxis;
          var anchor = group.anchorPoint[mainAxis];
          anchor = this.adapter.multiplier == 1 ? 1 - anchor : anchor;
          var oldSize = group.oldSize[mainAxis];
          var newSize = group.size[mainAxis];
          var multiplier = this.adapter.multiplier;
          switch (this.stretchDirection) {
            case StretchDirection.Header:
              //
              // itemtestNode 
              // overflowHeader 
              var oldOffset = group.oldPosition[mainAxis] + oldSize * anchor * multiplier;
              var ok = multiplier == 1 ? this.overflowHeader >= oldOffset : this.overflowHeader <= oldOffset;
              if (ok) {
                this.overflowHeader += (newSize - oldSize) * multiplier;
              }
              break;
            case StretchDirection.Footer:
              //
              var oldOffset = group.oldPosition[mainAxis] + oldSize * anchor * multiplier;
              var ok = multiplier == 1 ? this.overflowHeader >= oldOffset : this.overflowHeader <= oldOffset;
              if (ok) ;else {
                this.overflowHeader -= (newSize - oldSize) * multiplier;
              }
              break;
            case StretchDirection.Center:
              //
              var oldOffset = group.oldPosition[mainAxis] + oldSize * anchor * multiplier;
              var ok = multiplier == 1 ? this.overflowHeader >= oldOffset : this.overflowHeader <= oldOffset;
              if (ok) {
                this.overflowHeader += (newSize - oldSize) * 0.5 * multiplier;
              } else {
                this.overflowHeader -= (newSize - oldSize) * 0.5 * multiplier;
              }
              break;
            case StretchDirection.Auto:
              //
              var oldOffset = group.oldPosition[mainAxis] + oldSize * anchor * multiplier;
              var ok = multiplier == 1 ? this.overflowHeader >= oldOffset : this.overflowHeader <= oldOffset;
              if (centerIndex <= visibleIndex) {
                oldOffset = group.oldPosition[mainAxis] + oldSize * anchor * multiplier;
                ok = multiplier == -1 ? this.overflowHeader >= oldOffset : this.overflowHeader <= oldOffset;
              }
              if (ok) {
                if (centerIndex <= visibleIndex) {
                  this.overflowHeader -= (newSize - oldSize) * multiplier;
                } else {
                  this.overflowHeader += (newSize - oldSize) * multiplier;
                }
              }
              break;
          }
        }
        /** @deprecated  */;
        _proto.internal_lateUpdate = function internal_lateUpdate(deltaTime) {
          if (this._isFill) {
            this._isFill = false;
            this._forceFill();
          }
          this.emit(Event.ON_LATEUPDATE, deltaTime);
        }
        /** @deprecated  */;
        _proto.internal_viewChanged = function internal_viewChanged(view, oldMainAxisSize) {
          var cross = view.group.size[this.adapter.mainAxis] - oldMainAxisSize;
          this.virtualSize += cross;
          var visibleIndex = this.getVisibleIndexByGroupIndex(view.index);
          var centerIndex = -1;
          if (this.getVisibleMainAxisSize() < this.adapter.mainAxisSize || this.stretchDirection == StretchDirection.Footer) {
            //  
            var prev = visibleIndex - 1;
            if (!this._visibleViews[prev]) {
              this.adapter.layoutManager.layout(view.group);
            }
            this._stretchToFooter(prev, visibleIndex);
          } else if (this.stretchDirection == StretchDirection.Header) {
            //  
            var _prev = visibleIndex + 1;
            if (!this._visibleViews[_prev]) {
              this.adapter.layoutManager.layout(view.group);
            }
            this._stretchToHeader(_prev, visibleIndex);
          } else if (this.stretchDirection == StretchDirection.Center) {
            this.adapter.layoutManager.layout(view.group);
            this._stretchToHeader(visibleIndex, visibleIndex - 1);
            this._stretchToFooter(visibleIndex, visibleIndex + 1);
          } else {
            centerIndex = this.adapter.centerManager.getCenterVisibleIndex();
            if (-1 != centerIndex) {
              var center = this._visibleViews[centerIndex];
              this.adapter.layoutManager.layout(center.group);
              this._stretchToHeader(centerIndex, centerIndex - 1);
              this._stretchToFooter(centerIndex, centerIndex + 1);
            } else {
              throw Error("" + view.index);
            }
          }
          //  
          this._calcOverflowHeader(view.group, centerIndex, visibleIndex);
          if (this.magneticSizeChanges) {
            this._calcMagnetic();
          }
          this._isFill = true;
          this.emit(Event.ON_CHANGED_VIRTUALSIZE);
        }
        /** @deprecated  */;
        _proto.internal_getHolder = function internal_getHolder(model) {
          var holder = this._getHolderFromDisableHolders(model);
          if (!holder) {
            var prefab = this.adapter.getPrefab(model.data);
            var node = instantiate(prefab);
            holder = this.adapter.getHolder(node, model.code);
          }
          holder.node.parent = this.adapter.scrollManager.getLayerNode(model.element.layer);
          return holder;
        }
        /** @deprecated  */;
        _proto.internal_updateVisibleView = function internal_updateVisibleView(index) {
          // 
          this._onModelChangeBefore();
          this._updateGroups(index);
        }
        /** @deprecated  */;
        _proto.internal_getGroupFooterBoundary = function internal_getGroupFooterBoundary(group) {
          if (!group) return 0;
          var anchor = group.anchorPoint[this.adapter.mainAxis];
          anchor = this.adapter.multiplier == 1 ? anchor : 1 - anchor;
          var value = group.position[this.adapter.mainAxis];
          value -= group.size[this.adapter.mainAxis] * anchor * this.adapter.multiplier;
          value += this.adapter.scrollManager.contentPosition;
          return value;
        }
        /** @deprecated  */;
        _proto.internal_getGroupHeaderBoundary = function internal_getGroupHeaderBoundary(group) {
          if (!group) return 0;
          var anchor = group.anchorPoint[this.adapter.mainAxis];
          anchor = this.adapter.multiplier == 1 ? 1 - anchor : anchor;
          var value = group.position[this.adapter.mainAxis] + this.adapter.scrollManager.contentPosition + anchor * group.size[this.adapter.mainAxis] * this.adapter.multiplier;
          return value;
        }
        /** @deprecated  */;
        _proto.internal_getInitHeaderSize = function internal_getInitHeaderSize(group) {
          if (!group) return 0;
          var anchor = group.anchorPoint[this.adapter.mainAxis];
          anchor = this.adapter.multiplier == 1 ? 1 - anchor : anchor;
          var value = -group.position[this.adapter.mainAxis] * this.adapter.multiplier;
          value -= group.size[this.adapter.mainAxis] * anchor;
          value -= this.adapter.scrollManager.contentPosition * this.adapter.multiplier;
          value = this.adapter.mainAxisSize - value;
          return value;
        }
        /** @deprecated  */;
        _proto.internal_getInitFooterSize = function internal_getInitFooterSize(group) {
          if (!group) return 0;
          var anchor = group.anchorPoint[this.adapter.mainAxis];
          anchor = this.adapter.multiplier == 1 ? anchor : 1 - anchor;
          var value = -group.position[this.adapter.mainAxis] * this.adapter.multiplier;
          value += group.size[this.adapter.mainAxis] * anchor;
          value -= this.adapter.scrollManager.contentPosition * this.adapter.multiplier;
          return value;
        }
        /** @deprecated  */;
        _proto.internal_accumulationSize = function internal_accumulationSize(index) {
          var group = this._groups[index];
          if (!group) return 0;
          return group.size[this.adapter.mainAxis] + this.spacing;
        }
        /** @deprecated  */;
        _proto.internal_convertSizeToFooterPosition = function internal_convertSizeToFooterPosition(totalSize, group) {
          var anchor = group.anchorPoint[this.adapter.mainAxis];
          anchor = this.adapter.multiplier == 1 ? anchor : 1 - anchor;
          var size = group.size[this.adapter.mainAxis] * anchor;
          var value = -this.adapter.scrollManager.contentPosition;
          value -= this.adapter.multiplier * totalSize - this.adapter.multiplier * size;
          return value;
        }
        /** @deprecated  */;
        _proto.internal_convertSizeToHeaderPosition = function internal_convertSizeToHeaderPosition(totalSize, group) {
          var anchor = group.anchorPoint[this.adapter.mainAxis];
          anchor = this.adapter.multiplier == 1 ? 1 - anchor : anchor;
          var size = group.size[this.adapter.mainAxis] * anchor;
          var value = this.adapter.multiplier * totalSize - this.adapter.multiplier * size;
          value -= this.adapter.multiplier * this.adapter.mainAxisSize;
          value -= this.adapter.scrollManager.contentPosition;
          return value;
        }
        // public
        ;

        _proto.getGroup = function getGroup(index) {
          return this._groups[index];
        };
        _proto.getVisibleView = function getVisibleView(index) {
          return this._visibleViews[index];
        };
        _proto.getVisibleMainAxisSize = function getVisibleMainAxisSize() {
          if (this._visibleViews.length == 0) return 0;
          var size = 0;
          var xy = this.adapter.mainAxis;
          for (var i = 0, len = this._visibleViews.length; i < len; i++) {
            var view = this._visibleViews[i];
            if (view.group) {
              size += view.group.size[xy] + this.spacing;
            }
          }
          size -= this.spacing;
          return size;
        };
        _proto.getGroupIndexByModelIndex = function getGroupIndexByModelIndex(modelIndex) {
          for (var i = 0, len = this._groups.length; i < len; i++) {
            var group = this._groups[i];
            var index = group.findModelIndex(modelIndex);
            if (-1 != index) return i;
          }
          return -1;
        };
        _proto.getVisibleIndexByGroupIndex = function getVisibleIndexByGroupIndex(index) {
          return this._visibleViews.findIndex(function (view) {
            return view.index == index;
          });
        };
        _proto.getNextFixedHolders = function getNextFixedHolders(index) {
          var list = [];
          var start = this.getVisibleIndexByGroupIndex(index);
          for (var i = start + 1, len = this._visibleViews.length; i < len; i++) {
            var view = this._visibleViews[i];
            if (view.index == index) continue;
            if (view.group.isFixed) {
              list = view.getFixedHolders();
              break;
            }
          }
          return list;
        };
        _proto.getMagneticOffset = function getMagneticOffset() {
          if (!this.magnetic) {
            return 0;
          }
          var direction = this.adapter.isHorizontal ? -this.adapter.multiplier : this.adapter.multiplier;
          if (this.magneticDirection == MagneticDirection.Footer) {
            if (!this.footer) {
              return this.adapter.mainAxisSize * direction;
            }
            var value = Math.max(0, this.adapter.mainAxisSize - this.adapter.mainAxisPadding - this.getVisibleMainAxisSize()) * direction;
            return value;
          }
          return 0;
        };
        _createClass(ViewManager, [{
          key: "arrangeAxis",
          get: function get() {
            return this._arrangeAxis;
          },
          set: function set(value) {
            if (value == this._arrangeAxis) return;
            this._arrangeAxis = value;
            this._resetAllState();
          }
        }, {
          key: "spacing",
          get: function get() {
            return this._spacing;
          },
          set: function set(value) {
            if (value == this._spacing) return;
            this._spacing = value;
            this._resetAllState();
          }
        }, {
          key: "header",
          get: function get() {
            return this._visibleViews[0];
          }
        }, {
          key: "footer",
          get: function get() {
            return this._visibleViews[this._visibleViews.length - 1];
          }
        }, {
          key: "overflowHeader",
          get: function get() {
            return this._overflowHeader;
          },
          set: function set(value) {
            if (value == this._overflowHeader) return;
            this._overflowHeader = value;
            this.emit(Event.ON_CHANGED_OVERFLOWHEADER, value);
          }
        }, {
          key: "virtualSize",
          get: function get() {
            return this._virtualSize;
          },
          set: function set(value) {
            if (value == this._virtualSize) return;
            this._virtualSize = value;
            this.emit(Event.ON_CHANGED_VIRTUALSIZE);
          }
        }, {
          key: "groupLength",
          get: function get() {
            return this._groupLength;
          }
        }, {
          key: "visibleLength",
          get: function get() {
            return this._visibleViews.length;
          }
        }, {
          key: "min",
          get: function get() {
            if (!this.header) return 0;
            var value = this.adapter.isArrangeAxisStart ? this.internal_getGroupFooterBoundary(this.footer.group) : this.internal_getGroupHeaderBoundary(this.header.group);
            return value;
          }
        }, {
          key: "max",
          get: function get() {
            if (!this.header) return 0;
            var value = this.adapter.isArrangeAxisStart ? this.internal_getGroupHeaderBoundary(this.header.group) : this.internal_getGroupFooterBoundary(this.footer.group);
            return value;
          }
        }]);
        return ViewManager;
      }(Manager), _class3.Event = Event, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "_arrangeAxis", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return ArrangeAxis.Start;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "arrangeAxis", [_dec3], Object.getOwnPropertyDescriptor(_class2.prototype, "arrangeAxis"), _class2.prototype), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "stretchDirection", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return StretchDirection.Auto;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "overflowOffset", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.3;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "enterOffset", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_spacing", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "spacing", [_dec7], Object.getOwnPropertyDescriptor(_class2.prototype, "spacing"), _class2.prototype), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "left", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "right", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "top", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "bottom", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "magnetic", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "magneticDirection", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return MagneticDirection.Header;
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "magneticDuration", [_dec14], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return 0.5;
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "magneticSizeChanges", [_dec15], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, "loopHeader", [_dec16], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      }), _descriptor15 = _applyDecoratedDescriptor(_class2.prototype, "loopFooter", [_dec17], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return false;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/VisiblePanel.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _inheritsLoose, _initializerDefineProperty, _assertThisInitialized, cclegacy, _decorator, Node, UIOpacity, tween, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _inheritsLoose = module.inheritsLoose;
      _initializerDefineProperty = module.initializerDefineProperty;
      _assertThisInitialized = module.assertThisInitialized;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Node = module.Node;
      UIOpacity = module.UIOpacity;
      tween = module.tween;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "c5c0fR4sOtBf6AVBLMy1WNE", "VisiblePanel", undefined);
      var ccclass = _decorator.ccclass,
        property = _decorator.property;
      var VisiblePanel = exports('VisiblePanel', (_dec = ccclass('VisiblePanel'), _dec2 = property({
        type: Node,
        group: "VisiblePanel"
      }), _dec(_class = (_class2 = /*#__PURE__*/function (_Component) {
        _inheritsLoose(VisiblePanel, _Component);
        function VisiblePanel() {
          var _this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _Component.call.apply(_Component, [this].concat(args)) || this;
          _initializerDefineProperty(_this, "indicator", _descriptor, _assertThisInitialized(_this));
          _this.opMain = null;
          _this.onVisibleChanged = void 0;
          _this.tweenOpacity = null;
          return _this;
        }
        var _proto = VisiblePanel.prototype;
        _proto.setPanelVisible = function setPanelVisible(isVisible, timeAction, isNodeDeactivable) {
          var _this$tweenOpacity,
            _this2 = this;
          if (timeAction === void 0) {
            timeAction = 0.35;
          }
          if (isNodeDeactivable === void 0) {
            isNodeDeactivable = true;
          }
          if (!this.opMain) {
            this.opMain = this.getComponent(UIOpacity);
            if (this.opMain == null) {
              this.opMain = this.addComponent(UIOpacity);
            }
          }
          if (timeAction <= 0.0) {
            this.opMain.opacity = isVisible ? 255.0 : 0.0;
          }
          if (isVisible && isNodeDeactivable) {
            this.node.active = true;
            if (this.indicator) this.indicator.active = true;
          }
          this.opMain.opacity = isVisible ? 0.0 : 255.0;
          (_this$tweenOpacity = this.tweenOpacity) == null || _this$tweenOpacity.stop();
          this.tweenOpacity = tween(this.opMain).to(timeAction, {
            opacity: isVisible ? 255.0 : 0.0
          }).call(function () {
            if (!isVisible && isNodeDeactivable) {
              _this2.node.active = false;
              if (_this2.indicator) _this2.indicator.active = false;
            }
            _this2.visibleChanged(isVisible);
          }).start();
        };
        _proto.visibleChanged = function visibleChanged(isVisible) {
          var _this$onVisibleChange;
          (_this$onVisibleChange = this.onVisibleChanged) == null || _this$onVisibleChange.call(this, isVisible);
        };
        return VisiblePanel;
      }(Component), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "indicator", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

(function(r) {
  r('virtual:///prerequisite-imports/main', 'chunks:///_virtual/main'); 
})(function(mid, cid) {
    System.register(mid, [cid], function (_export, _context) {
    return {
        setters: [function(_m) {
            var _exportObj = {};

            for (var _key in _m) {
              if (_key !== "default" && _key !== "__esModule") _exportObj[_key] = _m[_key];
            }
      
            _export(_exportObj);
        }],
        execute: function () { }
    };
    });
});